<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JS,">










<meta name="description" content="执行上下文 执行上下文是一个抽象的概念，我理解为执行代码时的环境中。每当JS代码运行的时候，他都是在执行上下文中运行。  执行上下文分为三种 全局执行上下文：默认或者说基础的上下文，不在函数中的代码执行时在全局上下文中。一个程序只有一个全局上下文。 函数执行上下文：每当调用一个函数时，会为这个函数创建一个新的上下文。函数执行上下文可以有无穷多个。 Eval函数执行上下文：行在 eval 函数内部的">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="JS执行机制">
<meta property="og:url" content="http://yoursite.com/2020/03/05/JS执行机制/index.html">
<meta property="og:site_name" content="Jerry&#39;s Blog">
<meta property="og:description" content="执行上下文 执行上下文是一个抽象的概念，我理解为执行代码时的环境中。每当JS代码运行的时候，他都是在执行上下文中运行。  执行上下文分为三种 全局执行上下文：默认或者说基础的上下文，不在函数中的代码执行时在全局上下文中。一个程序只有一个全局上下文。 函数执行上下文：每当调用一个函数时，会为这个函数创建一个新的上下文。函数执行上下文可以有无穷多个。 Eval函数执行上下文：行在 eval 函数内部的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/04/3IrvTJ.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/05/3TfO0I.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/05/3TIoVA.png">
<meta property="og:updated_time" content="2022-05-08T07:31:54.710Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS执行机制">
<meta name="twitter:description" content="执行上下文 执行上下文是一个抽象的概念，我理解为执行代码时的环境中。每当JS代码运行的时候，他都是在执行上下文中运行。  执行上下文分为三种 全局执行上下文：默认或者说基础的上下文，不在函数中的代码执行时在全局上下文中。一个程序只有一个全局上下文。 函数执行上下文：每当调用一个函数时，会为这个函数创建一个新的上下文。函数执行上下文可以有无穷多个。 Eval函数执行上下文：行在 eval 函数内部的">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/03/04/3IrvTJ.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/05/JS执行机制/">





  <title>JS执行机制 | Jerry's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jerry's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/JS执行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS执行机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-05T13:36:17+08:00">
                2020-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li>执行上下文是一个抽象的概念，我理解为执行代码时的环境中。每当JS代码运行的时候，他都是在执行上下文中运行。</li>
</ul>
<h5 id="执行上下文分为三种"><a href="#执行上下文分为三种" class="headerlink" title="执行上下文分为三种"></a>执行上下文分为三种</h5><ul>
<li>全局执行上下文：默认或者说基础的上下文，不在函数中的代码执行时在全局上下文中。一个程序只有一个全局上下文。</li>
<li>函数执行上下文：每当调用一个函数时，会为这个函数创建一个新的上下文。函数执行上下文可以有无穷多个。</li>
<li>Eval函数执行上下文：行在 eval 函数内部的代码也会有它属于自己的执行上下文，JavaScript 开发者并不经常使用 eval。</li>
</ul>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><ul>
<li>执行栈用来存储代码运行时创建的执行上下文。</li>
<li>代码开始执行时会创建全局执行上下文并压入栈底，每当引擎调用一个函数时，会为该函数创建函数执行上下文并且压入栈顶部。</li>
<li>引擎执行那些执行上下文位于栈顶的函数。当函数执行完毕时执行上下文从栈中弹出，控制流达到当前栈下一个执行上下文（顶部）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&apos;b&apos;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&apos;c&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&apos;d&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">console.log(&apos;e&apos;);</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IrvTJ.png" alt="image"></p>
<p>总结：</p>
<ol>
<li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
</ol>
<h3 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h3><ul>
<li>执行上下文创建包含三个阶段：创建阶段、执行阶段、回收阶段。</li>
</ul>
<h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><ul>
<li>创建阶段在函数被调用，但是还未执行任何代码之前。</li>
<li>主要完成三件事：创建变量对象，创建作用域链，决定this指向。</li>
</ul>
<h6 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h6><p>变量对象中依次存储以下三个内容：</p>
<ul>
<li>函数的所有形参：创建arguments对象，用来存放形参。</li>
<li>所有函数声明：在VO对象中以函数名建立一个属性，属性值为函数的地址。如果函数名的属性已经存在了，那么该属性将会被新的引用所覆盖</li>
<li>所有变量声明：在变量对象中以变量名建立一个属性，属性值为undefined。如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</li>
</ul>
<p>ES6支持新的变量声明方式let/const，规则与var完全不同，它们是在上下文的执行阶段开始执行的，避免了变量提升带来的一系列问题。</p>
<p>在了解创建变量对象的过程之前，先通过一个例子了解一下变量提升和函数提升：、</p>
<ul>
<li>变量提升和函数提升的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);  //undefined</span><br><span class="line">console.log(first()); //first</span><br><span class="line">console.log(second);  //undefined</span><br><span class="line">  </span><br><span class="line">var a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;</span><br><span class="line">    return &apos;first&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var second = function () &#123;</span><br><span class="line">  return &apos;second&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(second); //[Function: second]</span><br></pre></td></tr></table></figure>

<p>上述代码相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a; // 变量a提升</span><br><span class="line">var second; // 变量b提升，但是函数没提升</span><br><span class="line">function first() &#123;  // 整个函数被提升</span><br><span class="line">    return &apos;first&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);  //undefined</span><br><span class="line">console.log(first()); //first</span><br><span class="line">console.log(second);  //undefined</span><br><span class="line">  </span><br><span class="line">a = &apos;Hello World!&apos;;</span><br><span class="line">second = function () &#123;</span><br><span class="line">  return &apos;second&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(second); //[Function: second]</span><br></pre></td></tr></table></figure>

<p>从上边也可以看出两种声明函数之间存在的差别，一个提升的是变量，另一个提升的是整个函数。</p>
<ul>
<li>注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(a); //输出：function a()&#123; alert(&apos;我是函数&apos;) &#125;</span><br><span class="line">function a() &#123;</span><br><span class="line">    alert(&quot;我是函数&quot;);</span><br><span class="line">&#125; //</span><br><span class="line">var a = &quot;我是变量&quot;;</span><br><span class="line">alert(a); //输出：&apos;我是变量&apos;</span><br></pre></td></tr></table></figure>

<p>因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code>，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">(function foo() &#123;</span><br><span class="line">    foo = 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;())</span><br><span class="line">// [Function: foo]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来这个例子看一看创建上下文过程到底是怎样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">function b () &#123;</span><br><span class="line">    console.log(&apos;全局的b函数&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">function bar(a, b) &#123;</span><br><span class="line">    console.log(&apos;1&apos;, a, b) </span><br><span class="line">    var a = 1</span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;2&apos;, a, b) </span><br><span class="line">&#125;</span><br><span class="line">bar(2, 3)</span><br><span class="line">console.log(&apos;3&apos;, a, b)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1 2 function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">2 1 function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">3 10 function b () &#123;</span><br><span class="line">    console.log(&apos;全局的b函数&apos;)</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 创建阶段：</span><br><span class="line">// 第一步，遇到了全局代码，进入全局上下文，此时的执行上下文栈是这样</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            // vo依次存储，优先处理全局下的b函数声明,值为该函数所在内存地址的引用</span><br><span class="line">            b: &lt;reference to function&gt;,</span><br><span class="line">            // 按顺序再处理bar函数声明，因为是在全局上下文中，并不会分析bar函数的参数</span><br><span class="line">            bar: &lt;refernce to function&gt;,</span><br><span class="line">            // 再处理变量，并赋值为undefined</span><br><span class="line">            a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">// 第二步，发现bar函数被调用，就又创建了一个函数上下文，此时的执行上下文栈是这样</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            //vo依次存储，优先分析函数的形参</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,(a)</span><br><span class="line">                1: 3,(b)</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 2,</span><br><span class="line">            // b: 3,</span><br><span class="line">            // 再分析bar函数中的函数声明b,并且赋值为b函数所在内存地址的引用, 它发现VO中已经有b:3了，就会覆盖掉它。因此上面一行中的b:3实际上不存在了。</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">            // 接着分析bar函数中的变量声明a,并且赋值为undefined, 但是发现VO中已经有a:2了，因此下面一行中的a:undefined也是会不存在的。</span><br><span class="line">            // a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><ul>
<li>变量赋值</li>
<li>函数引用</li>
<li>执行其他代码</li>
<li>上述例子执行阶段为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段：</span><br><span class="line">// 第三步：首先，执行了bar(2, 3)函数，紧接着，在bar函数里执行了console.log(&apos;1&apos;, a, b)。全局上下文中依然还是VO，但是函数上下文中VO就变成了AO。并且代码执行到这，就已经修改了全局上下文中的变量a.</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        AO: &#123;</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,</span><br><span class="line">                1: 3,</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 2,</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 因此会输出结果： &apos;1&apos;, 2, function b() &#123;console.log(&apos;bar下的b函数&apos;)&#125;;</span><br><span class="line"></span><br><span class="line">// 第四步：执行console.log(&apos;2&apos;, a, b)的时候, 发现里面的变量a被重新赋值为1了。</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        AO: &#123;</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,</span><br><span class="line">                1: 3,</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 1,</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">// 因此会输出结果： &apos;2&apos;, 1, function b() &#123;console.log(&apos;bar下的b函数&apos;)&#125;；</span><br><span class="line"></span><br><span class="line">// 第五步，执行到console.log(&apos;3&apos;, a, b)的时候，ECStack发现bar函数已经执行完了，就把bar从ECStack给弹出去了。此时的执行上下文栈是这样的。</span><br><span class="line"></span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 因此会输出结果： &apos;3&apos;, 10, function b() &#123;console.log(&apos;全局的b函数&apos;)&#125;</span><br></pre></td></tr></table></figure>

<p>上边我们会发现执行函数代码的时候，VO会变成AO。</p>
<p>VO是变量对象，AO是活动对象。</p>
<ul>
<li>只有全局上下文中的变量对象允许通过VO属性名称来间接访问，函数上下文中，不能直接访问VO对象。</li>
<li>函数执行上下文中，VO不能直接访问，此时由活动对象AO继续扮演VO的角色。</li>
</ul>
<p>未进入执行阶段前，变量对象中的属性都不能访问！但是进入到执行阶段之后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<p>因此，对于函数上下文来讲，活动对象与变量对象其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于执行上下文栈栈顶的函数执行上下文中的变量对象，才会变成活动对象。全局上下文的变量对象有一个特殊的地方，即它的变量对象就是window对象，而且全局上下文的变量对象不能变成活动对象。</p>
<h5 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h5><ul>
<li>执行完毕出栈，等待被销毁。</li>
</ul>
<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ul>
<li>JS是单线程的语言，单线程就是就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。比如：早上上班的时候你正要打卡，这时候你来电话了，你先接电话后打卡，这就是单线程。边接电话边打卡，这就是多线程，但最终两者的结果是一样的。单线程存在的缺点是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），为解决这个问题JS将任务执行分为两种模式：同步和异步。</li>
<li>同步：同步是指当程序1调用程序2时，程序2返回结果后才继续向下执行程序1的步骤。</li>
<li>异步是指当程序1调用程序2时，不等程序2返回结果就继续向下执行程序1。</li>
</ul>
<h5 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h5><p><img src="https://s2.ax1x.com/2020/03/05/3TfO0I.png" alt="image"></p>
<ul>
<li>同步任务和异步任务会进行到不同的执行“场所”，同步任务进行到主线程，异步进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue</li>
<li>主线程内的任务执行完毕为空时会去Event Queue读取对应的函数，进入主线程执行</li>
<li>上述过程不断重复，也就是常说的事件循环</li>
</ul>
<p>以下代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;执行延时函数&apos;);</span><br><span class="line">&#125;,3000);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行完毕&apos;)</span><br><span class="line"></span><br><span class="line">/* 执行结果：</span><br><span class="line">代码执行完毕</span><br><span class="line">执行延时函数</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>上述代码中，setTimeout是异步任务，进入Event Table，满足延时3秒后，把要执行的任务加入到Event Queue中。又因为是单线程任务要一个个执行，如果前面的任务需要的时间太长，那么只能等着（即使超过）。</p>
<ul>
<li>所以我们可以总结出来，定时器执行的条件是</li>
</ul>
<ol>
<li>延迟时间足够</li>
<li>主线程空闲</li>
</ol>
<ul>
<li>那么接下来观察一段代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    for(var i=0;i&lt;100;i++)&#123;</span><br><span class="line">        i==22&amp;&amp;resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(()=&gt;console.log(&quot;执行then函数&quot;))；</span><br><span class="line"> </span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br></pre></td></tr></table></figure>

<p>按照我们之前来分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout  是异步任务,被放到event table</span><br><span class="line">new Promise 是同步任务,被放到主进程里,直接执行打印 console.log(&apos;准备执行for循环了&apos;)</span><br><span class="line">.then里的函数是 异步任务,被放到event table</span><br><span class="line"> console.log(&apos;代码执行结束&apos;)是同步代码,被放到主进程里,直接执行</span><br><span class="line">所以最后的执行结果是：【准备执行for循环--&gt;代码执行完毕--&gt;定时器开始执行--&gt;执行then函数 】</span><br></pre></td></tr></table></figure>

<p>但是正确的结果是：【准备执行for循环–&gt;代码执行完毕–&gt;执行then函数–&gt;定时器开始执行】</p>
<p>原来上述划分并不准确。正确划分如下：</p>
<h5 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h5><ul>
<li>宏任务：Script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering.</li>
<li>微任务：process.nextTick, Promise(原生)，Object.observe，MutationObserver</li>
<li>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue；Promise，process.nextTick会进入相同的Event Queue。</li>
<li>事件循环的顺序决定代码执行的顺序。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/05/3TIoVA.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 1 7 6 8 2 4 9 11 3 10 5 12</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(() =&gt; console.log(&quot;执行then函数&quot;));</span><br><span class="line"></span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">准备执行for循环了</span><br><span class="line">代码执行完毕</span><br><span class="line">执行then函数</span><br><span class="line">定时器开始执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(() =&gt; console.log(&quot;执行then函数&quot;));</span><br><span class="line"></span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;5&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">准备执行for循环了</span><br><span class="line">代码执行完毕</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">执行then函数</span><br><span class="line">定时器开始执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ul>
<li>上边代码可以看出，4、5、6是比then后进入微任务的，却是先执行的。</li>
</ul>
<p>对比以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    resolve()  // 返回resolve</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br><span class="line"></span><br><span class="line">&lt;!--promise--&gt;</span><br><span class="line">&lt;!--console--&gt;</span><br><span class="line">&lt;!--then--&gt;</span><br><span class="line">&lt;!--setTimeout--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    // resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br><span class="line"></span><br><span class="line">&lt;!--promise--&gt;</span><br><span class="line">&lt;!--console--&gt;</span><br><span class="line">&lt;!--setTimeout--&gt;</span><br></pre></td></tr></table></figure>

<p>由此可见，只有返回resolve之后，then才会被添加到微任务队列中。</p>
<p>process.nextTick 优先级高于 Promise。<br>setTimeout的优先级高于setIImmediate。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/03/深浅拷贝/" rel="next" title="深浅拷贝">
                <i class="fa fa-chevron-left"></i> 深浅拷贝
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/05/解决异步回调地狱/" rel="prev" title="解决异步回调地狱">
                解决异步回调地狱 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jerry">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行上下文"><span class="nav-number">1.</span> <span class="nav-text">执行上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#执行上下文分为三种"><span class="nav-number">1.0.1.</span> <span class="nav-text">执行上下文分为三种</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#执行栈"><span class="nav-number">2.</span> <span class="nav-text">执行栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建执行上下文"><span class="nav-number">3.</span> <span class="nav-text">创建执行上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建阶段"><span class="nav-number">3.0.1.</span> <span class="nav-text">创建阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建变量对象"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">创建变量对象</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行阶段"><span class="nav-number">3.0.2.</span> <span class="nav-text">执行阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回收阶段"><span class="nav-number">3.0.3.</span> <span class="nav-text">回收阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS执行机制"><span class="nav-number">4.</span> <span class="nav-text">JS执行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#事件循环-Event-Loop"><span class="nav-number">4.0.1.</span> <span class="nav-text">事件循环(Event Loop)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#宏任务、微任务"><span class="nav-number">4.0.2.</span> <span class="nav-text">宏任务、微任务</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
