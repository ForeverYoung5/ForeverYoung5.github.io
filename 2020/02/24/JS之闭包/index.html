<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JS,">










<meta name="description" content="作用域 作用域就是变量与函数的可访问范围，控制这变量与函数的可见性和生命周期。  全局作用域：任何地方都能访问到。 在函数外边生命的变量拥有全局作用域。  123456var a = &amp;apos;全局变量&amp;apos;;function fn()&amp;#123;    console.log(a); // 全局变量&amp;#125;;fn();   未声明直接赋值的变量拥有全局作用域。  12345funct">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="JS之闭包">
<meta property="og:url" content="http://yoursite.com/2020/02/24/JS之闭包/index.html">
<meta property="og:site_name" content="Jerry&#39;s Blog">
<meta property="og:description" content="作用域 作用域就是变量与函数的可访问范围，控制这变量与函数的可见性和生命周期。  全局作用域：任何地方都能访问到。 在函数外边生命的变量拥有全局作用域。  123456var a = &amp;apos;全局变量&amp;apos;;function fn()&amp;#123;    console.log(a); // 全局变量&amp;#125;;fn();   未声明直接赋值的变量拥有全局作用域。  12345funct">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/24/3G2xW4.png">
<meta property="og:updated_time" content="2022-05-08T07:31:54.710Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS之闭包">
<meta name="twitter:description" content="作用域 作用域就是变量与函数的可访问范围，控制这变量与函数的可见性和生命周期。  全局作用域：任何地方都能访问到。 在函数外边生命的变量拥有全局作用域。  123456var a = &amp;apos;全局变量&amp;apos;;function fn()&amp;#123;    console.log(a); // 全局变量&amp;#125;;fn();   未声明直接赋值的变量拥有全局作用域。  12345funct">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/02/24/3G2xW4.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/24/JS之闭包/">





  <title>JS之闭包 | Jerry's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jerry's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/JS之闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS之闭包</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T22:10:10+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>作用域就是变量与函数的可访问范围，控制这变量与函数的可见性和生命周期。</li>
</ul>
<h5 id="全局作用域：任何地方都能访问到。"><a href="#全局作用域：任何地方都能访问到。" class="headerlink" title="全局作用域：任何地方都能访问到。"></a>全局作用域：任何地方都能访问到。</h5><ul>
<li>在函数外边生命的变量拥有全局作用域。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;全局变量&apos;;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(a); // 全局变量</span><br><span class="line">&#125;;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<ul>
<li>未声明直接赋值的变量拥有全局作用域。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">    b = &apos;未声明直接赋值的全局变量&apos;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line">console.log(b) //未声明直接赋值的全局变量</span><br></pre></td></tr></table></figure>

<ul>
<li>window 对象的属性拥有全局作用域。</li>
</ul>
<h5 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h5><ul>
<li>代码片段中可以访问到。函数内声明变量，在外部无法访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    var a =&apos;局部变量&apos;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>上述代码中函数fn()执行时创建一个私有作用域每当函数执行完毕的时候私有作用域会销毁。</p>
<h5 id="ES6中块级作用域"><a href="#ES6中块级作用域" class="headerlink" title="ES6中块级作用域"></a>ES6中块级作用域</h5><ul>
<li>块级作用域声明函数必须在代码块中，否则会报错。let和const涉及到块级作用域。</li>
<li>没有块级变量会导致以下问题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 变量提升导致内层变量可能会覆盖外层变量</span><br><span class="line">var i = 5;</span><br><span class="line">function func()&#123;</span><br><span class="line">    console.log(i);  //undefined</span><br><span class="line">    if(true)&#123;</span><br><span class="line">        var i = 6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line">// 2. 用来计数的循环变量泄露为全局变量</span><br><span class="line"> for(var i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">    //  console.log(i)</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(i); //10</span><br></pre></td></tr></table></figure>


<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><ul>
<li>如下所示，局部函数向上一层一层包起来，构成作用域链。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var m=1;</span><br><span class="line">function funct()&#123;</span><br><span class="line"></span><br><span class="line">    var m = 6;</span><br><span class="line">    function funct1()&#123;</span><br><span class="line">        var m =5;</span><br><span class="line">        console.log(&apos;函数内存在变量&apos;,m); //函数内存在变量 5</span><br><span class="line">    &#125;</span><br><span class="line">    function funct2()&#123;</span><br><span class="line">        console.log(&apos;函数内不存在变量，向上找&apos;,m) //函数内不存在变量，向上找 6</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    funct1();</span><br><span class="line">    funct2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funct()</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><ul>
<li>不再用到的内存没有及时释放，就叫做内存泄漏。</li>
<li>我们不会再引用某个对象时，垃圾回收器认为这个对象还在被引用，一次不会释放它，从而造成了内存泄漏。</li>
</ul>
<h5 id="为什么系统需要垃圾回收"><a href="#为什么系统需要垃圾回收" class="headerlink" title="为什么系统需要垃圾回收"></a>为什么系统需要垃圾回收</h5><ul>
<li>由于字符串、数组、对象没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或者对象时，解释器多读必须分配内存来存储那个实体，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</li>
<li>JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。</li>
</ul>
<h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><ul>
<li>js中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。而当变量离开环境时，则将其标记为“离开环境”。</li>
<li>可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生变化。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量标记。当变量离开环境（不再需要引用变量）的时候，再重新给这些变量添加标记,而在此之后重新被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li>
<li>原理是看变量是否在执行环境中被引用，不被引用则删除。</li>
</ul>
<h5 id="引用计数法（不常见）"><a href="#引用计数法（不常见）" class="headerlink" title="引用计数法（不常见）"></a>引用计数法（不常见）</h5><ul>
<li>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取的了另一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</li>
<li>原理是计算每个值引用的次数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=&quot;hello world&quot;;//hello world引用次数为1</span><br><span class="line">var b=&quot;world&quot;;//world引用次数也为1</span><br><span class="line">var a=b;//hello world引用次数为0，之后将删除释放，而world次数为2</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方法存在内存泄漏的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function problem() &#123;</span><br><span class="line">var objA = new Object();</span><br><span class="line">var objB = new Object();</span><br><span class="line">objA.someOtherObject = objB;</span><br><span class="line">objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在标记清除法中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用技数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为他们的引用次数永远不会时0。加入这个函数被多次调用，就会导致大量内存得不到回收。</p>
<h5 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h5><p>因为自动垃圾回收机制的存在，内存的分配与回收完全实现了自动管理。</p>
<p>内存空间的使用过程（JS的内存生命周期）：</p>
<ol>
<li>分配所需要的内存空间</li>
<li>使用分配到的内存空间</li>
<li>不需要时将其释放归还</li>
</ol>
<p>js中存在的问题就是分配给web浏览器的内存通常比分配给桌面应用的少，因此为了使页面性能更好，要保证变量占用的内存尽量少，最好的办法就是将不用的变量引用释放掉，也叫作解除引用。</p>
<p>在局部作用域中，当函数执行完，局部变量也就没有存在的必要，因此垃圾收集器很容易做出判断并回收。但是在全局中，变量什么时候需要自动释放内存空间则很难判断，因此我们在开发时，应尽量避免使用全局变量，如果使用了，在不使用它时，通过赋值null的方式释放引用，以确保能够及时回收内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  // 在堆内存中给数值变量分配空间</span><br><span class="line">alert(a + 100);  // 使用内存</span><br><span class="line">var a = null; // 使用完毕之后，释放内存空间</span><br></pre></td></tr></table></figure>

<p>标记清除法可知，只有与执行环境失去引用的环境变量才会被清除，我们通过设置null，让变量失去引用，等待回收。</p>
<h3 id="浅谈Chrome-V8引擎中的垃圾回收机制"><a href="#浅谈Chrome-V8引擎中的垃圾回收机制" class="headerlink" title="浅谈Chrome V8引擎中的垃圾回收机制"></a>浅谈Chrome V8引擎中的垃圾回收机制</h3><p><a href="https://blog.csdn.net/heyeqingquan/article/details/78839699" target="_blank" rel="noopener">Chrome V8</a> ：<code>JavaScript</code>引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行<code>JavaScript</code>之前，相比其它的<code>JavaScript</code>的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，<code>JavaScript</code>程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。</p>
<h4 id="1-垃圾回收器"><a href="#1-垃圾回收器" class="headerlink" title="1. 垃圾回收器"></a>1. 垃圾回收器</h4><h5 id="JavaScript的垃圾回收器"><a href="#JavaScript的垃圾回收器" class="headerlink" title="JavaScript的垃圾回收器"></a>JavaScript的垃圾回收器</h5><p>JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理。</p>
<h5 id="内存管理问题"><a href="#内存管理问题" class="headerlink" title="内存管理问题"></a>内存管理问题</h5><p>在浏览器中，Chrome V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需 要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。</p>
<h4 id="2-Chrome的内存限制"><a href="#2-Chrome的内存限制" class="headerlink" title="2. Chrome的内存限制"></a>2. Chrome的内存限制</h4><h5 id="存在限制"><a href="#存在限制" class="headerlink" title="存在限制"></a>存在限制</h5><p>Chrome限制了所能使用的内存极限（64位为1.4GB，32位为1.0GB），这也就意味着将无法直接操作一些大内存对象。</p>
<h5 id="为何限制"><a href="#为何限制" class="headerlink" title="为何限制"></a>为何限制</h5><p>Chrome之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因 则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞 JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。 若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响 应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。</p>
<h4 id="3-Chrome-V8的堆构成"><a href="#3-Chrome-V8的堆构成" class="headerlink" title="3.Chrome V8的堆构成"></a>3.Chrome V8的堆构成</h4><p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：</p>
<ul>
<li>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁</li>
<li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li>
<li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针。</li>
<li>大对象区：这里存放体积超越其他区对象大小的对象，每个对象有自己的内存，垃圾回收器不会移动大对象。</li>
<li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li>
<li>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li>
</ul>
<p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对 齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内 存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。</p>
<h4 id="4-Chrome-V8的垃圾回收机制"><a href="#4-Chrome-V8的垃圾回收机制" class="headerlink" title="4.Chrome V8的垃圾回收机制"></a>4.Chrome V8的垃圾回收机制</h4><h5 id="如何判断回收内容"><a href="#如何判断回收内容" class="headerlink" title="如何判断回收内容"></a>如何判断回收内容</h5><p>假定：一个对象为活对象当且仅当它被一个根对象或者另一个活对象指向。根对象永远是活对象，它是被浏览器所引用的对象，被局部变量所引用的对象也属于根对象，因为它们所在的作用于对象被视为根对象。全局对象（Node中为global，浏览器中为window）自然为根对象。浏览器中的DOM元素也属于根对象。</p>
<h5 id="如何识别指针和数据"><a href="#如何识别指针和数据" class="headerlink" title="如何识别指针和数据"></a>如何识别指针和数据</h5><p>垃圾回收器需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写</p>
<p>目前主要有三种方法识别指针：</p>
<ol>
<li>保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会被误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。</li>
<li>编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象是哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言</li>
<li>标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</li>
</ol>
<h5 id="V8的回收策略"><a href="#V8的回收策略" class="headerlink" title="V8的回收策略"></a>V8的回收策略</h5><p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有情况。</p>
<p>V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。</p>
<p>新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p>
<p>分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代的对象满足某些条件时，会被移动到老生代。</p>
<h5 id="V8的分代内存"><a href="#V8的分代内存" class="headerlink" title="V8的分代内存"></a>V8的分代内存</h5><p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="新生代的特点"><a href="#新生代的特点" class="headerlink" title="新生代的特点"></a>新生代的特点</h5><p>大多数的对象被分配到这里，这个区域很小但是垃圾回收特别频繁。在新生代分配内存非常的方便，我们需要保存一个指向内存区的指针，根据新对象的大小不断的进行递增。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p>
<h5 id="新生代垃圾回收算法"><a href="#新生代垃圾回收算法" class="headerlink" title="新生代垃圾回收算法"></a>新生代垃圾回收算法</h5><p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p>
<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个 semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空 间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中 （复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是 通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费 的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广 度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p>
<p><a href="https://www.cnblogs.com/liangdaye/p/4654734.html" target="_blank" rel="noopener">具体的执行过程大致是这样</a>：</p>
<p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将 扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向 老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr 所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针 都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From 区剩下的都可以被视为垃圾，可以进行清理了</p>
<h5 id="对象的晋升"><a href="#对象的晋升" class="headerlink" title="对象的晋升"></a>对象的晋升</h5><p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升，具体移动的标准有两种：</p>
<ol>
<li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li>
<li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li>
</ol>
<h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p>
<h4 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h4><h5 id="老生代的特点"><a href="#老生代的特点" class="headerlink" title="老生代的特点"></a>老生代的特点</h5><p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>
<h5 id="老生代的垃圾回收算法"><a href="#老生代的垃圾回收算法" class="headerlink" title="老生代的垃圾回收算法"></a>老生代的垃圾回收算法</h5><p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将 会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>
<h5 id="Mark-Sweep（标记清除）"><a href="#Mark-Sweep（标记清除）" class="headerlink" title="Mark-Sweep（标记清除）"></a>Mark-Sweep（标记清除）</h5><p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段中，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p>
<p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p>
<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代</li>
</ul>
<h5 id="Mark-Compact（标记整理-标记压缩）"><a href="#Mark-Compact（标记整理-标记压缩）" class="headerlink" title="Mark-Compact（标记整理/标记压缩）"></a>Mark-Compact（标记整理/标记压缩）</h5><p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其清除阶段变为紧缩阶段。在整理的过程中，将活着的 对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p>
<p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空 间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：</p>
<ul>
<li>如果一个对象为白对象，它还没未被垃圾回收器发现</li>
<li>如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li>
<li>如果一个对象为黑对象，说明他不仅被垃圾回收器发现，其邻接对象也全部被处理完毕了</li>
</ul>
<p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背 染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然 后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列 溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象， 将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p>
<p>清除和紧缩阶段都是以内存页为单位回收内存</p>
<p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p>
<p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对 象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁 出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页 非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p>
<h5 id="结合使用标记清除和标记整理"><a href="#结合使用标记清除和标记整理" class="headerlink" title="结合使用标记清除和标记整理"></a>结合使用标记清除和标记整理</h5><p>Chrome V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>
<h3 id="作用域的继承"><a href="#作用域的继承" class="headerlink" title="作用域的继承"></a>作用域的继承</h3><ul>
<li>外边函数里边定义一个函数，子函数能访问父函数的变量，父函数不能访问子函数的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function out_f()&#123;</span><br><span class="line">    var w = &apos;father&apos;;</span><br><span class="line">    // console.log(e);  undefined</span><br><span class="line">    function inner_f()&#123;</span><br><span class="line">        var e = &apos;son&apos;;</span><br><span class="line">        console.log(w) //father</span><br><span class="line">    &#125;;</span><br><span class="line">    inner_f();</span><br><span class="line">&#125;</span><br><span class="line">out_f()</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包是指外部函数return一个内部函数，内部的函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">     var  a = &apos;变量1&apos;</span><br><span class="line">     var  inner = function () &#123;</span><br><span class="line">            console.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    return inner    // inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为什么闭包函数能访问其他函数的作用域。"><a href="#为什么闭包函数能访问其他函数的作用域。" class="headerlink" title="为什么闭包函数能访问其他函数的作用域。"></a>为什么闭包函数能访问其他函数的作用域。</h5><ul>
<li>以以下代码为例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var b = 2;</span><br><span class="line">    function fn1()&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>在js中，函数也是对象。存储在堆内存中。以上代码在内存中存储如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/24/3G2xW4.png" alt="image"></p>
<ul>
<li>栈是一种先进后出的数据结构： </li>
</ul>
<ol>
<li>在执行fn前，此时我们在全局执行环境(浏览器就是window作用域)，全局作用域里有个变量a； </li>
<li>进入fn，此时栈内存就会push一个fn的执行环境，这个环境里有变量b和函数对象fn1，这里可以访问自身执行环境和全局执行环境所定义的变量 </li>
<li>进入fn1，此时栈内存就会push 一个fn1的执行环境，这里面没有定义其他变量，但是我们可以访问到fn和全局执行环境里面的变量，因为程序在访问变量时，是向底层栈一个个找，如果找到全局执行环境里都没有对应变量，则程序抛出underfined的错误。</li>
<li>随着fn1()执行完毕，fn1的执行环境被杯销毁，接着执行完fn()，fn的执行环境也会被销毁，只剩全局的执行环境下，现在没有b变量，和fn1函数对象了，只有a 和 fn(函数声明作用域是window下)。</li>
</ol>
<ul>
<li>在函数内访问某个变量是根据函数作用域链来判断变量是否存在的，而函数作用域链是程序根据函数所在的执行环境栈来初始化的，所以上面的例子，我们在fn1里面打印变量b，根据fn1的作用域链的找到对应fn执行环境下的变量b。所以当程序在调用某个函数时，做了一下的工作：准备执行环境，初始函数作用域链和arguments参数对象。</li>
</ul>
<h5 id="闭包函数的作用"><a href="#闭包函数的作用" class="headerlink" title="闭包函数的作用"></a>闭包函数的作用</h5><ul>
<li>闭包函数是在函数中return另一个函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">     var  a = &apos;变量1&apos;</span><br><span class="line">     var  inner = function () &#123;</span><br><span class="line">            console.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    return inner    // inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = ourter()</span><br></pre></td></tr></table></figure>

<p>outer()返回值inner()被赋给全局变量a,inner()始终存在与内存中，inner依赖于outer，所以outer不会结束调用，不会被回收。既然outer中的这一块作用域不被销毁，那么我们可以用它来保护一些私有变量。即闭包有保护和保存两个作用。</p>
<ul>
<li>保护作用：团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。jQuery 的源码中也是利用了这种保护机制。</li>
<li>保存作用：</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/20/JS之原型，原型链,new/" rel="next" title="JS之原型，原型链,new">
                <i class="fa fa-chevron-left"></i> JS之原型，原型链,new
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/25/JS之闭包的应用/" rel="prev" title="JS之闭包的应用">
                JS之闭包的应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jerry">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">1.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#全局作用域：任何地方都能访问到。"><span class="nav-number">1.0.1.</span> <span class="nav-text">全局作用域：任何地方都能访问到。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#局部作用域（函数作用域）"><span class="nav-number">1.0.2.</span> <span class="nav-text">局部作用域（函数作用域）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES6中块级作用域"><span class="nav-number">1.0.3.</span> <span class="nav-text">ES6中块级作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#作用域链"><span class="nav-number">1.0.4.</span> <span class="nav-text">作用域链</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收机制"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏"><span class="nav-number">2.0.1.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么系统需要垃圾回收"><span class="nav-number">2.0.2.</span> <span class="nav-text">为什么系统需要垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标记清除法"><span class="nav-number">2.0.3.</span> <span class="nav-text">标记清除法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#引用计数法（不常见）"><span class="nav-number">2.0.4.</span> <span class="nav-text">引用计数法（不常见）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#管理内存"><span class="nav-number">2.0.5.</span> <span class="nav-text">管理内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅谈Chrome-V8引擎中的垃圾回收机制"><span class="nav-number">3.</span> <span class="nav-text">浅谈Chrome V8引擎中的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-垃圾回收器"><span class="nav-number">3.1.</span> <span class="nav-text">1. 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JavaScript的垃圾回收器"><span class="nav-number">3.1.1.</span> <span class="nav-text">JavaScript的垃圾回收器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存管理问题"><span class="nav-number">3.1.2.</span> <span class="nav-text">内存管理问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Chrome的内存限制"><span class="nav-number">3.2.</span> <span class="nav-text">2. Chrome的内存限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#存在限制"><span class="nav-number">3.2.1.</span> <span class="nav-text">存在限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为何限制"><span class="nav-number">3.2.2.</span> <span class="nav-text">为何限制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Chrome-V8的堆构成"><span class="nav-number">3.3.</span> <span class="nav-text">3.Chrome V8的堆构成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Chrome-V8的垃圾回收机制"><span class="nav-number">3.4.</span> <span class="nav-text">4.Chrome V8的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何判断回收内容"><span class="nav-number">3.4.1.</span> <span class="nav-text">如何判断回收内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何识别指针和数据"><span class="nav-number">3.4.2.</span> <span class="nav-text">如何识别指针和数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V8的回收策略"><span class="nav-number">3.4.3.</span> <span class="nav-text">V8的回收策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V8的分代内存"><span class="nav-number">3.4.4.</span> <span class="nav-text">V8的分代内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代"><span class="nav-number">3.5.</span> <span class="nav-text">新生代</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#新生代的特点"><span class="nav-number">3.5.1.</span> <span class="nav-text">新生代的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#新生代垃圾回收算法"><span class="nav-number">3.5.2.</span> <span class="nav-text">新生代垃圾回收算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的晋升"><span class="nav-number">3.5.3.</span> <span class="nav-text">对象的晋升</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写屏障"><span class="nav-number">3.5.4.</span> <span class="nav-text">写屏障</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老生代"><span class="nav-number">3.6.</span> <span class="nav-text">老生代</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#老生代的特点"><span class="nav-number">3.6.1.</span> <span class="nav-text">老生代的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#老生代的垃圾回收算法"><span class="nav-number">3.6.2.</span> <span class="nav-text">老生代的垃圾回收算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mark-Sweep（标记清除）"><span class="nav-number">3.6.3.</span> <span class="nav-text">Mark-Sweep（标记清除）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mark-Compact（标记整理-标记压缩）"><span class="nav-number">3.6.4.</span> <span class="nav-text">Mark-Compact（标记整理/标记压缩）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法思路"><span class="nav-number">3.6.5.</span> <span class="nav-text">算法思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结合使用标记清除和标记整理"><span class="nav-number">3.6.6.</span> <span class="nav-text">结合使用标记清除和标记整理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域的继承"><span class="nav-number">4.</span> <span class="nav-text">作用域的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">5.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么闭包函数能访问其他函数的作用域。"><span class="nav-number">5.0.1.</span> <span class="nav-text">为什么闭包函数能访问其他函数的作用域。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#闭包函数的作用"><span class="nav-number">5.0.2.</span> <span class="nav-text">闭包函数的作用</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
