<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Jerry&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Jerry&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jerry&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>Jerry's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jerry's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/JS执行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/05/JS执行机制/" itemprop="url">JS执行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-05T13:36:17+08:00">
                2020-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul>
<li>执行上下文是一个抽象的概念，我理解为执行代码时的环境中。每当JS代码运行的时候，他都是在执行上下文中运行。</li>
</ul>
<h5 id="执行上下文分为三种"><a href="#执行上下文分为三种" class="headerlink" title="执行上下文分为三种"></a>执行上下文分为三种</h5><ul>
<li>全局执行上下文：默认或者说基础的上下文，不在函数中的代码执行时在全局上下文中。一个程序只有一个全局上下文。</li>
<li>函数执行上下文：每当调用一个函数时，会为这个函数创建一个新的上下文。函数执行上下文可以有无穷多个。</li>
<li>Eval函数执行上下文：行在 eval 函数内部的代码也会有它属于自己的执行上下文，JavaScript 开发者并不经常使用 eval。</li>
</ul>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><ul>
<li>执行栈用来存储代码运行时创建的执行上下文。</li>
<li>代码开始执行时会创建全局执行上下文并压入栈底，每当引擎调用一个函数时，会为该函数创建函数执行上下文并且压入栈顶部。</li>
<li>引擎执行那些执行上下文位于栈顶的函数。当函数执行完毕时执行上下文从栈中弹出，控制流达到当前栈下一个执行上下文（顶部）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&apos;b&apos;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&apos;c&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&apos;d&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">console.log(&apos;e&apos;);</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IrvTJ.png" alt="image"></p>
<p>总结：</p>
<ol>
<li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
</ol>
<h3 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h3><ul>
<li>执行上下文创建包含三个阶段：创建阶段、执行阶段、回收阶段。</li>
</ul>
<h5 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h5><ul>
<li>创建阶段在函数被调用，但是还未执行任何代码之前。</li>
<li>主要完成三件事：创建变量对象，创建作用域链，决定this指向。</li>
</ul>
<h6 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h6><p>变量对象中依次存储以下三个内容：</p>
<ul>
<li>函数的所有形参：创建arguments对象，用来存放形参。</li>
<li>所有函数声明：在VO对象中以函数名建立一个属性，属性值为函数的地址。如果函数名的属性已经存在了，那么该属性将会被新的引用所覆盖</li>
<li>所有变量声明：在变量对象中以变量名建立一个属性，属性值为undefined。如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</li>
</ul>
<p>ES6支持新的变量声明方式let/const，规则与var完全不同，它们是在上下文的执行阶段开始执行的，避免了变量提升带来的一系列问题。</p>
<p>在了解创建变量对象的过程之前，先通过一个例子了解一下变量提升和函数提升：、</p>
<ul>
<li>变量提升和函数提升的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);  //undefined</span><br><span class="line">console.log(first()); //first</span><br><span class="line">console.log(second);  //undefined</span><br><span class="line">  </span><br><span class="line">var a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;</span><br><span class="line">    return &apos;first&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var second = function () &#123;</span><br><span class="line">  return &apos;second&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(second); //[Function: second]</span><br></pre></td></tr></table></figure>

<p>上述代码相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var a; // 变量a提升</span><br><span class="line">var second; // 变量b提升，但是函数没提升</span><br><span class="line">function first() &#123;  // 整个函数被提升</span><br><span class="line">    return &apos;first&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);  //undefined</span><br><span class="line">console.log(first()); //first</span><br><span class="line">console.log(second);  //undefined</span><br><span class="line">  </span><br><span class="line">a = &apos;Hello World!&apos;;</span><br><span class="line">second = function () &#123;</span><br><span class="line">  return &apos;second&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(second); //[Function: second]</span><br></pre></td></tr></table></figure>

<p>从上边也可以看出两种声明函数之间存在的差别，一个提升的是变量，另一个提升的是整个函数。</p>
<ul>
<li>注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(a); //输出：function a()&#123; alert(&apos;我是函数&apos;) &#125;</span><br><span class="line">function a() &#123;</span><br><span class="line">    alert(&quot;我是函数&quot;);</span><br><span class="line">&#125; //</span><br><span class="line">var a = &quot;我是变量&quot;;</span><br><span class="line">alert(a); //输出：&apos;我是变量&apos;</span><br></pre></td></tr></table></figure>

<p>因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code>，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">(function foo() &#123;</span><br><span class="line">    foo = 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;())</span><br><span class="line">// [Function: foo]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来这个例子看一看创建上下文过程到底是怎样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">function b () &#123;</span><br><span class="line">    console.log(&apos;全局的b函数&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">function bar(a, b) &#123;</span><br><span class="line">    console.log(&apos;1&apos;, a, b) </span><br><span class="line">    var a = 1</span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;2&apos;, a, b) </span><br><span class="line">&#125;</span><br><span class="line">bar(2, 3)</span><br><span class="line">console.log(&apos;3&apos;, a, b)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1 2 function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">2 1 function b() &#123;</span><br><span class="line">        console.log(&apos;bar下的b函数&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">3 10 function b () &#123;</span><br><span class="line">    console.log(&apos;全局的b函数&apos;)</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>创建过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 创建阶段：</span><br><span class="line">// 第一步，遇到了全局代码，进入全局上下文，此时的执行上下文栈是这样</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            // vo依次存储，优先处理全局下的b函数声明,值为该函数所在内存地址的引用</span><br><span class="line">            b: &lt;reference to function&gt;,</span><br><span class="line">            // 按顺序再处理bar函数声明，因为是在全局上下文中，并不会分析bar函数的参数</span><br><span class="line">            bar: &lt;refernce to function&gt;,</span><br><span class="line">            // 再处理变量，并赋值为undefined</span><br><span class="line">            a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">// 第二步，发现bar函数被调用，就又创建了一个函数上下文，此时的执行上下文栈是这样</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            //vo依次存储，优先分析函数的形参</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,(a)</span><br><span class="line">                1: 3,(b)</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 2,</span><br><span class="line">            // b: 3,</span><br><span class="line">            // 再分析bar函数中的函数声明b,并且赋值为b函数所在内存地址的引用, 它发现VO中已经有b:3了，就会覆盖掉它。因此上面一行中的b:3实际上不存在了。</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">            // 接着分析bar函数中的变量声明a,并且赋值为undefined, 但是发现VO中已经有a:2了，因此下面一行中的a:undefined也是会不存在的。</span><br><span class="line">            // a: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><ul>
<li>变量赋值</li>
<li>函数引用</li>
<li>执行其他代码</li>
<li>上述例子执行阶段为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段：</span><br><span class="line">// 第三步：首先，执行了bar(2, 3)函数，紧接着，在bar函数里执行了console.log(&apos;1&apos;, a, b)。全局上下文中依然还是VO，但是函数上下文中VO就变成了AO。并且代码执行到这，就已经修改了全局上下文中的变量a.</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        AO: &#123;</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,</span><br><span class="line">                1: 3,</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 2,</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 因此会输出结果： &apos;1&apos;, 2, function b() &#123;console.log(&apos;bar下的b函数&apos;)&#125;;</span><br><span class="line"></span><br><span class="line">// 第四步：执行console.log(&apos;2&apos;, a, b)的时候, 发现里面的变量a被重新赋值为1了。</span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;bar&gt;functionContext: &#123;</span><br><span class="line">        AO: &#123;</span><br><span class="line">            arguments: &#123;</span><br><span class="line">                0: 2,</span><br><span class="line">                1: 3,</span><br><span class="line">                length: 2,</span><br><span class="line">                callee: bar</span><br><span class="line">            &#125;,</span><br><span class="line">            a: 1,</span><br><span class="line">            b: &lt;refernce to function b() &#123;&#125;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">// 因此会输出结果： &apos;2&apos;, 1, function b() &#123;console.log(&apos;bar下的b函数&apos;)&#125;；</span><br><span class="line"></span><br><span class="line">// 第五步，执行到console.log(&apos;3&apos;, a, b)的时候，ECStack发现bar函数已经执行完了，就把bar从ECStack给弹出去了。此时的执行上下文栈是这样的。</span><br><span class="line"></span><br><span class="line">ECStack = [</span><br><span class="line">    globalContext: &#123;</span><br><span class="line">        VO: &#123;</span><br><span class="line">            b: &lt;reference to function b() &#123;&#125;&gt;, </span><br><span class="line">            bar: &lt;refernce to function bar() &#123;&#125;&gt;,</span><br><span class="line">            a: 10,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 因此会输出结果： &apos;3&apos;, 10, function b() &#123;console.log(&apos;全局的b函数&apos;)&#125;</span><br></pre></td></tr></table></figure>

<p>上边我们会发现执行函数代码的时候，VO会变成AO。</p>
<p>VO是变量对象，AO是活动对象。</p>
<ul>
<li>只有全局上下文中的变量对象允许通过VO属性名称来间接访问，函数上下文中，不能直接访问VO对象。</li>
<li>函数执行上下文中，VO不能直接访问，此时由活动对象AO继续扮演VO的角色。</li>
</ul>
<p>未进入执行阶段前，变量对象中的属性都不能访问！但是进入到执行阶段之后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<p>因此，对于函数上下文来讲，活动对象与变量对象其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于执行上下文栈栈顶的函数执行上下文中的变量对象，才会变成活动对象。全局上下文的变量对象有一个特殊的地方，即它的变量对象就是window对象，而且全局上下文的变量对象不能变成活动对象。</p>
<h5 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h5><ul>
<li>执行完毕出栈，等待被销毁。</li>
</ul>
<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><ul>
<li>JS是单线程的语言，单线程就是就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。比如：早上上班的时候你正要打卡，这时候你来电话了，你先接电话后打卡，这就是单线程。边接电话边打卡，这就是多线程，但最终两者的结果是一样的。单线程存在的缺点是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），为解决这个问题JS将任务执行分为两种模式：同步和异步。</li>
<li>同步：同步是指当程序1调用程序2时，程序2返回结果后才继续向下执行程序1的步骤。</li>
<li>异步是指当程序1调用程序2时，不等程序2返回结果就继续向下执行程序1。</li>
</ul>
<h5 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h5><p><img src="https://s2.ax1x.com/2020/03/05/3TfO0I.png" alt="image"></p>
<ul>
<li>同步任务和异步任务会进行到不同的执行“场所”，同步任务进行到主线程，异步进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue</li>
<li>主线程内的任务执行完毕为空时会去Event Queue读取对应的函数，进入主线程执行</li>
<li>上述过程不断重复，也就是常说的事件循环</li>
</ul>
<p>以下代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;执行延时函数&apos;);</span><br><span class="line">&#125;,3000);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行完毕&apos;)</span><br><span class="line"></span><br><span class="line">/* 执行结果：</span><br><span class="line">代码执行完毕</span><br><span class="line">执行延时函数</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>上述代码中，setTimeout是异步任务，进入Event Table，满足延时3秒后，把要执行的任务加入到Event Queue中。又因为是单线程任务要一个个执行，如果前面的任务需要的时间太长，那么只能等着（即使超过）。</p>
<ul>
<li>所以我们可以总结出来，定时器执行的条件是</li>
</ul>
<ol>
<li>延迟时间足够</li>
<li>主线程空闲</li>
</ol>
<ul>
<li>那么接下来观察一段代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    for(var i=0;i&lt;100;i++)&#123;</span><br><span class="line">        i==22&amp;&amp;resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(()=&gt;console.log(&quot;执行then函数&quot;))；</span><br><span class="line"> </span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br></pre></td></tr></table></figure>

<p>按照我们之前来分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout  是异步任务,被放到event table</span><br><span class="line">new Promise 是同步任务,被放到主进程里,直接执行打印 console.log(&apos;准备执行for循环了&apos;)</span><br><span class="line">.then里的函数是 异步任务,被放到event table</span><br><span class="line"> console.log(&apos;代码执行结束&apos;)是同步代码,被放到主进程里,直接执行</span><br><span class="line">所以最后的执行结果是：【准备执行for循环--&gt;代码执行完毕--&gt;定时器开始执行--&gt;执行then函数 】</span><br></pre></td></tr></table></figure>

<p>但是正确的结果是：【准备执行for循环–&gt;代码执行完毕–&gt;执行then函数–&gt;定时器开始执行】</p>
<p>原来上述划分并不准确。正确划分如下：</p>
<h5 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h5><ul>
<li>宏任务：Script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering.</li>
<li>微任务：process.nextTick, Promise(原生)，Object.observe，MutationObserver</li>
<li>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue；Promise，process.nextTick会进入相同的Event Queue。</li>
<li>事件循环的顺序决定代码执行的顺序。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/05/3TIoVA.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 1 7 6 8 2 4 9 11 3 10 5 12</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(() =&gt; console.log(&quot;执行then函数&quot;));</span><br><span class="line"></span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">准备执行for循环了</span><br><span class="line">代码执行完毕</span><br><span class="line">执行then函数</span><br><span class="line">定时器开始执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;定时器开始执行&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&quot;准备执行for循环了&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(() =&gt; console.log(&quot;执行then函数&quot;));</span><br><span class="line"></span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;4&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;5&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function () &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;代码执行完毕&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">准备执行for循环了</span><br><span class="line">代码执行完毕</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">执行then函数</span><br><span class="line">定时器开始执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ul>
<li>上边代码可以看出，4、5、6是比then后进入微任务的，却是先执行的。</li>
</ul>
<p>对比以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    resolve()  // 返回resolve</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br><span class="line"></span><br><span class="line">&lt;!--promise--&gt;</span><br><span class="line">&lt;!--console--&gt;</span><br><span class="line">&lt;!--then--&gt;</span><br><span class="line">&lt;!--setTimeout--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;promise&apos;);</span><br><span class="line">    // resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;then&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;console&apos;);</span><br><span class="line"></span><br><span class="line">&lt;!--promise--&gt;</span><br><span class="line">&lt;!--console--&gt;</span><br><span class="line">&lt;!--setTimeout--&gt;</span><br></pre></td></tr></table></figure>

<p>由此可见，只有返回resolve之后，then才会被添加到微任务队列中。</p>
<p>process.nextTick 优先级高于 Promise。<br>setTimeout的优先级高于setIImmediate。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/深浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/深浅拷贝/" itemprop="url">深浅拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-03T17:48:46+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是拷贝"><a href="#什么是拷贝" class="headerlink" title="什么是拷贝"></a>什么是拷贝</h3><ul>
<li>克隆，即拷贝，简单点说就是复制。</li>
<li>拷贝是针对内部属性而言的。对于最外层的对象，永远是创建的新的对象，然后将源对象内部的属性拷贝进来。</li>
</ul>
<h3 id="数据类型比较"><a href="#数据类型比较" class="headerlink" title="数据类型比较"></a>数据类型比较</h3><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul>
<li>基本数据类型保存在栈内存中，按值查找。</li>
<li>比较基本数据类型使，比较的是值。</li>
</ul>
<h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ul>
<li>引用数据类型数据保存在堆内存中，对应引用地址保存在栈内存中。</li>
<li>在比较引用数据类型时比较的是引用地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a=10;</span><br><span class="line">var b=10;</span><br><span class="line">console.log(a==b);//true</span><br><span class="line">var obj1=new Object();</span><br><span class="line">var obj2=new Object();</span><br><span class="line">console.log(obj1==obj2);//false</span><br></pre></td></tr></table></figure>

<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
<li>对拷贝后的数据内容修改会影响原来数据。</li>
<li>只进行一个层面的拷贝。</li>
</ul>
<h5 id="自己实现拷贝"><a href="#自己实现拷贝" class="headerlink" title="自己实现拷贝"></a>自己实现拷贝</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function clone(o) &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    for (i in o) &#123;</span><br><span class="line">    </span><br><span class="line">    &lt;!--hasOwnProperty忽略继承属性length toString等--&gt;</span><br><span class="line">        if(o.hasOwnProperty(i))&#123;</span><br><span class="line">            obj[i] = o[i]</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;;</span><br><span class="line">var source_obj = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2,</span><br><span class="line">    c:&#123;d:4&#125;</span><br><span class="line">&#125;</span><br><span class="line">var clone_obj = clone(source_obj);</span><br><span class="line">clone_obj.c.d = 555;</span><br><span class="line">console.log(source_obj); //&#123; a: 1, b: 2, c: &#123; d: 555 &#125; &#125;</span><br><span class="line">console.log(clone_obj);  //&#123; a: 1, b: 2, c: &#123; d: 555 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-assign-target-source"><a href="#Object-assign-target-source" class="headerlink" title="Object.assign(target,source)"></a>Object.assign(target,source)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123;&#125;;</span><br><span class="line">var source1 = &#123; a:&#123;c:3&#125;&#125;;</span><br><span class="line">var source2 = &#123; b: 2 &#125;;</span><br><span class="line"></span><br><span class="line">// 接收的第一个对象是拷贝目标，剩下的对象是拷贝的源对象（可以是多个）</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">console.log(target);  //&#123; a: &#123; c: 3 &#125;, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">target.a.c = &apos;change&apos;;</span><br><span class="line">console.log(target); //&#123; a: &#123; c: &apos;change&apos; &#125;, b: &apos;change&apos; &#125;</span><br><span class="line"></span><br><span class="line">console.log(source1); //&#123; a: &#123; c: &apos;change&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<ol>
<li>不会拷贝对象继承的属性</li>
<li>不拷贝不可枚举的属性</li>
<li>属性的数据属性/访问器属性</li>
<li>可以拷贝Symbol类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj_1 = &#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        b:1</span><br><span class="line">    &#125;,</span><br><span class="line">    sym:Symbol(1)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  为obj_1添加innumerable属性，描述为&#123;&#125;</span><br><span class="line">Object.defineProperty(obj_1,&apos;innumerable&apos;,&#123;</span><br><span class="line">    value:&apos;不可枚举属性&apos;,</span><br><span class="line">    enumerable:false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj_2 = &#123;&#125;;</span><br><span class="line">Object.assign(obj_2,obj_1); </span><br><span class="line">console.log(obj_2);//&#123; a: &#123; b: 1 &#125;, sym: Symbol(1) &#125;</span><br><span class="line"></span><br><span class="line">obj_2.a.b = 2;</span><br><span class="line">console.log(&apos;obj1&apos;,obj_1);  //obj1 &#123; a: &#123; b: 2 &#125;, sym: Symbol(1) &#125;</span><br><span class="line">console.log(&apos;obj2&apos;,obj_2);   //obj2 &#123; a: &#123; b: 2 &#125;, sym: Symbol(1) &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/03/02/3WEyn0.png" alt="image"></p>
<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    a:&#123;c:3&#125;,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cloneObj = &#123;...obj1&#125;;</span><br><span class="line">console.log(cloneObj); //&#123; a: &#123; c: 3 &#125;, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">cloneObj.a.c = 4;</span><br><span class="line">cloneObj.b = 5;</span><br><span class="line">console.log(cloneObj);  //&#123; a: &#123; c: 4 &#125;, b: 5 &#125;</span><br><span class="line">console.log(obj1); //&#123; a: &#123; c: 4 &#125;, b: 2 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h5><ul>
<li>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, &#123; a: 7 &#125;, 2, 3, 4,]</span><br><span class="line"></span><br><span class="line">console.log(arr.slice()); //[ 1, &#123; a: 7 &#125;, 2, 3, 4 ]</span><br><span class="line">console.log(arr.slice() === arr); // false</span><br><span class="line"></span><br><span class="line">var new_arr = arr.slice(0, 2);</span><br><span class="line">console.log(new_arr); //[ 1, &#123; a: 7 &#125; ]</span><br><span class="line"></span><br><span class="line">new_arr[0] = 5;</span><br><span class="line">new_arr[1].a = 666;</span><br><span class="line">console.log(arr); //[ 1, &#123; a: 666 &#125;, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">console.log(arr.slice()); //[ 1, &#123; a: 666 &#125;, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">console.log(arr.slice() === arr); //false</span><br></pre></td></tr></table></figure>

<h5 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h5><ul>
<li>该方法是利用Array原型链上的concat方法进行实现，concat方法进行数组的合并返回一个新数组，如果我们传入的是一个空数组（即用原数组与空数组合并），那么显而易见返回的数组就是拷贝得到的数组</li>
<li>同样对于对象向属性不能创建两个互不相关的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, &#123;username: &apos;Wayne&apos;&#125;]</span><br><span class="line">let arr2 = arr1.concat()</span><br><span class="line">arr2[0] = 5</span><br><span class="line">arr2[2].username = &apos;Jack&apos;</span><br><span class="line">console.log(arr1) // [1, 2, &#123;username: &apos;Jack&apos;&#125;]</span><br><span class="line">console.log(arr2) // [ 5, 2, &#123; username: &apos;Jack&apos; &#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>从上边各浅拷贝的例子可以看出，拷贝深浅是针对对象而言的。如果属性是原始数据类型，永远是深拷贝（改变新值不影响原值）。</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li>
<li>对拷贝后的数据内容修改不会影响原来数据。</li>
<li>进行无限层级的拷贝。</li>
</ul>
<h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><ul>
<li>先将要拷贝的对象或数组传入JSON.stringify()中，此时得到了一个JSON字符串，我们把一个引用类型的数据变成了基本的字符串类型，假设此时的这个JSON字符串就叫str吧，那么再将str传入JSON.parse()中，此时str被变成了一个普通的js对象（或数组），所以会得到一个新的对象（或数组）。此数组是由字符串str新产生的，与原对象（或）数组自然没有关系，因此能实现深度克隆。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr_s = [1,2,&#123;name:&apos;way&apos;&#125;];</span><br><span class="line">&lt;!--JSON.stringfy将对象转换为字符串--&gt;</span><br><span class="line">&lt;!--JSON.parse将字符串转换为对象--&gt;</span><br><span class="line">var arr_t = JSON.parse(JSON.stringify(arr_s));</span><br><span class="line">console.log(arr_t);  // [ 1, 2, &#123; name: &apos;way&apos; &#125; ]</span><br><span class="line"></span><br><span class="line">arr_t[0] = 5;</span><br><span class="line">arr_t[2].name = &apos;lalala&apos;;</span><br><span class="line">console.log(JSON.stringify(arr_s));  // [ 1, 2, &#123; name: &apos;way&apos; &#125; ]</span><br><span class="line">console.log(JSON.parse(JSON.stringify(arr_s)));  //[ 1, 2, &#123; name: &apos;way&apos; &#125; ]</span><br><span class="line">console.log(arr_s);  // [ 1, 2, &#123; name: &apos;way&apos; &#125; ]</span><br><span class="line">console.log(arr_t);  // [ 5, 2, &#123; name: &apos;lalala&apos; &#125; ]</span><br></pre></td></tr></table></figure>

<p>但是上述方法存在不足：</p>
<ol>
<li>会忽略<code>symbol</code> 和<code>undefined</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能解决对象原型链上的属性和方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: undefined,</span><br><span class="line">    sex: Symbol(&apos;male&apos;),</span><br><span class="line">    jobs: function() &#123;&#125;,</span><br><span class="line">    name: &apos;yck&apos;</span><br><span class="line">&#125;</span><br><span class="line">let b = JSON.parse(JSON.stringify(a))</span><br><span class="line">console.log(b) // &#123;name: &quot;yck&quot;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自己实现深度克隆"><a href="#自己实现深度克隆" class="headerlink" title="自己实现深度克隆"></a>自己实现深度克隆</h5><ul>
<li>判断被拷贝的类型。</li>
<li>根据类型生成空的对象或者数组。</li>
<li>调用for in方法遍历被拷贝对象或者数组，向新的对象或者数组中添加数据，如果是基本数据类型直接添加到新的对象或者数组中，否则深度克隆。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obje) &#123;</span><br><span class="line">    if(typeof obje === &apos;object&apos;)&#123;</span><br><span class="line">        let afterClone = Array.isArray(obje) ? [] : &#123;&#125;;</span><br><span class="line">        for(let item in obje)&#123;</span><br><span class="line">            if(obje.hasOwnProperty(item))&#123;</span><br><span class="line">                afterClone[item] = deepCopy(obje[item]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return afterClone;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return obje;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var theObj = &#123;</span><br><span class="line">    name:&apos;jerry&apos;,</span><br><span class="line">    age:15,</span><br><span class="line">    a:undefined,</span><br><span class="line">    b:&#123;</span><br><span class="line">        c:456</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">var newObj = deepCopy(theObj);</span><br><span class="line"></span><br><span class="line">console.log(newObj);  // &#123; name: &apos;jerry&apos;, age: 15, a: undefined, b: &#123; c: 456 &#125; &#125;</span><br><span class="line">console.log(theObj);  // &#123; name: &apos;jerry&apos;, age: 15, a: undefined, b: &#123; c: 456 &#125; &#125;</span><br><span class="line"></span><br><span class="line">newObj.b.c = &apos;change&apos;;  </span><br><span class="line"></span><br><span class="line">console.log(newObj);  // &#123; name: &apos;jerry&apos;, age: 15, a: undefined, b: &#123; c: &apos;change&apos; &#125; &#125;</span><br><span class="line">console.log(theObj);  // &#123; name: &apos;jerry&apos;, age: 15, a: undefined, b: &#123; c: 456 &#125; &#125;</span><br><span class="line"></span><br><span class="line">var theArr = [1,2,&#123;d:4&#125;];</span><br><span class="line">var newArr = deepCopy(theArr);</span><br><span class="line"></span><br><span class="line">console.log(&apos;ADS&apos;,newArr); // [ 1, 2, &#123; d: 4 &#125; ]</span><br><span class="line"></span><br><span class="line">newArr[2].d =555;</span><br><span class="line">console.log(theArr);  // [ 1, 2, &#123; d: 4 &#125; ]</span><br><span class="line">console.log(newArr);  // [ 1, 2, &#123; d: 555 &#125; ]</span><br><span class="line"></span><br><span class="line">// 死循环测试</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a.a=a;</span><br><span class="line"></span><br><span class="line">var new_a = deepCopy(a);</span><br><span class="line">console.log(new_a);  //RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure>

<h3 id="解决上述手动深拷贝存在的问题"><a href="#解决上述手动深拷贝存在的问题" class="headerlink" title="解决上述手动深拷贝存在的问题"></a>解决上述手动深拷贝存在的问题</h3><h5 id="问题一：对象判断不严谨"><a href="#问题一：对象判断不严谨" class="headerlink" title="问题一：对象判断不严谨"></a>问题一：对象判断不严谨</h5><ul>
<li>抽象一个判断对象的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isObject(obj)&#123;</span><br><span class="line">    return Object.prototype.toString.call(obj) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;asd:&apos;das&apos;&#125;</span><br><span class="line">console.log(isObject(obj1))  //[object Object]</span><br><span class="line"></span><br><span class="line">var arr1 = [1,2,3]</span><br><span class="line">console.log(isObject(arr1))  //[object Array]</span><br><span class="line"></span><br><span class="line">// typeof不能区分object和array</span><br><span class="line">console.log(&apos;arr&apos;,typeof arr1);  //arr object</span><br><span class="line">console.log(&apos;obj&apos;,typeof obj1); // obj object</span><br><span class="line"></span><br><span class="line">// Array.isArray()</span><br><span class="line">console.log(&apos;arry---&apos;,Array.isArray(arr1)); //arry--- true</span><br><span class="line">console.log(&apos;obj---&apos;,Array.isArray(obj1)); //obj--- false</span><br></pre></td></tr></table></figure>

<ul>
<li>typeof不能区分数组和对象，结合typeof和Array.isArray()可以区分。</li>
</ul>
<h5 id="问题二：深层及的数据导致爆栈"><a href="#问题二：深层及的数据导致爆栈" class="headerlink" title="问题二：深层及的数据导致爆栈"></a>问题二：深层及的数据导致爆栈</h5><ul>
<li>当数据层级很深时会出现栈溢出的问题。</li>
<li>JSON.parse(JSON.stringify())内部使用的也是递归。也会产生这种问题。</li>
<li>破解递归爆栈：既然是递归引起的爆栈，那就不用递归，改用循环。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;手动实现深度克隆&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   function cloneLoop(x) &#123;</span><br><span class="line">    const root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 栈</span><br><span class="line">    const loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: undefined,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    console.log(&apos;loopList---&gt;&apos;,loopList,root)</span><br><span class="line"></span><br><span class="line">debugger</span><br><span class="line"></span><br><span class="line">    while(loopList.length) &#123;</span><br><span class="line">        // 深度优先</span><br><span class="line">        const node = loopList.pop();</span><br><span class="line">        console.log(&apos;node&apos;,node,root)</span><br><span class="line"></span><br><span class="line">        const parent = node.parent;</span><br><span class="line">        console.log(&quot;parent&quot;,parent,root)</span><br><span class="line"></span><br><span class="line">        const key = node.key;</span><br><span class="line">        console.log(&quot;key&quot;,key,root)</span><br><span class="line"></span><br><span class="line">        const data = node.data;</span><br><span class="line">        console.log(&quot;data&quot;,data,root);</span><br><span class="line"></span><br><span class="line">        // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span><br><span class="line">        let res = parent;</span><br><span class="line">        if (typeof key !== &apos;undefined&apos;) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;res---&gt;&quot;,res,root)</span><br><span class="line">debugger</span><br><span class="line">        for(let k in data) &#123;</span><br><span class="line">            if (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                if (typeof data[k] === &apos;object&apos;) &#123;</span><br><span class="line">                    // 下一次循环</span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                    console.log(&quot;loopList-push---&gt;&quot;,loopList,root)</span><br><span class="line">debugger</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                    console.log(&apos;else--res---&gt;&apos;,res,root)</span><br><span class="line">debugger</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    a1: 1,</span><br><span class="line">    a2: &#123;</span><br><span class="line">        b1: 1,</span><br><span class="line">        b2: &#123;</span><br><span class="line">            c1: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = cloneLoop(a);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>原理图</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/03/3hbFud.png" alt="image"></p>
<p><img src="https://s2.ax1x.com/2020/03/03/3hOVER.png" alt="image"></p>
<ul>
<li>原理可总结为parent指向root,res指向parent从而向root添加数据位基本数据类型的属性。当数据为对象时，将res给parent从而使parent依旧指向root，然后将res指向parent[key]，即root[key]向子对象继续添加属性。 </li>
</ul>
<h5 id="问题三：循环引用"><a href="#问题三：循环引用" class="headerlink" title="问题三：循环引用"></a>问题三：循环引用</h5><ul>
<li>手动克隆代码中已经指出循环引用导致栈满的问题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">a.a=a;</span><br><span class="line"></span><br><span class="line">var new_a = deepCopy(a);</span><br><span class="line">console.log(new_a);  //RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON.parse(JSON.stringify())的JSON.stringify()内部做了循环引用的检测，不会产生这种问题。</li>
<li>上述代码中都会出现引用丢失问题，比如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var b = 1;</span><br><span class="line">var a = &#123;a1: b, a2: b&#125;;</span><br><span class="line"></span><br><span class="line">a.a1 === a.a2 // true</span><br><span class="line"></span><br><span class="line">var c = clone(a);</span><br><span class="line">c.a1 === c.a2 // false</span><br></pre></td></tr></table></figure>

<ul>
<li>解决办法，与上边几乎一致，不一致部分已标出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;解决深度克隆循环调用问题&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">function cloneForce(x) &#123;</span><br><span class="line">    // =============</span><br><span class="line">    const uniqueList = []; // 用来去重</span><br><span class="line">    // =============</span><br><span class="line"></span><br><span class="line">    let root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 循环数组</span><br><span class="line">    const loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: undefined,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    while(loopList.length) &#123;</span><br><span class="line">        // 深度优先</span><br><span class="line">        const node = loopList.pop();</span><br><span class="line">        const parent = node.parent;</span><br><span class="line">        const key = node.key;</span><br><span class="line">        const data = node.data;</span><br><span class="line"></span><br><span class="line">        // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span><br><span class="line">        let res = parent;</span><br><span class="line">        if (typeof key !== &apos;undefined&apos;) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // =============</span><br><span class="line">        // 数据已经存在</span><br><span class="line">        let uniqueData = find(uniqueList, data);</span><br><span class="line">        if (uniqueData) &#123;</span><br><span class="line">            parent[key] = uniqueData.target;</span><br><span class="line">            break; // 中断本次循环</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 数据不存在</span><br><span class="line">        // 保存源数据，在拷贝数据中对应的引用</span><br><span class="line">        uniqueList.push(&#123;</span><br><span class="line">            source: data,</span><br><span class="line">            target: res,</span><br><span class="line">        &#125;);</span><br><span class="line">        // =============</span><br><span class="line">    </span><br><span class="line">        for(let k in data) &#123;</span><br><span class="line">            if (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                if (typeof data[k] === &apos;object&apos;) &#123;</span><br><span class="line">                    // 下一次循环</span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function find(arr, item) &#123;</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i].source === item) &#123;</span><br><span class="line">            return arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    b:1</span><br><span class="line">&#125;;</span><br><span class="line">a.a = a;</span><br><span class="line"></span><br><span class="line">var b = cloneForce(a)</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>原理是复制之前，先看看有没有重复，如果没重复正常复制，如果重复，直接将该对象整个复制过去，然后中断循环，这样不会死循环。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/JS之类的创建和继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/26/JS之类的创建和继承/" itemprop="url">JS面试之类的创建和继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-26T15:23:29+08:00">
                2020-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><ul>
<li>类(class)是对象的模板，定义了同一组对象（也称实例）共有的属性和方法。JS中没有类的概念，但是可以模拟出来</li>
</ul>
<h5 id="function-this"><a href="#function-this" class="headerlink" title="function + this"></a>function + this</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function User()&#123;</span><br><span class="line">    this.name=&quot;123&quot;;</span><br><span class="line">    this.getName=function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line">//使用类</span><br><span class="line">var user=new User();</span><br><span class="line">console.log(user.getName());</span><br><span class="line">// 123</span><br><span class="line">console.log(user);</span><br><span class="line">// User&#123; name: &apos;123&apos; ,getName:[Function]&#125;</span><br><span class="line">console.log(User())</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<h5 id="this-prototype"><a href="#this-prototype" class="headerlink" title="this + prototype"></a>this + prototype</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function User(name)&#123;</span><br><span class="line">	this.name=name;</span><br><span class="line">	this.age=1;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype=&#123;</span><br><span class="line">		getName: function()&#123;</span><br><span class="line">			return this.name;</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br><span class="line">var  user = new User(&apos;hello&apos;);</span><br><span class="line">console.log(user.getName());//访问方法</span><br><span class="line">// hello</span><br><span class="line">console.log(user.name);//访问属性</span><br><span class="line">// hello</span><br><span class="line">console.log(user.age);//访问属性</span><br><span class="line">// 1</span><br><span class="line">console.log(user);</span><br><span class="line">// &#123; name: &apos;hello&apos;, age: 1 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User=&#123;</span><br><span class="line">    name:&apos;hello&apos;,</span><br><span class="line">    getName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">var user=Object.create(User);</span><br><span class="line">console.log(user.getName());</span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><h5 id="经典继承（由构造函数继承）"><a href="#经典继承（由构造函数继承）" class="headerlink" title="经典继承（由构造函数继承）"></a>经典继承（由构造函数继承）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parent1()&#123;</span><br><span class="line">    this.name=&apos;parent1&apos;</span><br><span class="line">&#125;</span><br><span class="line">parent1.prototype.say=function()&#123;</span><br><span class="line">    console.log(&apos;parent1-say!!!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function child1()&#123;</span><br><span class="line">    parent1.call(this);  //将parent1的this指向child1的this对象,向child1的this里边添加name为parent1，实现继承</span><br><span class="line">    this.type=&apos;child1&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new child1()); // child1 &#123; name: &apos;parent1&apos;, type: &apos;child1&apos; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原型链上的东西没有被继承</li>
<li>子类调用的时候可以向父类传参数</li>
</ul>
<h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function parent2()&#123;</span><br><span class="line">    this.name=&apos;parent2&apos;;</span><br><span class="line">    this.paly=[1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function child2()&#123;</span><br><span class="line">    this.type = &apos;child2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child2.prototype=new parent2();</span><br><span class="line"></span><br><span class="line">console.log(new child2());  // child2 &#123; type: &apos;child2&apos; &#125;</span><br><span class="line">console.log(new child2().name); // parent2</span><br><span class="line"></span><br><span class="line">var str1=new child2();</span><br><span class="line">var str2 = new child2()</span><br><span class="line"></span><br><span class="line">str1.paly.push(4);</span><br><span class="line"></span><br><span class="line">console.log(&apos;str1.paly--&gt;&apos;,str1.paly); // str1.paly--&gt; [ 1, 2, 3, 4 ]</span><br><span class="line">console.log(&apos;str2.play--&gt;&apos;,str2.paly); // str2.play--&gt; [ 1, 2, 3, 4 ]</span><br></pre></td></tr></table></figure>

<ul>
<li>改变一个对象的属性，另一个对象的属性也会改变，prototype指向原型对象，内部的属性是共享属性。</li>
</ul>
<h5 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Father(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.sayName = function()&#123;  //原型对象上的共享方法</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Son(name,age)&#123;</span><br><span class="line">     </span><br><span class="line">	Father.call(this,name);     //继承实例属性，第一次调用 Father()    </span><br><span class="line">	this.age = age; // 子类自己的属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类和父类共享的方法（实现了父类属性和方法的复用）                              </span><br><span class="line">Son.prototype = Father.prototype;   //继承父类方法,第二次调用 Father()</span><br><span class="line"></span><br><span class="line">// 子类实例对象共享的方法</span><br><span class="line">Son.prototype.sayAge = function()&#123;</span><br><span class="line">	console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Son.prototype) //Father &#123; sayName: [Function], sayAge: [Function] &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数继承私有属性，原型继承原型链上的方法。</li>
<li>调用两次构造函数。</li>
</ul>
<h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">	function F()&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createAnother(original)&#123;</span><br><span class="line">	var clone = object(original); // 通过调用object函数创建一个新对象</span><br><span class="line">	clone.sayHi = function()&#123; // 以某种方式来增强这个对象</span><br><span class="line">		console.log(&quot;hi&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return clone; //返回这个对象</span><br><span class="line">&#125;</span><br><span class="line">jerry =&#123;</span><br><span class="line">    name:&apos;jerry&apos;</span><br><span class="line">&#125;</span><br><span class="line">var a = createAnother(jerry)</span><br><span class="line">console.log(a.name)//jerry</span><br><span class="line">console.log(a) //&#123; sayHi: [Function] &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免调用两次构造函数。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/JS之闭包的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/JS之闭包的应用/" itemprop="url">JS之闭包的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T19:25:57+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>闭包是一种特殊的概念</p>
<p>它由两部分组成–执行上下文（代号A）以及在该执行上下文中创建的函数（代号B）</p>
<p>当B执行时，如果访问了A中<strong>变量对象</strong>（包括的内容参考上一章）的值，那么闭包就产生了。</p>
<p>许多书籍、文章中都以函数B的名字代指这里生成的闭包。而在Chrome中，则以执行上下文A的函数名代指闭包。</p>
<p>特点：</p>
<ul>
<li>函数嵌套函数</li>
<li>在函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会以垃圾回收机制回收</li>
</ul>
<h3 id="闭包与垃圾回收机制"><a href="#闭包与垃圾回收机制" class="headerlink" title="闭包与垃圾回收机制"></a>闭包与垃圾回收机制</h3><p>垃圾回收机制，当一个值失去引用之后就会被标记，然后被垃圾回收机制回收并释放空间</p>
<p>当一个函数的执行上下文运行完毕之后，内部的所有内容都会是去引用而被垃圾回收机制回收</p>
<p>闭包的本质就是在函数外部保持了内部变量的引用，因此闭包会阻止垃圾回收机制进行回收</p>
<h3 id="闭包与作用域链"><a href="#闭包与作用域链" class="headerlink" title="闭包与作用域链"></a>闭包与作用域链</h3><p>因为函数调用栈其实是在代码执行时才确定的，而作用域规则在代码编译阶段就已经确定，虽然作用域链是在代码执行时才生成的，但是它的规则并不会在执行时发生改变。</p>
<p>所以，闭包的存在不会导致作用域链的变化。</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ul>
<li>读取函数内部变量。</li>
<li>让局部变量值保存在内存中不被回收。</li>
<li>方便调用上下文的局部变量，利于代码封装。</li>
</ul>
<h3 id="闭包应用之setTimeout"><a href="#闭包应用之setTimeout" class="headerlink" title="闭包应用之setTimeout"></a>闭包应用之setTimeout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;闭包的应用&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;原始内容&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// ********setTimeout()*******</span><br><span class="line"></span><br><span class="line">setTimeout(function(val)&#123;</span><br><span class="line">    alert(val)  //不能传入参数val</span><br><span class="line">&#125;,3000)</span><br><span class="line"></span><br><span class="line">function change(val)&#123;</span><br><span class="line">    document.getElementById(&apos;content&apos;).innerHTML= &apos;我是等待后改变的内容。&apos;</span><br><span class="line">    alert(val)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(&quot;change(3)&quot;,3000)  //可以传入参数</span><br><span class="line"></span><br><span class="line">// 通过闭包实现传参效果</span><br><span class="line">function func(param)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        alert(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">fn = func(&apos;param&apos;);</span><br><span class="line">setTimeout(fn,3000)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>个人认为第二种传参方式比闭包更简单。</p>
<h3 id="闭包应用场景之回调函数"><a href="#闭包应用场景之回调函数" class="headerlink" title="闭包应用场景之回调函数"></a>闭包应用场景之回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;原始内容&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;huidiao&quot; style=&quot;width: 200px;height: 200px;background-color: aqua;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;changeToGreen&quot;&gt;绿色&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;changeToYellow&quot;&gt;黄色&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">// **********回调*********</span><br><span class="line">function changeColor(color)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            document.getElementById(&apos;huidiao&apos;).style.backgroundColor = color;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;changeToYellow&apos;).onclick = changeColor(&quot;yellow&quot;);</span><br><span class="line">document.getElementById(&apos;changeToGreen&apos;).onclick = changeColor(&quot;green&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码点击不同按钮调用同一函数更改背景颜色。代码简洁。</p>
<h3 id="闭包应用场景之封装变量。"><a href="#闭包应用场景之封装变量。" class="headerlink" title="闭包应用场景之封装变量。"></a>闭包应用场景之封装变量。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var counter = (function()&#123;</span><br><span class="line">    var privateCounter = 0;//私有变量</span><br><span class="line">    function change(val)&#123;</span><br><span class="line">       return privateCounter += val;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123; //三个闭包共享一个词法环境</span><br><span class="line">        increment:function()&#123;</span><br><span class="line">           return change(1);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement:function()&#123;</span><br><span class="line">            change(-1);</span><br><span class="line">        &#125;,</span><br><span class="line">        value:function()&#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(counter.value()) //0</span><br><span class="line">console.log(counter.increment());  //1</span><br><span class="line">console.log(counter.increment());  //2</span><br><span class="line">console.log(counter.value()) //2</span><br></pre></td></tr></table></figure>

<p>共享的环境创建在一个匿名函数体内，环境中有一个局部变量一个局部函数，通过匿名函数返回的对象的三个公共函数访问。</p>
<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><ul>
<li>顾名思义是没有名字的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明普通函数</span><br><span class="line">function func()&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 声明匿名函数</span><br><span class="line">function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是像上边那样写由于不符合语法要求会报错，解决办法是加上一个括号即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    console.log(&apos;匿名函数&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>由于要执行匿名函数，所以要在后边加一个括号。</p>
<h3 id="为节点循环绑定click事件"><a href="#为节点循环绑定click事件" class="headerlink" title="为节点循环绑定click事件"></a>为节点循环绑定click事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=&quot;info&quot;&gt;123&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;E-mail: &lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Name: &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Age: &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function showContent(content)&#123;</span><br><span class="line">        document.getElementById(&apos;info&apos;).innerHTML = content;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function setContent()&#123;</span><br><span class="line">        var infoArr = [</span><br><span class="line">            &#123;&apos;id&apos;:&apos;email&apos;,&apos;content&apos;:&apos;your email address&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;name&apos;,&apos;content&apos;:&apos;your name&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;age&apos;,&apos;content&apos;:&apos;your age&apos;&#125;</span><br><span class="line">        ];</span><br><span class="line">        for (var i = 0; i &lt; infoArr.length; i++) &#123;</span><br><span class="line">            var item = infoArr[i];</span><br><span class="line">            document.getElementById(item.id).onfocus = function()&#123;</span><br><span class="line">                showContent(item.content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setContent()</span><br><span class="line">    //循环中创建了三个闭包，他们使用了相同的词法环境item，item.content是变化的变量</span><br><span class="line">    //当onfocus执行时，item.content才确定，此时循环已经结束，三个闭包共享的item已经指向数组最后一项。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决方法1     通过函数工厂，则函数为每一个回调都创建一个新的词法环境</span><br><span class="line">     */</span><br><span class="line">    function showContent(content)&#123;</span><br><span class="line">        document.getElementById(&apos;info&apos;).innerHTML = content;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function callBack(content)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            showContent(content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function setContent()&#123;</span><br><span class="line">        var infoArr = [</span><br><span class="line">            &#123;&apos;id&apos;:&apos;email&apos;,&apos;content&apos;:&apos;your email address&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;name&apos;,&apos;content&apos;:&apos;your name&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;age&apos;,&apos;content&apos;:&apos;your age&apos;&#125;</span><br><span class="line">        ];</span><br><span class="line">        for (var i = 0; i &lt; infoArr.length; i++) &#123;</span><br><span class="line">            var item = infoArr[i];</span><br><span class="line">            document.getElementById(item.id).onfocus = callBack(item.content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setContent()</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决方法2        绑定事件放在立即执行函数中</span><br><span class="line">     */</span><br><span class="line">    function showContent(content)&#123;</span><br><span class="line">        document.getElementById(&apos;info&apos;).innerHTML = content;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function setContent()&#123;</span><br><span class="line">        var infoArr = [</span><br><span class="line">            &#123;&apos;id&apos;:&apos;email&apos;,&apos;content&apos;:&apos;your email address&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;name&apos;,&apos;content&apos;:&apos;your name&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;age&apos;,&apos;content&apos;:&apos;your age&apos;&#125;</span><br><span class="line">        ];</span><br><span class="line">        for (var i = 0; i &lt; infoArr.length; i++) &#123;</span><br><span class="line">            (function()&#123;</span><br><span class="line">                var item = infoArr[i];</span><br><span class="line">                document.getElementById(item.id).onfocus = function()&#123;</span><br><span class="line">                    showContent(item.content)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)()//放立即执行函数，立即绑定，用每次的值绑定到事件上，而不是循环结束的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setContent()</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解决方案3        用ES6声明，避免声明提前，作用域只在当前块内</span><br><span class="line">     */</span><br><span class="line">    function showContent(content)&#123;</span><br><span class="line">        document.getElementById(&apos;info&apos;).innerHTML = content;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function setContent()&#123;</span><br><span class="line">        var infoArr = [</span><br><span class="line">            &#123;&apos;id&apos;:&apos;email&apos;,&apos;content&apos;:&apos;your email address&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;name&apos;,&apos;content&apos;:&apos;your name&apos;&#125;,</span><br><span class="line">            &#123;&apos;id&apos;:&apos;age&apos;,&apos;content&apos;:&apos;your age&apos;&#125;</span><br><span class="line">        ];</span><br><span class="line">        for (var i = 0; i &lt; infoArr.length; i++) &#123;</span><br><span class="line">            let item = infoArr[i];      //限制作用域只在当前块内</span><br><span class="line">            document.getElementById(item.id).onfocus = function()&#123;</span><br><span class="line">                showContent(item.content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setContent()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/JS之闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/JS之闭包/" itemprop="url">JS之闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T22:10:10+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>作用域就是变量与函数的可访问范围，控制这变量与函数的可见性和生命周期。</li>
</ul>
<h5 id="全局作用域：任何地方都能访问到。"><a href="#全局作用域：任何地方都能访问到。" class="headerlink" title="全局作用域：任何地方都能访问到。"></a>全局作用域：任何地方都能访问到。</h5><ul>
<li>在函数外边生命的变量拥有全局作用域。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;全局变量&apos;;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(a); // 全局变量</span><br><span class="line">&#125;;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<ul>
<li>未声明直接赋值的变量拥有全局作用域。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">    b = &apos;未声明直接赋值的全局变量&apos;</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line">console.log(b) //未声明直接赋值的全局变量</span><br></pre></td></tr></table></figure>

<ul>
<li>window 对象的属性拥有全局作用域。</li>
</ul>
<h5 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h5><ul>
<li>代码片段中可以访问到。函数内声明变量，在外部无法访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    var a =&apos;局部变量&apos;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>上述代码中函数fn()执行时创建一个私有作用域每当函数执行完毕的时候私有作用域会销毁。</p>
<h5 id="ES6中块级作用域"><a href="#ES6中块级作用域" class="headerlink" title="ES6中块级作用域"></a>ES6中块级作用域</h5><ul>
<li>块级作用域声明函数必须在代码块中，否则会报错。let和const涉及到块级作用域。</li>
<li>没有块级变量会导致以下问题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1. 变量提升导致内层变量可能会覆盖外层变量</span><br><span class="line">var i = 5;</span><br><span class="line">function func()&#123;</span><br><span class="line">    console.log(i);  //undefined</span><br><span class="line">    if(true)&#123;</span><br><span class="line">        var i = 6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line">// 2. 用来计数的循环变量泄露为全局变量</span><br><span class="line"> for(var i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">    //  console.log(i)</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(i); //10</span><br></pre></td></tr></table></figure>


<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><ul>
<li>如下所示，局部函数向上一层一层包起来，构成作用域链。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var m=1;</span><br><span class="line">function funct()&#123;</span><br><span class="line"></span><br><span class="line">    var m = 6;</span><br><span class="line">    function funct1()&#123;</span><br><span class="line">        var m =5;</span><br><span class="line">        console.log(&apos;函数内存在变量&apos;,m); //函数内存在变量 5</span><br><span class="line">    &#125;</span><br><span class="line">    function funct2()&#123;</span><br><span class="line">        console.log(&apos;函数内不存在变量，向上找&apos;,m) //函数内不存在变量，向上找 6</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    funct1();</span><br><span class="line">    funct2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funct()</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><ul>
<li>不再用到的内存没有及时释放，就叫做内存泄漏。</li>
<li>我们不会再引用某个对象时，垃圾回收器认为这个对象还在被引用，一次不会释放它，从而造成了内存泄漏。</li>
</ul>
<h5 id="为什么系统需要垃圾回收"><a href="#为什么系统需要垃圾回收" class="headerlink" title="为什么系统需要垃圾回收"></a>为什么系统需要垃圾回收</h5><ul>
<li>由于字符串、数组、对象没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或者对象时，解释器多读必须分配内存来存储那个实体，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</li>
<li>JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。</li>
</ul>
<h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><ul>
<li>js中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。而当变量离开环境时，则将其标记为“离开环境”。</li>
<li>可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生变化。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量标记。当变量离开环境（不再需要引用变量）的时候，再重新给这些变量添加标记,而在此之后重新被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</li>
<li>原理是看变量是否在执行环境中被引用，不被引用则删除。</li>
</ul>
<h5 id="引用计数法（不常见）"><a href="#引用计数法（不常见）" class="headerlink" title="引用计数法（不常见）"></a>引用计数法（不常见）</h5><ul>
<li>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取的了另一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</li>
<li>原理是计算每个值引用的次数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=&quot;hello world&quot;;//hello world引用次数为1</span><br><span class="line">var b=&quot;world&quot;;//world引用次数也为1</span><br><span class="line">var a=b;//hello world引用次数为0，之后将删除释放，而world次数为2</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方法存在内存泄漏的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function problem() &#123;</span><br><span class="line">var objA = new Object();</span><br><span class="line">var objB = new Object();</span><br><span class="line">objA.someOtherObject = objB;</span><br><span class="line">objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在标记清除法中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用技数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为他们的引用次数永远不会时0。加入这个函数被多次调用，就会导致大量内存得不到回收。</p>
<h5 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h5><p>因为自动垃圾回收机制的存在，内存的分配与回收完全实现了自动管理。</p>
<p>内存空间的使用过程（JS的内存生命周期）：</p>
<ol>
<li>分配所需要的内存空间</li>
<li>使用分配到的内存空间</li>
<li>不需要时将其释放归还</li>
</ol>
<p>js中存在的问题就是分配给web浏览器的内存通常比分配给桌面应用的少，因此为了使页面性能更好，要保证变量占用的内存尽量少，最好的办法就是将不用的变量引用释放掉，也叫作解除引用。</p>
<p>在局部作用域中，当函数执行完，局部变量也就没有存在的必要，因此垃圾收集器很容易做出判断并回收。但是在全局中，变量什么时候需要自动释放内存空间则很难判断，因此我们在开发时，应尽量避免使用全局变量，如果使用了，在不使用它时，通过赋值null的方式释放引用，以确保能够及时回收内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  // 在堆内存中给数值变量分配空间</span><br><span class="line">alert(a + 100);  // 使用内存</span><br><span class="line">var a = null; // 使用完毕之后，释放内存空间</span><br></pre></td></tr></table></figure>

<p>标记清除法可知，只有与执行环境失去引用的环境变量才会被清除，我们通过设置null，让变量失去引用，等待回收。</p>
<h3 id="浅谈Chrome-V8引擎中的垃圾回收机制"><a href="#浅谈Chrome-V8引擎中的垃圾回收机制" class="headerlink" title="浅谈Chrome V8引擎中的垃圾回收机制"></a>浅谈Chrome V8引擎中的垃圾回收机制</h3><p><a href="https://blog.csdn.net/heyeqingquan/article/details/78839699" target="_blank" rel="noopener">Chrome V8</a> ：<code>JavaScript</code>引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行<code>JavaScript</code>之前，相比其它的<code>JavaScript</code>的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，<code>JavaScript</code>程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。</p>
<h4 id="1-垃圾回收器"><a href="#1-垃圾回收器" class="headerlink" title="1. 垃圾回收器"></a>1. 垃圾回收器</h4><h5 id="JavaScript的垃圾回收器"><a href="#JavaScript的垃圾回收器" class="headerlink" title="JavaScript的垃圾回收器"></a>JavaScript的垃圾回收器</h5><p>JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理。</p>
<h5 id="内存管理问题"><a href="#内存管理问题" class="headerlink" title="内存管理问题"></a>内存管理问题</h5><p>在浏览器中，Chrome V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需 要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。</p>
<h4 id="2-Chrome的内存限制"><a href="#2-Chrome的内存限制" class="headerlink" title="2. Chrome的内存限制"></a>2. Chrome的内存限制</h4><h5 id="存在限制"><a href="#存在限制" class="headerlink" title="存在限制"></a>存在限制</h5><p>Chrome限制了所能使用的内存极限（64位为1.4GB，32位为1.0GB），这也就意味着将无法直接操作一些大内存对象。</p>
<h5 id="为何限制"><a href="#为何限制" class="headerlink" title="为何限制"></a>为何限制</h5><p>Chrome之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因 则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞 JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。 若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响 应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。</p>
<h4 id="3-Chrome-V8的堆构成"><a href="#3-Chrome-V8的堆构成" class="headerlink" title="3.Chrome V8的堆构成"></a>3.Chrome V8的堆构成</h4><p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：</p>
<ul>
<li>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁</li>
<li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li>
<li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针。</li>
<li>大对象区：这里存放体积超越其他区对象大小的对象，每个对象有自己的内存，垃圾回收器不会移动大对象。</li>
<li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li>
<li>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li>
</ul>
<p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对 齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内 存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。</p>
<h4 id="4-Chrome-V8的垃圾回收机制"><a href="#4-Chrome-V8的垃圾回收机制" class="headerlink" title="4.Chrome V8的垃圾回收机制"></a>4.Chrome V8的垃圾回收机制</h4><h5 id="如何判断回收内容"><a href="#如何判断回收内容" class="headerlink" title="如何判断回收内容"></a>如何判断回收内容</h5><p>假定：一个对象为活对象当且仅当它被一个根对象或者另一个活对象指向。根对象永远是活对象，它是被浏览器所引用的对象，被局部变量所引用的对象也属于根对象，因为它们所在的作用于对象被视为根对象。全局对象（Node中为global，浏览器中为window）自然为根对象。浏览器中的DOM元素也属于根对象。</p>
<h5 id="如何识别指针和数据"><a href="#如何识别指针和数据" class="headerlink" title="如何识别指针和数据"></a>如何识别指针和数据</h5><p>垃圾回收器需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写</p>
<p>目前主要有三种方法识别指针：</p>
<ol>
<li>保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会被误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。</li>
<li>编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象是哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言</li>
<li>标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</li>
</ol>
<h5 id="V8的回收策略"><a href="#V8的回收策略" class="headerlink" title="V8的回收策略"></a>V8的回收策略</h5><p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有情况。</p>
<p>V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。</p>
<p>新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p>
<p>分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代的对象满足某些条件时，会被移动到老生代。</p>
<h5 id="V8的分代内存"><a href="#V8的分代内存" class="headerlink" title="V8的分代内存"></a>V8的分代内存</h5><p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="新生代的特点"><a href="#新生代的特点" class="headerlink" title="新生代的特点"></a>新生代的特点</h5><p>大多数的对象被分配到这里，这个区域很小但是垃圾回收特别频繁。在新生代分配内存非常的方便，我们需要保存一个指向内存区的指针，根据新对象的大小不断的进行递增。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p>
<h5 id="新生代垃圾回收算法"><a href="#新生代垃圾回收算法" class="headerlink" title="新生代垃圾回收算法"></a>新生代垃圾回收算法</h5><p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p>
<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个 semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空 间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中 （复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是 通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费 的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广 度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p>
<p><a href="https://www.cnblogs.com/liangdaye/p/4654734.html" target="_blank" rel="noopener">具体的执行过程大致是这样</a>：</p>
<p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将 扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向 老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr 所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针 都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From 区剩下的都可以被视为垃圾，可以进行清理了</p>
<h5 id="对象的晋升"><a href="#对象的晋升" class="headerlink" title="对象的晋升"></a>对象的晋升</h5><p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升，具体移动的标准有两种：</p>
<ol>
<li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li>
<li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li>
</ol>
<h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p>
<h4 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h4><h5 id="老生代的特点"><a href="#老生代的特点" class="headerlink" title="老生代的特点"></a>老生代的特点</h5><p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>
<h5 id="老生代的垃圾回收算法"><a href="#老生代的垃圾回收算法" class="headerlink" title="老生代的垃圾回收算法"></a>老生代的垃圾回收算法</h5><p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将 会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>
<h5 id="Mark-Sweep（标记清除）"><a href="#Mark-Sweep（标记清除）" class="headerlink" title="Mark-Sweep（标记清除）"></a>Mark-Sweep（标记清除）</h5><p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段中，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p>
<p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p>
<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代</li>
</ul>
<h5 id="Mark-Compact（标记整理-标记压缩）"><a href="#Mark-Compact（标记整理-标记压缩）" class="headerlink" title="Mark-Compact（标记整理/标记压缩）"></a>Mark-Compact（标记整理/标记压缩）</h5><p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其清除阶段变为紧缩阶段。在整理的过程中，将活着的 对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p>
<p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空 间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：</p>
<ul>
<li>如果一个对象为白对象，它还没未被垃圾回收器发现</li>
<li>如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li>
<li>如果一个对象为黑对象，说明他不仅被垃圾回收器发现，其邻接对象也全部被处理完毕了</li>
</ul>
<p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背 染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然 后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列 溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象， 将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p>
<p>清除和紧缩阶段都是以内存页为单位回收内存</p>
<p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p>
<p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对 象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁 出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页 非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p>
<h5 id="结合使用标记清除和标记整理"><a href="#结合使用标记清除和标记整理" class="headerlink" title="结合使用标记清除和标记整理"></a>结合使用标记清除和标记整理</h5><p>Chrome V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>
<h3 id="作用域的继承"><a href="#作用域的继承" class="headerlink" title="作用域的继承"></a>作用域的继承</h3><ul>
<li>外边函数里边定义一个函数，子函数能访问父函数的变量，父函数不能访问子函数的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function out_f()&#123;</span><br><span class="line">    var w = &apos;father&apos;;</span><br><span class="line">    // console.log(e);  undefined</span><br><span class="line">    function inner_f()&#123;</span><br><span class="line">        var e = &apos;son&apos;;</span><br><span class="line">        console.log(w) //father</span><br><span class="line">    &#125;;</span><br><span class="line">    inner_f();</span><br><span class="line">&#125;</span><br><span class="line">out_f()</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包是指外部函数return一个内部函数，内部的函数可以访问外部函数的变量，外部函数不能访问内部函数的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">     var  a = &apos;变量1&apos;</span><br><span class="line">     var  inner = function () &#123;</span><br><span class="line">            console.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    return inner    // inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为什么闭包函数能访问其他函数的作用域。"><a href="#为什么闭包函数能访问其他函数的作用域。" class="headerlink" title="为什么闭包函数能访问其他函数的作用域。"></a>为什么闭包函数能访问其他函数的作用域。</h5><ul>
<li>以以下代码为例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var b = 2;</span><br><span class="line">    function fn1()&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>在js中，函数也是对象。存储在堆内存中。以上代码在内存中存储如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/24/3G2xW4.png" alt="image"></p>
<ul>
<li>栈是一种先进后出的数据结构： </li>
</ul>
<ol>
<li>在执行fn前，此时我们在全局执行环境(浏览器就是window作用域)，全局作用域里有个变量a； </li>
<li>进入fn，此时栈内存就会push一个fn的执行环境，这个环境里有变量b和函数对象fn1，这里可以访问自身执行环境和全局执行环境所定义的变量 </li>
<li>进入fn1，此时栈内存就会push 一个fn1的执行环境，这里面没有定义其他变量，但是我们可以访问到fn和全局执行环境里面的变量，因为程序在访问变量时，是向底层栈一个个找，如果找到全局执行环境里都没有对应变量，则程序抛出underfined的错误。</li>
<li>随着fn1()执行完毕，fn1的执行环境被杯销毁，接着执行完fn()，fn的执行环境也会被销毁，只剩全局的执行环境下，现在没有b变量，和fn1函数对象了，只有a 和 fn(函数声明作用域是window下)。</li>
</ol>
<ul>
<li>在函数内访问某个变量是根据函数作用域链来判断变量是否存在的，而函数作用域链是程序根据函数所在的执行环境栈来初始化的，所以上面的例子，我们在fn1里面打印变量b，根据fn1的作用域链的找到对应fn执行环境下的变量b。所以当程序在调用某个函数时，做了一下的工作：准备执行环境，初始函数作用域链和arguments参数对象。</li>
</ul>
<h5 id="闭包函数的作用"><a href="#闭包函数的作用" class="headerlink" title="闭包函数的作用"></a>闭包函数的作用</h5><ul>
<li>闭包函数是在函数中return另一个函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">     var  a = &apos;变量1&apos;</span><br><span class="line">     var  inner = function () &#123;</span><br><span class="line">            console.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    return inner    // inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = ourter()</span><br></pre></td></tr></table></figure>

<p>outer()返回值inner()被赋给全局变量a,inner()始终存在与内存中，inner依赖于outer，所以outer不会结束调用，不会被回收。既然outer中的这一块作用域不被销毁，那么我们可以用它来保护一些私有变量。即闭包有保护和保存两个作用。</p>
<ul>
<li>保护作用：团队开发时，每个开发者把自己的代码放在一个私有的作用域中，防止相互之间的变量命名冲突；把需要提供给别人的方法，通过 return 或 window.xxx 的方式暴露在全局下。jQuery 的源码中也是利用了这种保护机制。</li>
<li>保存作用：</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/JS之原型，原型链,new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/JS之原型，原型链,new/" itemprop="url">JS之原型，原型链,new</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T17:24:58+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><ul>
<li>在JS中，我们可以通过构造函数创建一个对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function person(name)&#123;</span><br><span class="line">    this.school=&apos;HBschool&apos;,  </span><br><span class="line">    this.name = name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = new person(&apos;tom&apos;);</span><br><span class="line">var obj2 = new person(&apos;jerry&apos;);</span><br></pre></td></tr></table></figure>

<p>obj1和obj2是两个对象，改变其中一个school并不能使另一个改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.school = &apos;anotherSchool&apos;;</span><br><span class="line">console.log(obj2.school)    //HBschool</span><br></pre></td></tr></table></figure>

<p>即obj1和obj2两个的相同属性school没有被共享，所以JS设计了原型对象来存储对象共享的属性。</p>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h5><ul>
<li>上边说到了JS设计原型对象来存放对象的共享属性，那么怎么使新创建的对象有共享属性呢？<br>JS的构造函数中有一个prototype属性，指向原型对象。即将所有的共享属性放在构造函数的prototype属性指向的原型对象中，私有属性放在构造函数中。如下图所示：</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZjrHf.png" alt="image"></p>
<h5 id="proto-（原型）"><a href="#proto-（原型）" class="headerlink" title="_ proto_（原型）"></a>_ proto_（原型）</h5><ul>
<li>每创建一个新的对象，都会有一个_proto_属性，这个属性是自动生成的，这个_proto_属性指向的就是原型对象。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3Zxj76.png" alt="image"></p>
<p>详细展开如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3eSjJO.png" alt="image"></p>
<p>新创建的对象person内置属性_ proto_ 指向其构造函数的原型对象，原型对象也是一个对象，也有_proto_属性，指向其构造函数的原型对象。我们看到原型对象中除了_proto_属性外还有constructor属性，从图中我们也可以看出constructor属性指向了构造函数person()。</p>
<ul>
<li>综上所述，我们可以总结出：</li>
</ul>
<ol>
<li>原型对象存放共有属性。</li>
<li>构造函数的prototype属性指向原型对象。</li>
<li>原型对象的constructor属性指回构造函数。</li>
<li>每个新生成的对象都有一个内置属性_proto_指向原型对象。</li>
</ol>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><ul>
<li>图中person()创建对象实例_proto_属性指向其构造函数的原型对象，原型对象还有原型对象，以此类推构成原型链。所有的原型对象都是Object的实例，所以最后指向Object构造函数的原型对象，Object构造函数的_proto_指向null。</li>
</ul>
<h5 id="prototype和-proto"><a href="#prototype和-proto" class="headerlink" title="prototype和_ proto_"></a>prototype和_ proto_</h5><ul>
<li>prototype是构造函数所独有，指向原型对象。</li>
<li>_proto_是对象所独有的，指向prototype。</li>
<li>prototype是内部属性，不能访问，所以通过_ proto _访问。</li>
</ul>
<h5 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function person(name)&#123;</span><br><span class="line">    this.school=&apos;HBschool&apos;,  </span><br><span class="line">    this.name = name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.prototype.all=&#123;</span><br><span class="line">    one:&apos;lll&apos;,</span><br><span class="line">    two:&apos;222&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = new person(&apos;tom&apos;);</span><br><span class="line">console.log(&apos;obj1---&gt;&apos;,obj1)</span><br><span class="line"></span><br><span class="line">var obj2 = new person(&apos;jerry&apos;);</span><br><span class="line">console.log(&apos;obj2---&gt;&apos;,obj2)</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3eERoj.png" alt="image"></p>
<p>改变共享属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1.all.one = &apos;change&apos;;</span><br><span class="line">console.log(&quot;change-obj1---&gt;&quot;,obj1)</span><br><span class="line">console.log(&quot;change-obj2---&gt;&quot;,obj2)</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3eZ9Cn.png" alt="image"></p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><h5 id="new的过程发生了什么"><a href="#new的过程发生了什么" class="headerlink" title="new的过程发生了什么"></a>new的过程发生了什么</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function person (name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = new person();</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个空的新对象。</li>
<li>连接到原型。</li>
<li>将this指向现对象（构造函数作用域给新对象）。</li>
<li>为新对象添加属性。</li>
<li>返回新对象。</li>
</ul>
<h5 id="手动实现new"><a href="#手动实现new" class="headerlink" title="手动实现new"></a>手动实现new</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function person (name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.prototype.print = function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function creatPerson(fn,name)&#123;</span><br><span class="line">    // 创建空对象</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    // 将新对象原型指向构造函数的原型对象</span><br><span class="line">    obj._proto_ = fn.prototype;</span><br><span class="line">    // this绑定</span><br><span class="line">    fn.call(obj,name);</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var creatOne = creatPerson(person,&apos;jerry&apos;);</span><br><span class="line">console.log(&apos;手动实现---&gt;&apos;,creatOne)</span><br><span class="line"></span><br><span class="line">var obj =  new person();</span><br><span class="line">console.log(&apos;new---&gt;&apos;,obj)</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3eJ0tP.png" alt="image"></p>
<h3 id="Object的创建方法及之间差别"><a href="#Object的创建方法及之间差别" class="headerlink" title="Object的创建方法及之间差别"></a>Object的创建方法及之间差别</h3><ul>
<li>new构造函数</li>
<li>字面量</li>
<li>Object.create()</li>
</ul>
<h5 id="字面量创建的优势"><a href="#字面量创建的优势" class="headerlink" title="字面量创建的优势"></a>字面量创建的优势</h5><ul>
<li>代码量少，易读。</li>
<li>对象字面量运行速度更快，它们可以在解析的时候被优化。他不会像 new 一个对象一样，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为 Object() 的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局 Object() 构造函数为止。</li>
</ul>
<h5 id="new-字面量-与-Object-create-null-创建对象的区别？"><a href="#new-字面量-与-Object-create-null-创建对象的区别？" class="headerlink" title="new/字面量 与 Object.create(null) 创建对象的区别？"></a>new/字面量 与 Object.create(null) 创建对象的区别？</h5><ul>
<li>new/字面量创建的对象原型指向Object.prototype,会继承Object的属性和方法。</li>
<li>而通过 Object.create(null) 创建的对象，其原型指向 null，null 作为原型链的顶端，没有也不会继承任何属性和方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/19/数据类型和this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/19/数据类型和this/" itemprop="url">数据类型和this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T16:03:10+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>js数据类型分为原始数据类型和引用数据类型。<blockquote>
<p> 原始数据类型包括String,Number,Boolean,null,undefined,symbol</p>
</blockquote>
</li>
</ul>
<blockquote>
<p> 引用数据类型为Object,具体包括Object，Array,Date,Function,RegExp</p>
</blockquote>
<h3 id="数据类型的存储形式"><a href="#数据类型的存储形式" class="headerlink" title="数据类型的存储形式"></a>数据类型的存储形式</h3><ul>
<li>原始数据保存在栈内存中，可以按值查找。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=10;</span><br><span class="line">var b=a;</span><br><span class="line">var b=20;</span><br></pre></td></tr></table></figure>

<p>栈内存中过程如图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3EkIZn.png" alt="image"></p>
<ul>
<li>引用数据保存在堆内存中，每个对象在堆内存中有一个引用地址，相应的内存地址保存到栈内存中，按照引用地址查找。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/19/3EkvL9.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">var boj2 = obj1;</span><br></pre></td></tr></table></figure>

<p>过程如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3EAPJK.png" alt="image"></p>
<p>所以当执行以下代码时，会产生结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj2.name = &apos;Jerry&apos;;</span><br><span class="line">console.log(obj1.name);</span><br><span class="line">//结果为Jerry</span><br></pre></td></tr></table></figure>

<h3 id="typeof-null为什么返回object"><a href="#typeof-null为什么返回object" class="headerlink" title="typeof null为什么返回object"></a>typeof null为什么返回object</h3><ul>
<li>因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code>。</li>
<li>000：对象</li>
<li>1:整型</li>
<li>010：双精度</li>
<li>100：字符串</li>
<li>110：布尔</li>
</ul>
<h3 id="数据类型的判断"><a href="#数据类型的判断" class="headerlink" title="数据类型的判断"></a>数据类型的判断</h3><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><ul>
<li>一元运算符（只能带一个参数），除了null和object不能准确判断，别的（string，number，undefined，Boolean，symbol）都能准确判断。</li>
<li>typeof(NaN)—&gt; number</li>
</ul>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof()"></a>instanceof()</h5><ul>
<li>a instanceof b：检测a的原型链上是否有b.prototype,返回true或者false。</li>
<li>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">console.log(a instanceof Array) // true</span><br></pre></td></tr></table></figure>

<h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><ul>
<li><p>返回变量的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;.constructor.toString().indexOf(&apos;Object&apos;) &gt; -1</span><br></pre></td></tr></table></figure>
</li>
<li><p>arr.indexOf(a):返回a在arr中的位置，arr中有两个a的时候，返回第一个a的位置。不存在时，返回-1。</p>
</li>
</ul>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul>
<li>ECMAScript内部定义了一些‘抽象操作’，定义了各种值类型的转换规则，包括<code>ToNumber</code>、<code>ToString</code>、<code>ToBoolean</code>和<code>ToPrimitive</code>。前三者针对一种基本类型转换为另一种基本类型，<code>ToPrimitive</code>针对的是对象类型转换为基本类型。</li>
</ul>
<h5 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h5><ul>
<li>当一次运算的期望值是字符串的时候就会发生<code>ToString</code>转换，例如<code>alert(value)</code>显示<code>value</code>时最终会转换为字符串显示。当然我们可以调用<code>String(value)</code>函数显示将<code>value</code>转换为字符串。</li>
<li><code>ToSting</code>的转换比较直观：</li>
</ul>
<table>
<thead>
<tr>
<th>转换前</th>
<th>转换后</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>“null”</td>
</tr>
<tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>true和false</td>
<td>“true”和”false”</td>
</tr>
<tr>
<td>Symbol()和Symbol(‘foo’)</td>
<td>“Symbol()”和 “Symbol(foo)”</td>
</tr>
<tr>
<td>数字</td>
<td>转换为对应的字符串形式</td>
</tr>
</tbody></table>
<h5 id="转换为数字类型"><a href="#转换为数字类型" class="headerlink" title="转换为数字类型"></a>转换为数字类型</h5><ul>
<li>数字转换会发生在数学函数和表达式中。</li>
<li>转换规则：</li>
</ul>
<table>
<thead>
<tr>
<th>转换前</th>
<th>转换后</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>true和false</td>
<td>1和0</td>
</tr>
<tr>
<td>Symbol值</td>
<td>NaN</td>
</tr>
<tr>
<td>字符串</td>
<td>首先去除两边空格。剩下的是空字符串：结果为<code>0</code>；是可以转换为有效数字的值：转换为对应数字；否则是<code>NaN</code></td>
</tr>
</tbody></table>
<h5 id="转换为布尔"><a href="#转换为布尔" class="headerlink" title="转换为布尔"></a>转换为布尔</h5><ul>
<li>发生在逻辑运算中。</li>
<li>除了‘’,null,undefined,NaN,false,0转换为false之外，其他的都转换为true。</li>
<li>‘0’和仅包含空格的字符串(“ “)会转换成<code>true</code>。</li>
</ul>
<h5 id="对象数据类型转换为原始数据类型"><a href="#对象数据类型转换为原始数据类型" class="headerlink" title="对象数据类型转换为原始数据类型"></a>对象数据类型转换为原始数据类型</h5><ul>
<li>当对象处于期望值是基本类型的场景下，就会发生对象转换为基本类型值。会用到<code>ToPrimitive</code>算法。</li>
<li>对象数据类型会转换为数字类型或者字符串类型，转换为布尔类型都是true。</li>
<li>ToPrimitive</li>
</ul>
<p>这个算法允许我们自定义对象转换规则，但是要依赖环境，用所谓的<code>hint</code>表示，它有三个可能取值。</p>
<p><code>string</code></p>
<p>当操作期望值是字符串的时候。这样的操作包括输出对象或者将对象作为属性使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;,</span><br><span class="line">    anotherObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 输出操作</span><br><span class="line">alert(obj); //[object Object]</span><br><span class="line"></span><br><span class="line">// 将对象作为属性名使用</span><br><span class="line">anotherObj[obj] = 123; //相当于anotherObj[&apos;[object Object]&apos;] = 123;</span><br></pre></td></tr></table></figure>

<p><code>number</code></p>
<p>当操作期望值是数字，比如数学运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 显式转换</span><br><span class="line">let num = Number(obj);</span><br><span class="line"></span><br><span class="line">// 数学运算（除了二元加号）</span><br><span class="line">let n = +obj; // 一元加号</span><br><span class="line">let delta = date1 - date2;</span><br><span class="line"></span><br><span class="line">// 大于/小于比较</span><br><span class="line">let greater = user1 &gt; user2;</span><br></pre></td></tr></table></figure>

<p><code>default</code></p>
<p>适用于运算结果不确定的操作中。比如二元加号既可以将两字符串连接也可以将两数字相加。还有当一个对象使用<code>==</code>与字符串、数字、布尔值或者Symbol值比较时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 二元加号</span><br><span class="line">let total = car1 + car2;</span><br><span class="line"></span><br><span class="line">// obj == string/number/boolean/symbol</span><br><span class="line">if (user == 1) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，所有内置对象（除了Date）对于  <code>default</code>和<code>number</code>的处理遵循同一套转换规则。</p>
<p>具体转换过程：</p>
<ol>
<li>如果<code>obj[Symbol.toPrimitive](hint)</code>方法存在，就调用。</li>
<li>否则，如果hint是<code>string</code>:不论是否存在，尝试调用<code>obj.toString()</code>和<code>obj.valueOf()</code>。</li>
<li>否则，如果hint是<code>number</code>或者<code>default</code>：不论是否存在，尝试调用<code>obj.valueOf()</code>和<code>obj.toString()</code>。</li>
</ol>
<ul>
<li>valueOf()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1];</span><br><span class="line">console.log(a.valueOf().toString())  //1</span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol.toPrimitive</li>
</ul>
<p>js有一个预先定义的Symbol值<code>Symbol.toPrimitive</code>，定义对象发生转换时调用的方法名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj[Symbol.toPrimitive] = function (hint) &#123;</span><br><span class="line">    // 返回一个基本类型值，否则报错。</span><br><span class="line">    // hint 的值取 &quot;string&quot;、&quot;number&quot; 和 `default` 之一</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面定义一个<code>user</code>实现这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    money: 1000,</span><br><span class="line"></span><br><span class="line">    [Symbol.toPrimitive](hint) &#123;</span><br><span class="line">        alert(`hint: $&#123;hint&#125;`);</span><br><span class="line">        return hint == &apos;string&apos; ? `&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;` : this.money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); // hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="line">alert(+user); // hint: number -&gt; 1000</span><br><span class="line">alert(user + 500); // hint: default -&gt; 1500</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>user</code>对象发生转换时，<code>user[Symbol.toPrimitive]</code>处理了三种情况。</p>
<ul>
<li>toString/valueOf</li>
</ul>
<p>在ES6引入Symbol之前，对象转换依赖的是<code>toString</code>和<code>valueOf</code>方法，他们会按照这样的顺序调用</p>
<ol>
<li>hint是<code>string</code>的情况：<code>toString -&gt; valueOf</code></li>
<li>hint是<code>number</code>和<code>default</code>的情况：<code>valueOf -&gt; toString</code></li>
</ol>
<p>要注意的是：如果先调用方法返回了一个基本类型，就不在调用后边的方法。例如，对于hint等于<code>string</code>的情况，如果先调用了<code>toString</code>方法反回了一个基本类型值，那么不再调用<code>valueOf</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    money: 1000,</span><br><span class="line"></span><br><span class="line">  // 针对 hint 等于 &quot;string&quot; 的情况</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return `&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;`;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 针对 hint 等于 &quot;number&quot; 或 &quot;default&quot; 的情况</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return this.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); //（调用toString）&#123;name: &quot;John&quot;&#125;  </span><br><span class="line">alert(+user); // （调用valueOf）1000</span><br><span class="line">alert(user + 500); // （调用valueOf）1500</span><br></pre></td></tr></table></figure>

<p>若是不提供<code>valueOf</code>方法，那么<code>toString</code>就成为了对象转换的唯一途径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line"></span><br><span class="line">  // 针对 hint 等于 &quot;string&quot; 的情况</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); //（调用toString）John </span><br><span class="line">alert(+user); // （调用toString）NaN</span><br><span class="line">alert(user + 500); // （调用toString）John500</span><br></pre></td></tr></table></figure>

<p><code>toString</code> 和 <code>valueOf</code> 方法应该返回一个基本类型值，但由于历史原因，如果返回了一个对象，也不会报错，而是会忽略这个方法（就像这个方法不存在一样）。</p>
<p>与此相反，<code>Symbol.toPrimitive</code> 必须 返回一个基本类型值，否则会报错。</p>
<h5 id="四则运算：隐式转换"><a href="#四则运算：隐式转换" class="headerlink" title="四则运算：隐式转换"></a>四则运算：隐式转换</h5><ul>
<li>加法</li>
</ul>
<blockquote>
<p>有一方是字符串，则加法起到“连接”作用。</p>
</blockquote>
<blockquote>
<p>Boolean + Number,Boolean + Boolean 转换为数字相加</p>
</blockquote>
<blockquote>
<p>Object + Number object调用valueof如果不是String, Boolean或者Number类型就继续调用toString()。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;a&apos; + + &apos;b&apos;) //aNaN  因为+&apos;b&apos; 为NaN。</span><br><span class="line">alert([1,2] + [2,1]) //1,22,1</span><br><span class="line">alert(&apos;1,2&apos; + &apos;2,1&apos;)  //1,22,1</span><br></pre></td></tr></table></figure>

<ul>
<li>其余运算转换成Number进行运算。</li>
</ul>
<h3 id="和-、以及Object-is的区别"><a href="#和-、以及Object-is的区别" class="headerlink" title="== 和 ===、以及Object.is的区别"></a>== 和 ===、以及Object.is的区别</h3><h5 id="严格等于"><a href="#严格等于" class="headerlink" title="=== 严格等于"></a>=== 严格等于</h5><ul>
<li>首先判断类型是否相同，类型不同则不相同。</li>
<li>有一个值是NaN则不相等，==NaN === NaN  为false，+0 === -0 为true==。</li>
<li>剩下的按位取均相同则相等。</li>
</ul>
<h5 id="object-is加强版严格等于"><a href="#object-is加强版严格等于" class="headerlink" title="object.is加强版严格等于"></a>object.is加强版严格等于</h5><ul>
<li>和严格等于基本一致，只存在两方面的差别：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.is(+0,-0)   //false</span><br><span class="line">Object.is(NaN,NaN)   //true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="非严格等于"><a href="#非严格等于" class="headerlink" title="==非严格等于"></a>==非严格等于</h5><ul>
<li>先判断类型是否相同，相同的话返回x==y的结果。</li>
<li>类型不同，先转换为相同类型再比较。</li>
<li>string转换为number，Boolean转换为number，object先转换为原始类型再比较。</li>
<li>均为string长度和内容完全相同猜想等。</li>
<li>null==undefined  结果为true。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] // -&gt; true</span><br><span class="line"></span><br><span class="line">// [] 转成 true，然后取反变成 false</span><br><span class="line">[] == false</span><br><span class="line"></span><br><span class="line">[] == ToNumber(false)</span><br><span class="line">[] == 0</span><br><span class="line"></span><br><span class="line">ToPrimitive([]) == 0</span><br><span class="line">// [].toString() -&gt; &apos;&apos;</span><br><span class="line">&apos;&apos; == 0</span><br><span class="line"></span><br><span class="line">0 == 0 // -&gt; true</span><br></pre></td></tr></table></figure>

<h3 id="什么是this指针，以及this指向问题。"><a href="#什么是this指针，以及this指向问题。" class="headerlink" title="什么是this指针，以及this指向问题。"></a>什么是this指针，以及this指向问题。</h3><h5 id="this就是一个对象。不同情况志指向不同。"><a href="#this就是一个对象。不同情况志指向不同。" class="headerlink" title="this就是一个对象。不同情况志指向不同。"></a>this就是一个对象。不同情况志指向不同。</h5><ul>
<li><p>默认绑定：直接在函数中调用，默认指向全局window对象，严格模式下为undefined：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function print_fun()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">print_fun()</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式绑定：对象中调用，指向该对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name:&apos;jerry&apos;,</span><br><span class="line">    age:23,</span><br><span class="line">    print:function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print() //&#123; name: &apos;jerry&apos;, age: 23, print: [Function: print] &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>隐式绑定存在着隐式丢失的问题（作为变量传递或者变量赋值产生丢失）</p>
<blockquote>
<p>作为变量传递</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;全局&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;对象&apos;,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fn1(param) &#123;</span><br><span class="line">    param();</span><br><span class="line">&#125;;</span><br><span class="line">fn1(obj.fn);//全局</span><br><span class="line">//obj.fn作为变量传递给fn1()，this并没有跟函数绑定在一起</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量赋值产生丢失</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;全局&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;对象&apos;,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let fn1 = obj.fn;</span><br><span class="line">fn1(); //全局</span><br></pre></td></tr></table></figure>

<p>但是并不是所有的隐式丢失都指向全局对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;全局&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;obj&apos;,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    name: &apos;obj1&apos;</span><br><span class="line">&#125;</span><br><span class="line">obj1.fn = obj.fn;</span><br><span class="line">obj1.fn(); //obj1</span><br></pre></td></tr></table></figure>

<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。</p>
<ul>
<li><p>显示绑定：通过call、apply、bind改变this的指向。</p>
</li>
<li><p>new绑定：通过new的方式，永远指向新创建的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;</span><br><span class="line">    this.name = &apos;jerry&apos;;</span><br><span class="line">    this.age = 23;</span><br><span class="line">    console.log(this);//person &#123; name: &apos;jerry&apos;, age: 23 &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new person();  //指向obj</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数中的 this：箭头函数中没有this，this的作用域取决于外层作用域中的this：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    name: &apos;obj1&apos;</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = &#123;</span><br><span class="line">    name: &apos;obj2&apos;</span><br><span class="line">&#125;;</span><br><span class="line">let bar = fn.call(obj1); // fn this指向obj1</span><br><span class="line">bar.call(obj2); //obj1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思。</p>
<p>当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    name: &apos;obj1&apos;</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = &#123;</span><br><span class="line">    name: &apos;obj2&apos;</span><br><span class="line">&#125;;</span><br><span class="line">fn.call(obj1)(); // fn this指向obj1,箭头函数this也指向obj1</span><br><span class="line">fn.call(obj2)(); //fn this 指向obj2,箭头函数this也指向obj2</span><br></pre></td></tr></table></figure>

<h3 id="改变this的指向。"><a href="#改变this的指向。" class="headerlink" title="改变this的指向。"></a>改变this的指向。</h3><ul>
<li><p>call、apply、bind都可以改变this的指向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// ***********call*************</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name : &apos;jerry&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name:&apos;tom&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function print(age,gender)&#123;</span><br><span class="line">    console.log(&apos;the name is &apos; + this.name + &apos; ,the age is &apos; + age + &apos; ,the gender is &apos; + gender);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 传参</span><br><span class="line">print.call(obj2,25,&apos;man&apos;);      //the name is tom ,the age is 25 ,the gender is man</span><br><span class="line">print.call(obj2,[25],[&apos;man&apos;]);  //the name is tom ,the age is 25 ,the gender is man</span><br><span class="line">print.call(obj2,[25,&apos;man&apos;]);    //the name is tom ,the age is 25,man ,the gender is undefined</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// *******apply**************</span><br><span class="line">// print.apply(obj2,25,&apos;man&apos;);报错</span><br><span class="line">print.apply(obj2,[25],[&apos;man&apos;]);//the name is tom ,the age is 25 ,the gender is undefined</span><br><span class="line">print.apply(obj2,[25,&apos;man&apos;]);  //the name is tom ,the age is 25 ,the gender is man</span><br><span class="line"></span><br><span class="line">// **********bind***********</span><br><span class="line">let bind_fn = print.bind(obj2,25,&apos;man&apos;);  //不打印</span><br><span class="line">bind_fn();  //the name is tom ,the age is 25 ,the gender is man</span><br><span class="line">let bind_fn1 = print.bind(obj2,[25],[&apos;man&apos;]);</span><br><span class="line">bind_fn1();  //the name is tom ,the age is 25 ,the gender is man</span><br><span class="line">let bind_fn2 = print.bind(obj2,[25,&apos;man&apos;]);</span><br><span class="line">bind_fn2();  //the name is tom ,the age is 25,man ,the gender is undefined</span><br><span class="line"></span><br><span class="line">// 重新绑定不成功</span><br><span class="line">let re_bind = bind_fn.bind(obj1)</span><br><span class="line">re_bind()       //the name is tom ,the age is 25 ,the gender is man</span><br></pre></td></tr></table></figure>
</li>
<li><p>三者相同的点</p>
</li>
</ul>
<ol>
<li>第一个参数都是要指向的对象。</li>
<li>都采用后续传参。</li>
</ol>
<ul>
<li>三者不同点</li>
</ul>
<ol>
<li>传参方式不同：call按顺序单个传入即可，apply放在数组中传入，bind均可。</li>
<li>call和apply会直接执行函数，bind等到调用时才会执行。</li>
<li>call和apply是单次绑定，bind绑定之后不能再改变。</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>在以下代码中，yellow并没有say属性，我们不想再给yellow添加say属性，我们可以用其他对象的属性（say）来操作：要注意的是==yellow调用了fruit的say属性==</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 动态改变函数内部this指向</span><br><span class="line"></span><br><span class="line">function fruit()&#123;&#125;</span><br><span class="line"></span><br><span class="line">fruit.prototype=&#123;</span><br><span class="line">    color:&apos;red&apos;,</span><br><span class="line">    say:function()&#123;</span><br><span class="line">        console.log(&apos;the color is&apos;, this.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var yellow=&#123;</span><br><span class="line">    color:&apos;yellow&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var apple = new fruit();</span><br><span class="line">apple.say.call(yellow);</span><br><span class="line">// the color is yellow</span><br></pre></td></tr></table></figure>

<h3 id="applay-和-call-的应用"><a href="#applay-和-call-的应用" class="headerlink" title="applay 和 call 的应用"></a>applay 和 call 的应用</h3><p>1、数组之间追加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数组之间追加</span><br><span class="line">var array1 = [12 , &quot;foo&quot; , &#123;name :&quot;Joe&quot;&#125; , -2458]; </span><br><span class="line">var array2 = [&quot;Doe&quot; , 555 , 100]; </span><br><span class="line"></span><br><span class="line">// 相当于array1.push(&quot;Doe&quot; , 555 , 100)</span><br><span class="line">Array.prototype.push.call(array1, array2); //Array.prototype.push.apply(array1, array2);</span><br><span class="line">console.log(array1)</span><br><span class="line">// [ 12, &apos;foo&apos;, &#123; name: &apos;Joe&apos; &#125;, -2458, [ &apos;Doe&apos;, 555, 100 ] ]</span><br></pre></td></tr></table></figure>

<p>2、获取数组中最值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// max &amp;&amp; min</span><br><span class="line">var  numbers = [5, 458 , 120 , -215 ]; </span><br><span class="line">var maxInNumbers1 = Math.max.apply(Math, numbers);  </span><br><span class="line">var maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); </span><br><span class="line">console.log(maxInNumbers1);//458</span><br><span class="line">console.log(maxInNumbers);//458</span><br></pre></td></tr></table></figure>

<p>3、判断是不是数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m=[1,2,3]</span><br><span class="line">function isArray(obj)&#123; </span><br><span class="line">    return Object.prototype.toString.call(obj) === &apos;[object Array]&apos; ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y=isArray(m)</span><br><span class="line">console.log(y)//true</span><br></pre></td></tr></table></figure>

<p>4、类（伪）数组使用数组方法:Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>编写log函数，实现console.log的功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> function log(msg)&#123;</span><br><span class="line">     console.log(msg)</span><br><span class="line"> &#125;</span><br><span class="line"> log(1);     //1</span><br><span class="line"> log(1,2);   //1</span><br><span class="line"></span><br><span class="line">//--------------------------------------------</span><br><span class="line">// 传入多个参数时</span><br><span class="line"> function log()&#123;</span><br><span class="line">     console.log.apply(console, arguments);</span><br><span class="line">   &#125;;</span><br><span class="line">   log(1);    //1</span><br><span class="line">   log(1,2);    //1 2</span><br><span class="line">// ------------------------------------</span><br><span class="line">// 下来的要求是给每一个 log 消息添加一个&quot;(app)&quot;的前辍，比如：</span><br><span class="line"></span><br><span class="line">// log(&quot;hello world&quot;);    //(app)hello world</span><br><span class="line">// 　　该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样：</span><br><span class="line"></span><br><span class="line">function log()&#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments);</span><br><span class="line">  args.unshift(&apos;(app)&apos;);  </span><br><span class="line">  console.log.apply(console, args);</span><br><span class="line">&#125;;</span><br><span class="line">log(&apos;hello world&apos;)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/mongodb-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/mongodb-1/" itemprop="url">mongodb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T20:30:00+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.runoob.com/mongodb/mongodb-dropdatabase.html" target="_blank" rel="noopener">教程</a></p>
<h4 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h4><p>安装完成后，去文件夹里边运行mongod.exe启动数据库。</p>
<h4 id="bson文件"><a href="#bson文件" class="headerlink" title="bson文件"></a>bson文件</h4><ol>
<li>什么是bson文件</li>
</ol>
<ul>
<li>json的一种二进制形式的存储格式，简称Binary JSON，和json一样支持内嵌的文档对象和数组对象，但是bson有json没有的一些数据类型，如Date和BinDate类型。</li>
<li>可作为网络数据交换的一种存储形式，优点灵活性高，缺点空间利用率不理想。</li>
<li>特点：轻量型，可遍历，高效性</li>
</ul>
<ol start="2">
<li>bson在mongoDB中的使用</li>
</ol>
<ul>
<li>存储数据和网络数据交换。把格式转化成文档。可理解为数据库中的一条记录。</li>
<li>使用这种存储结构主要因为其可遍历性。</li>
</ul>
<ol start="3">
<li>几个bson例子</li>
</ol>
<ul>
<li>Document的BSON表示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    title:&quot;MongoDB&quot;,  </span><br><span class="line">    last_editor:&quot;192.168.1.122&quot;,  </span><br><span class="line">    last_modified:new Data(&quot;27/06/2011&quot;),  </span><br><span class="line">    body:&quot;MongoDB introduction&quot;,  </span><br><span class="line">    categories:[&quot;Database&quot;,&quot;NoSQL&quot;,&quot;BSON&quot;],  </span><br><span class="line">    revieved:false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由key/value对组成的</p>
<ul>
<li>嵌套的例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    name:&quot;lemo&quot;,  </span><br><span class="line">    age:&quot;12&quot;,  </span><br><span class="line">    address:&#123;  </span><br><span class="line">        city:&quot;suzhou&quot;,  </span><br><span class="line">        country:&quot;china&quot;,  </span><br><span class="line">        code:215000  </span><br><span class="line">    &#125;  </span><br><span class="line">    scores:[  </span><br><span class="line">        &#123;&quot;name&quot;:&quot;english&quot;,&quot;grade:3.0&#125;,  </span><br><span class="line">        &#123;&quot;name&quot;:&quot;chinese&quot;,&quot;grade:2.0&#125;  </span><br><span class="line">    ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导入数据库（含有json和bson文件）"><a href="#导入数据库（含有json和bson文件）" class="headerlink" title="导入数据库（含有json和bson文件）"></a>导入数据库（含有json和bson文件）</h4><p>先进入mongo数据库：进入MongoDB中bin文件，打开控制台，输入命令:</p>
<blockquote>
<p>$ mongo</p>
</blockquote>
<p>查看所有数据库,看是否存在对应数据库:</p>
<blockquote>
<p>$ show dbs</p>
</blockquote>
<p>切换到要导入的数据库：</p>
<blockquote>
<p>$ use &lt;要导入的数据库&gt;</p>
</blockquote>
<p>执行删除命令：</p>
<blockquote>
<p>$ db.dropDatabase()</p>
</blockquote>
<p>==之后进入到数据库文件（要导入的数据库）上一级打开命令行，恢复删除的数据库(PM2)：==</p>
<blockquote>
<p>$ mongorestore -h localhost -d PM2  ./PM2</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/微信授权登录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/微信授权登录/" itemprop="url">微信授权登录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T18:37:00+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="整体登陆流程"><a href="#整体登陆流程" class="headerlink" title="整体登陆流程"></a>整体登陆流程</h3><p><img src="https://s2.ax1x.com/2019/09/29/u34wrR.png" alt="image"></p>
<h3 id="前期准备注意事项"><a href="#前期准备注意事项" class="headerlink" title="前期准备注意事项"></a>前期准备注意事项</h3><ul>
<li>关于appid和appsecret</li>
</ul>
<p>每个开发者都要去<br><a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a><br>注册小程序账号（不同于公众号账号），注册成功后，会分配一个appid和appsecret（公众号也有，但是不一样）,记住自己的appid和appsecret,==之后新建项目时的appid一定要填自己的appid==，否则很多地方都会报错。</p>
<h3 id="小程序获得code"><a href="#小程序获得code" class="headerlink" title="小程序获得code"></a>小程序获得code</h3><p>==code只存在五分钟，重复使用会报错，过期会报错==</p>
<ul>
<li>原生小程序目录结构</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/09/29/u34qzQ.png" alt="image"></p>
<p>小程序项目启动的时候首先执行app.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: function () &#123;</span><br><span class="line">    // 展示本地存储能力</span><br><span class="line">    var logs = wx.getStorageSync(&apos;logs&apos;) || []</span><br><span class="line">    logs.unshift(Date.now())</span><br><span class="line">    wx.setStorageSync(&apos;logs&apos;, logs)</span><br><span class="line"></span><br><span class="line">    // 微信登录</span><br><span class="line">    wx.login(&#123;</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        // 发送 res.code 到后台换取 openId, sessionKey, unionId</span><br><span class="line">        console.log(res.code);</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">          url: &apos;http://127.0.0.1:7001/wechat_login&apos;,</span><br><span class="line">          method: &apos;POST&apos;,</span><br><span class="line">          data: &#123;</span><br><span class="line">            &quot;code&quot;: res.code</span><br><span class="line">          &#125;,</span><br><span class="line">          success: res =&gt; &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 获取用户信息</span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        if (res.authSetting[&apos;scope.userInfo&apos;]) &#123;</span><br><span class="line">          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: res =&gt; &#123;</span><br><span class="line">              // 可以将 res 发送给后台解码出 unionId</span><br><span class="line">              this.globalData.userInfo = res.userInfo</span><br><span class="line"></span><br><span class="line">              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span><br><span class="line">              // 所以此处加入 callback 以防止这种情况</span><br><span class="line">              if (this.userInfoReadyCallback) &#123;</span><br><span class="line">                this.userInfoReadyCallback(res)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData: &#123;</span><br><span class="line">    userInfo: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="后端获得openid-egg"><a href="#后端获得openid-egg" class="headerlink" title="后端获得openid(egg)"></a>后端获得openid(egg)</h3><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><ul>
<li>安装nodejs环境</li>
<li>创建egg环境（只需安装一次）</li>
</ul>
<blockquote>
<p>$ npm i egg-init -g</p>
</blockquote>
<ul>
<li>创建项目</li>
</ul>
<blockquote>
<p>$ egg-init projecrName –type=simple</p>
</blockquote>
<p>进入项目文件夹，安装依赖</p>
<blockquote>
<p>$ npm install</p>
</blockquote>
<p>执行项目 </p>
<blockquote>
<p>$ npm run dev</p>
</blockquote>
<h4 id="写接口获得openid"><a href="#写接口获得openid" class="headerlink" title="写接口获得openid"></a>写接口获得openid</h4><ul>
<li>初始化目录</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/09/29/u3oXsH.png" alt="image"></p>
<ul>
<li>router.js</li>
</ul>
<p>此文件用来定义路由规则，前端调接口后，进入此文件，根据路由规则调用相应的controller。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use strict&apos;;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @param &#123;Egg.Application&#125; app - egg application</span><br><span class="line"> */</span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; = app;</span><br><span class="line">  </span><br><span class="line">  router.get(&apos;/&apos;, controller.home.index);</span><br><span class="line">  </span><br><span class="line">  // 微信登陆测试接口</span><br><span class="line">  </span><br><span class="line">  router.post(&apos;/wechat_login&apos;,controller.login.wechat.wechat_login);</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据路由规则进入 controller，调用相应的方法。</li>
</ul>
<p>controller主要是对前端数据进行处理，将处理结果给到service之后由service返回给前端。当然也可以直接从controller返回，但是不建议这样做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--controller/login/wechat.js--&gt;</span><br><span class="line"></span><br><span class="line">const Controller = require(&apos;egg&apos;).Controller;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller &#123;</span><br><span class="line">	</span><br><span class="line">	async wechat_login()&#123;</span><br><span class="line">	</span><br><span class="line">		const code = ctx.request.body.code;</span><br><span class="line">		const APPID = &apos;wxfbec66754634f5bf&apos;;</span><br><span class="line">		const SECRET = &apos;394fb3d841fb78427fe0e5672c4fc58e&apos;;</span><br><span class="line">		console.log(&apos;前端传回code---&gt;&apos;,code);</span><br><span class="line">		console.log(&apos;appid---&gt;&apos;,APPID);</span><br><span class="line">		console.log(&apos;secret---&gt;&apos;,SECRET);</span><br><span class="line">		</span><br><span class="line">		&lt;!--获取openid--&gt;</span><br><span class="line">		const url = &apos;https://api.weixin.qq.com/sns/jscode2session?appid=&apos; + APPID + &apos;&amp;secret=&apos; + SECRET + &apos;&amp;js_code=&apos; + code + &apos;&amp;grant_type=authorization_code&apos;</span><br><span class="line">		&lt;!--// const result =await ctx.curl(&apos;https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=CODE&amp;grant_type=authorization_code&apos;)--&gt;</span><br><span class="line">		&lt;!--// 上述接口拼接方式错误，code等变量没有引进来--&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!--要用await，因为返回的是promise--&gt;</span><br><span class="line">		const result = await ctx.curl(url,&#123;</span><br><span class="line">			// 定义返回数据的格式是json格式，不然返回的openid和session_key是16进制加密的</span><br><span class="line">			dataType:&apos;json&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">		console.log(result)</span><br><span class="line">		</span><br><span class="line">		// 调用service，传递进去的参数应该是key-value形式</span><br><span class="line">		</span><br><span class="line">		const info = await ctx.service.login.wechat._wechat_login(result.data);</span><br><span class="line">		</span><br><span class="line">		// openid送到前端</span><br><span class="line">		</span><br><span class="line">		ctx.body = &#123;</span><br><span class="line">			</span><br><span class="line">			code:200,</span><br><span class="line">			</span><br><span class="line">			// 不经service直接返回			</span><br><span class="line">			// data:&#123;</span><br><span class="line">			// 	openid:openid</span><br><span class="line">			// &#125;</span><br><span class="line">			</span><br><span class="line">			// 经过service处理返回，之后返回到前端</span><br><span class="line">			data:info</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = UserController;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>1.完成以上步骤后直接运行，会报错 missing csrf token，csrf是为了防止进攻，要求发起请求前要在header里面添加token,对初学者，可以关掉csrf,打开/config/config.default.js添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">config.security = &#123;</span><br><span class="line"> csrf: &#123;</span><br><span class="line">  enable: false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以调通了。</p>
<p>2.后端报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errcode: 40029, errmsg: &quot;invalid code, hints: [ req_id: HQd79a0747th31 ]</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html" target="_blank" rel="noopener">官方调取获得openid接口说明</a></li>
<li>造成code无效的原因有三方面：</li>
</ul>
<p>【1】code连续调用两次，通过查看调接口详情可以看到是否调用了两次。</p>
<p>【2】APPid和appsecret不符合，这就是为什么最开始要使用自己的appid和appsecret的原因。</p>
<p>【3】URL拼接不对，去看看你是不是丢了‘&amp;’</p>
<ul>
<li>service</li>
</ul>
<p>service拿到controller的数据之后，根据条件执行对数据库或者其他的处理。最终将数据返回给controller，controller返回前端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- service/login/wechat.js --&gt;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">const Service = require(&apos;egg&apos;).Service;</span><br><span class="line"></span><br><span class="line">class LoginService extends Service &#123;</span><br><span class="line"></span><br><span class="line">	async _wechat_login(options) &#123;</span><br><span class="line">		let result = &#123;</span><br><span class="line">			data:&#123;</span><br><span class="line">				openid:&apos;&apos;,</span><br><span class="line">				_id:&apos;&apos;,</span><br><span class="line">			&#125;,</span><br><span class="line">			msg:&apos;&apos;</span><br><span class="line">		&#125;</span><br><span class="line">		let m = await this.ctx.model.User.findOne(&#123;openid:options.openid&#125;)</span><br><span class="line">		console.log(&apos;m---&gt;&apos;,m);</span><br><span class="line">		if(m != null)&#123;			</span><br><span class="line">		 result = &#123;</span><br><span class="line">				data:&#123;</span><br><span class="line">					openid:m.openid,</span><br><span class="line">					_id:m._id</span><br><span class="line">				&#125;,</span><br><span class="line">				msg:&apos;find&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			let res = await this.ctx.model.User.create(options)</span><br><span class="line">			console.log(&apos;res---&gt;&apos;,res)</span><br><span class="line">			result = &#123;</span><br><span class="line">				data:&#123;</span><br><span class="line">					openid:res.openid,</span><br><span class="line">					_id:res._id</span><br><span class="line">					&#125;,</span><br><span class="line">				msg: &apos;add&apos;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = LoginService;</span><br></pre></td></tr></table></figure>

<ul>
<li>model</li>
</ul>
<p><em>跨域设置</em></p>
<p>安装egg-cors</p>
<blockquote>
<p>npm i egg-cors –save-dev</p>
</blockquote>
<p>在/config/plugin.js里面添加跨域插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cors : &#123;</span><br><span class="line">    enable: true,</span><br><span class="line">    package: &apos;egg-cors&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在/config/config.default.js添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config.cors = &#123;</span><br><span class="line">    origin: &apos;*&apos;, // 访问白名单,根据你自己的需要进行设置</span><br><span class="line">    allowMethods: &apos;GET,HEAD,PUT,POST,DELETE,PATCH&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>配置mongoose</em></p>
<p>安装</p>
<blockquote>
<p>npm install egg-mongoose –save</p>
</blockquote>
<p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// config/plugin.js</span><br><span class="line">exports.mongoose = &#123;</span><br><span class="line">    enable: true,</span><br><span class="line">    package: &apos;egg-mongoose&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">// config/config.default.js</span><br><span class="line">config.mongoose = &#123;</span><br><span class="line">    url: &apos;mongodb://你的mongodb地址/apiExample&apos;,  //apiExample是你新建的数据库的名称</span><br><span class="line">    options: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  model定义数据库字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--model/user.js--&gt;</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  const mongoose = app.mongoose;</span><br><span class="line">  const Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">&lt;!--定义数据库字段--&gt;</span><br><span class="line">  const UserSchema = new Schema(&#123;</span><br><span class="line">    openid: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      unique: true,</span><br><span class="line">      required: true,</span><br><span class="line">    &#125;,</span><br><span class="line">	session_key: &#123;</span><br><span class="line">	  type: String,</span><br><span class="line">	  unique: true,</span><br><span class="line">	  required: true,</span><br><span class="line">	&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  return mongoose.model(&apos;User&apos;, UserSchema);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/跨页面传参/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/跨页面传参/" itemprop="url">跨页面传参</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T18:29:00+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>application跳转到AfterApplication</p>
</blockquote>
<ul>
<li>application 页面代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goAfterApplication: function() &#123;</span><br><span class="line">  console.log(&apos;传递的参数&apos;,this.data.applyMessage)  //applyMessage是一个对象，包含所有要传递的参数</span><br><span class="line">  //页面传参</span><br><span class="line">  wx.navigateTo(&#123;</span><br><span class="line">    url: &apos;../AfterApplication/AfterApplication?applyMessage=&apos;+encodeURIComponent(JSON.stringify(this.data.applyMessage)),</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>AfterApplication代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function(options) &#123;</span><br><span class="line">   //接收参数</span><br><span class="line">   let decode = decodeURIComponent(options.applyMessage);</span><br><span class="line">   let applymessage = JSON.parse(decode);</span><br><span class="line">   console.log(&apos;接收applyMessage&apos;, applymessage)</span><br><span class="line">   this.setData(&#123;</span><br><span class="line">     ApplyMessage: applymessage</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jerry">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
