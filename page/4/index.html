<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Jerry&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Jerry&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jerry&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Jerry's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jerry's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/16/webpack-实战配置讲解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/16/webpack-实战配置讲解/" itemprop="url">webpack-实战配置讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-16T20:20:22+08:00">
                2020-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="打包库代码"><a href="#打包库代码" class="headerlink" title="打包库代码"></a>打包库代码</h3><h4 id="创建函数库library"><a href="#创建函数库library" class="headerlink" title="创建函数库library"></a>创建函数库library</h4><p>初始化库项目</p>
<blockquote>
<p>npm init -y</p>
</blockquote>
<p>创建math.js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export function add(a,b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">export function minus(a,b)&#123;</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line">export function muitiply(a,b)&#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">export function division(a,b)&#123;</span><br><span class="line">    return a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建string.js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function join(a,b)&#123;</span><br><span class="line">    return a +&apos;&apos;+ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建index.js 文件，引用他们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as math from &apos;./math&apos;;</span><br><span class="line">import * as string from &apos;./string&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;math,string&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们的函数库已经准备好了，接下来就是打包好被浏览器使用。</p>
<blockquote>
<p>npm install webpack webpack-cli -D</p>
</blockquote>
<p>在package.json中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;:&quot;webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后创建配置文件 webpack.config.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import path from &apos;path&apos;</span><br><span class="line">module.exports =&#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:&apos;./src/index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,&apos;dist&apos;);</span><br><span class="line">        filename:&apos;library.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是业务代码，至此我们已经打包完成了。</p>
<p>但是由于是函数库，在使用时可能存在多种引用的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const library = require(&apos;library&apos;);</span><br><span class="line"></span><br><span class="line">import library from &apos;library&apos;;</span><br><span class="line"></span><br><span class="line">//AMD</span><br><span class="line">require([&apos;library&apos;],function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>需要到配置文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    path:path.resolve(__dirname,&apos;dist&apos;),</span><br><span class="line">    filename:&apos;library.js&apos;,</span><br><span class="line">    libraryTarget:&apos;umd&apos; //支持以上三种方式引入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还可能希望这个库可以从script标签中引入，然后通过全局变量library来使用，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&apos;library.js&apos;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">library.math()</span><br></pre></td></tr></table></figure>

<p>这时候需要增加配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    path:path.resolve(__dirname,&apos;dist&apos;),</span><br><span class="line">    filename:&apos;library.js&apos;,</span><br><span class="line">    library:&apos;library&apos;, //将library.js挂载到全局变量library上</span><br><span class="line">    libraryTarget:&apos;umd&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好了以后，可以在dist文件夹下创建index.html文件，由此来测验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;library.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>打包后打开页面，之后在控制台输入library，会打印出库函数的内容。</p>
<p>但是有时候library和libraryTarget会搭配使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library:&apos;library&apos;, </span><br><span class="line">libraryTarget:&apos;this&apos;</span><br></pre></td></tr></table></figure>

<p>这种配置就不再支持前三种引入方式，因为配置的值不是 ‘umd’ ，这样配置的含义是设置全局变量library，然后将全局变量挂载到 this 上。</p>
<p>但是还存在这种情况，我们库中需要引入lodash库，但是别人使用我们的库的同时还想使用lodash，那么用户的代码里可能就会存在两份lodash的代码。这时候需要配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">externals:[&quot;lodash&quot;],</span><br></pre></td></tr></table></figure>

<p>这样再去打包，就会发现打包后代码小了很多。这样配置的含义是，在打包过程中，遇到了lodash这个库，就忽略这个库，不要把他打包到代码中去。但是别人在使用的时候，不仅要引入library库还要引入lodash库，因为我们打代码并没有打包lodash但是却用到了lodash，只好让别人引入，是用别人引入的lodash。</p>
<p><a href="https://webpack.js.org/configuration/externals/#root" target="_blank" rel="noopener">externals</a> 配置项还有很多，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    lodash：&#123;</span><br><span class="line">        commonjs：&apos;lodash&apos;,//lodash这个库在common.js下被使用（require形式），即别人使用我们代码的时候以这种弄形式引入，那么lodash的名字，必须为lodash 不能是 _ 等其他的。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    lodash：&#123;</span><br><span class="line">    root:&apos;_&apos;, // 通过script标签引入lodash的时候，会自动驻入一个全局变量 _</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们想要给别人用的库是打包后的library.js 还需要在package.json文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;./dist/library.js&quot;,</span><br></pre></td></tr></table></figure>

<p>之后可以在npm官网上申请账号，然后执行：</p>
<blockquote>
<p>npm adduser</p>
</blockquote>
<p>输入用户名和密码</p>
<blockquote>
<p>npm publish</p>
</blockquote>
<p>将项目发布到npm仓库中，但是不能重名（可以在package.json中配置name），之后别人用这个仓库（library）的时候，直接：</p>
<blockquote>
<p>npm install library</p>
</blockquote>
<h3 id="Progressive-Web-Application-PWA打包设置"><a href="#Progressive-Web-Application-PWA打包设置" class="headerlink" title="Progressive Web Application(PWA打包设置)"></a>Progressive Web Application(PWA打包设置)</h3><p>即将打包后的代码放到服务器上，就可以跑起来我们的项目。安装http-server 来模拟服务器。</p>
<blockquote>
<p>npm install http-server –save -dev</p>
</blockquote>
<p>之后在package.json中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;start&quot;: &quot;http-server dist&quot;, //在dist文件夹下创建一台服务器，将打包后的文件在服务器上跑起来</span><br></pre></td></tr></table></figure>

<p>之后运行 npm run start，会看到服务器跑起来，当然在这种之前你要对自己的代码进行打包。</p>
<p>此时你关闭服务器，刷新页面就会显示无法访问此网站。PWA 的功能就是，当你访问页面成功时，即使服务器已经挂掉，浏览器依旧可以显示上次访问成功的缓存。</p>
<p>首先安装插件：</p>
<blockquote>
<p> npm install workbox-webpack-plugin -D</p>
</blockquote>
<p>之后进行配置，因为只有在上线的代码中才需要考虑服务器是否挂掉，所以在webpack.prod.js中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const WorkBoxPlugin = require(&apos;workbox-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">        new WorkBoxPlugin.GenerateSW (&#123;</span><br><span class="line">            clientsClaim:true,</span><br><span class="line">            skipWaiting:true</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>之后打包会发现dist文件夹下会产生两个文件，除此之外，还要写逻辑代码：index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (&quot;serviceWorker&quot; in navigator) &#123;</span><br><span class="line">  window.addEventListener(&quot;load&quot;, () =&gt; &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(&quot;/service-worker.js&quot;)</span><br><span class="line">      .then((registration) =&gt; &#123;</span><br><span class="line">        console.log(&quot;SW registered: &quot;, registration);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((registrationError) =&gt; &#123;</span><br><span class="line">        console.log(&quot;SW registration failed: &quot;, registrationError);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的含义是，如果浏览器支持serviceWorker，就给浏览器添加监听事件。然后再次刷新的时候就会发现第一次访问的页面被保存下来。但是谷歌浏览器并没有默认支持serviceWorker。</p>
<h3 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h3><p>js有很强的灵活性，这也导致不同人的代码有不同的风格，如果团队开发会很不便利。TypeScript 对js做出了规范。使用TypeScript会对我们代码不规范处报错提示，可以有效提升js代码的可维护性。</p>
<p>安装 TypeScript 模块</p>
<blockquote>
<p>npm install typescript -D</p>
</blockquote>
<p>TypeScript 代码文件以 .tsx 结尾，在index.tsx 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting:string;</span><br><span class="line">    constructor(message:string)&#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;;</span><br><span class="line">    greet()&#123;</span><br><span class="line">        return &apos;hello&apos; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&apos;world&apos;);</span><br><span class="line"></span><br><span class="line">alert(greeter.greet())</span><br></pre></td></tr></table></figure>

<p>安装ts-loader:</p>
<blockquote>
<p>npm install ts-loader -D</p>
</blockquote>
<p>在webpack.config.js 中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.tsx?$/,</span><br><span class="line">    use:&apos;ts-loader&apos;,</span><br><span class="line">    exclude:/node_modules/,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ts-loader 打包代码时需要 tsconfig.json 文件，所以要在根目录项创建 tsconfig.json 文件，并进行配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;:&quot;./dist&quot;, // 打包后将文件放在dist目录里边</span><br><span class="line">        &quot;module&quot;: &quot;es6&quot;, // 在typeScript文件中引入模块的方式是通过es6方式引入的(import)</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;, //打包生成文件代码类型是es5</span><br><span class="line">        &quot;allowJs&quot;: true //允许在TypeScript中引入别的js模块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后将打包完成的文件复制，打开浏览器，在console中输入复制内容并回车，就可以看到代码正常运行。</p>
<p>在上述过程中，我们也可以看到 TypeScript 中的一些优点，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting:string;  </span><br><span class="line">    constructor(message:string)&#123;  // 规定接受的参数是字符串</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;;</span><br><span class="line">    greet()&#123;</span><br><span class="line">        return &apos;hello&apos; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&apos;world&apos;); // 在此处调用时，传入的参数如果为空或者不是字符串，会检测出错误。</span><br><span class="line"></span><br><span class="line">alert(greeter.greet())</span><br></pre></td></tr></table></figure>

<p>再比如，我们可能在 index.tsx中引入其他的库（以lodash为例），</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import * as _ from &apos;lodash&apos;;</span><br><span class="line">// import _ from &apos;lodash&apos;; 会报错</span><br><span class="line"></span><br><span class="line">class Greeter &#123;</span><br><span class="line">    greeting:string;</span><br><span class="line">    constructor(message:string)&#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;;</span><br><span class="line">    greet()&#123;</span><br><span class="line">        return _.join([&apos;hello&apos;, this.greeting],&apos; &apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&apos;world&apos;);</span><br><span class="line"></span><br><span class="line">alert(greeter.greet())</span><br></pre></td></tr></table></figure>

<p>但是我们在使用 _.join() 时不加参数也没有报错提醒，因为我们还要安装lodash的类型文件</p>
<blockquote>
<p>npm install @types/lodash -D</p>
</blockquote>
<h3 id="使用-WebpackDevServer-实现请求转发"><a href="#使用-WebpackDevServer-实现请求转发" class="headerlink" title="使用 WebpackDevServer 实现请求转发"></a>使用 WebpackDevServer 实现请求转发</h3><p>安装axios：</p>
<blockquote>
<p>npm install axios -D</p>
</blockquote>
<p>之后再index中发送请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Axios from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">Axios.get(&apos;http://www.dell-lee.com/react/api/header.json&apos;).then( res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是在开发环境和线上环境下，域名可能不同，我们一般不会把域名写死，而是写成以下这种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Axios from &quot;axios&quot;;</span><br><span class="line"></span><br><span class="line">Axios.get(&apos;/react/api/header.json&apos;).then( res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是直接这样是不能请求到接口的 ，因为这样写请求的是： <code>http://localhost:8080/react/api/header.json</code> 需要在webpack.dev.js中配置（因为devServer只在开发环境下起作用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist&apos;,</span><br><span class="line">    open: true,</span><br><span class="line">    hot: true,</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        &apos;/react/api&apos;:&apos;http://www.dell-lee.com&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问的路径依旧是：<code>http://localhost:8080/react/api/header.json</code>,但是正确请求到了数据，这是因为以上代码设置了：当请求以<code>/react/api</code>开头的网址时，就把这个请求代理转发到<code>http://www.dell-lee.com</code></p>
<p>proxy设置项还有很多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proxy:&#123;</span><br><span class="line">    &apos;/react/api&apos;:&#123;</span><br><span class="line">        target:&apos;http://www.dell-lee.com&apos;,  // 请求代理到哪个网址</span><br><span class="line">        secure:false, //设置为false时对https生效</span><br><span class="line">        pathRewrite:&#123; //对路径的重写，比如我们需要访问header.json，但是他还没有准备好，后台的人为我们在demo.json中写了假的数据，我们先访问demo.json，这样等header.json准备好了之后，直接将这句注释掉就好了，不用去业务代码里边修改</span><br><span class="line">            &apos;header.json&apos;:&apos;demo.json&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        changeOrigin:true, // 改变请求中的Origin选项，支持更多访问</span><br><span class="line">        headers:&#123; //在请求头中定义一些东西</span><br><span class="line">            host:&apos;www.dell-lee.com&apos;,</span><br><span class="line">            cookie:&apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WebpackDevServer-解决单页面应用路由问题"><a href="#WebpackDevServer-解决单页面应用路由问题" class="headerlink" title="WebpackDevServer 解决单页面应用路由问题"></a>WebpackDevServer 解决单页面应用路由问题</h3><p>首先准备以下文件代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import React ,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;hello Jerry&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line"></span><br><span class="line">//home.js</span><br><span class="line">import React , &#123;Component&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">class Home extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;HomePage&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br><span class="line"></span><br><span class="line">//list.js</span><br><span class="line">import React , &#123;Component&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">class List extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;ListPage&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default List;</span><br></pre></td></tr></table></figure>

<p>我们希望达到这种效果：当访问<code>http://localhost:8080/</code>显示home页面，访问<code>http://localhost:8080/list</code>显示list页面。</p>
<p>首先安装：</p>
<blockquote>
<p>npm install react-router-dom -D</p>
</blockquote>
<p>之后在index中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import ReactDom from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; BrowserRouter, Route &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import Home from &quot;./home&quot;;</span><br><span class="line">import List from &quot;./list&quot;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=&quot;/&quot; exact component=&#123;Home&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/list&quot; component=&#123;List&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>

<p>之后运行代码，发现访问根路径的时候正常，但是访问list时会说找不到，原因是当你访问list时，浏览器会尝试访问list页面，但是打包后只有index.html，所以会说找不到。</p>
<p>这时候需要我们去devServer中配置historyApiFallback:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback:true, //当然是在开发环境下</span><br></pre></td></tr></table></figure>

<p>上线后还可能存在找不到页面得情况，需要后端做相应的配置。</p>
<p>这样的话，不管我们访问任何路径，都会变成对根路径的请求，都加载index.hrml，这样我们业务代码中的逻辑才会生效。</p>
<p>historyApiFallback可配置项还有很多，可以去官网查看。</p>
<h3 id="Eslint-在webpack中的配置"><a href="#Eslint-在webpack中的配置" class="headerlink" title="Eslint 在webpack中的配置"></a>Eslint 在webpack中的配置</h3><p>eslint是规范代码的工具，首先安装eslint：</p>
<blockquote>
<p>npm install eslint -D</p>
</blockquote>
<p>但是具体怎么约束代码还需要配置文件，我们可以通过以下方式自动生成：</p>
<blockquote>
<p>npx eslint –init </p>
</blockquote>
<p>过程中会问一些问题，默认第一个就好。</p>
<p>安装好后会出现新的文件.eslintrc.js </p>
<p>如果想对src文件下的代码进行检测的话，在命令行运行</p>
<blockquote>
<p>npx eslint src</p>
</blockquote>
<p>然后，就会检测出来代码中的错误。这样就会检测出代码中的错误。还有种更加简单的使用方法，就是直接在编辑器中安装eslint插件，然后就会自动检测出来错误代码，下边标红。这样就不必再通过命令行进行检错，比较方便。</p>
<p>当然可能存在某种情况，就是我们希望遵循eslint下面大部分规范，但是也有部分规范是我们不想遵循的，我们可以在eslintrc.js文件下配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">    &quot;xxx&quot;:0  //代码不遵循xxx规范，这个xxx在代码标红的时候回提示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用document时也会报错，因为document是全局变量，直接使用时会报错，可以进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globals:&#123;</span><br><span class="line">    document:false//不允许覆盖document</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是团队中不可能每个人都用相同的编辑器，有的编辑器不能安装eslint插件，这时候就需要在webpack中配置。</p>
<p>安装：</p>
<blockquote>
<p>npm install eslint-loader –save-dev</p>
</blockquote>
<p>因为一般我们都是用eslint处理js文件，所以在webpack中配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">    use:[&quot;babel-loader&quot;,&quot;eslint-loader&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>先用eslint做检测然后执行babel。但是代码错误提示依旧是在命令行提示的，这时候可以配置devServer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overlay:true</span><br></pre></td></tr></table></figure>

<p>这时候在用webpaceDevServer时检测出来错误，就会在浏览器上直接出现一层提示：</p>
<p><img src="https://s1.ax1x.com/2020/05/16/YcanU0.png" alt="image"></p>
<p>但是这种用法会很大程度上影响打包速度，以为每次打包前都要先对代码进行检测。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/webpack-核心/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/webpack-核心/" itemprop="url">webpack-核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-10T17:51:06+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TreeShaking"><a href="#TreeShaking" class="headerlink" title="TreeShaking"></a>TreeShaking</h3><p>math.js模块下有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export const add = (a,b)=&gt;&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const minus = (a,b) =&gt; &#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在index.js中只引入了一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;add&#125; from &apos;./math&apos;</span><br><span class="line"></span><br><span class="line">add(1,2);</span><br></pre></td></tr></table></figure>

<p>但是看打包后的文件可以知道，math模块的两个办法都被压缩了，这样做是多余的。</p>
<p>TreeShaking的作用就是，用到哪个方法就压缩哪个方法。</p>
<h4 id="mode-development下"><a href="#mode-development下" class="headerlink" title="mode:development下"></a>mode:development下</h4><p>webpack配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class="line">optimization:&#123;</span><br><span class="line">    usedExports:true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>另外还需在package.json中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sideEffects&quot;:false,</span><br></pre></td></tr></table></figure>

<p>sideEffects的作用是对哪些模块不使用treeShaking ，设置为false的话意思是对每个模块都是用treeShaking。一般由项目中我们会引用css样式文件，使用treeshaking的话，他会去看css文件输出了什么，什么都没有输出的话，打包的时候可能会忽略css文件。所以我们需要设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sideEffects&quot;:[&apos;*css&apos;]  //对css文件不使用treeshaking</span><br></pre></td></tr></table></figure>

<p>注意：treeshaking只支持ES Module（import）的引入方式，不支持别的引入方式。</p>
<h4 id="mode：production下"><a href="#mode：production下" class="headerlink" title="mode：production下"></a>mode：production下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode: &apos;production&apos;,</span><br><span class="line">   devtool: &apos;cheap-module-source-map&apos;,</span><br><span class="line">   // optimization:&#123;  不需要再配置</span><br><span class="line">   //     usedExports:true</span><br><span class="line">   // &#125;,</span><br></pre></td></tr></table></figure>

<p>还需在package.json中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;sideEffects&quot;:false,</span><br></pre></td></tr></table></figure>

<h3 id="development和production区分打包"><a href="#development和production区分打包" class="headerlink" title="development和production区分打包"></a>development和production区分打包</h3><p>差异：</p>
<ul>
<li>开发环境用development，线上环境用production。</li>
<li>development中sourceMap比较全，可以快速定位代码问题。在production中，sourceMap比较简洁，可以单独的.map文件来存储。</li>
<li>开发环境下不压缩，production下压缩。</li>
<li>devtool,optimization设置存在差异。并且production下不需要devServer（不需要运行）</li>
</ul>
<p>既然两种模式下的配置存在差异，那么在开发环境下和上线环境下就会频繁去更改设置，我们可以这样做，<br>将原来的webpack.config.js改名为webpack.dev.js，具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/treeShaking/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        usedExports:true</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &apos;./dist&apos;,</span><br><span class="line">        open: true,</span><br><span class="line">        hot: true,</span><br><span class="line">        hotOnly: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                exclude: /node_modules/,</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    //在.babelrc中配置babel-loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            importLoaders: 2,</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(svg|ttf|woff|eot)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;file-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;fonts&apos;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建webpack.prod.js具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    devtool: &apos;cheap-module-source-map&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/treeShaking/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // optimization:&#123;</span><br><span class="line">    //     usedExports:true</span><br><span class="line">    // &#125;,</span><br><span class="line">    // devServer: &#123;</span><br><span class="line">    //     contentBase: &apos;./dist&apos;,</span><br><span class="line">    //     open: true,</span><br><span class="line">    //     hot: true,</span><br><span class="line">    //     hotOnly: true,</span><br><span class="line">    // &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                exclude: /node_modules/,</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    // 在.babelrc文件中配置babel-loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            importLoaders: 2,</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(svg|ttf|woff|eot)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;file-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;fonts&apos;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        // new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在package.json配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &quot;build&quot;:&quot;webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>需要线上打包时运行npm run build 即可。</p>
<p>我们看到，两个配置文件中有很多重复的代码，我们可以建立webpack.common.js文件，来存放共有代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/treeShaking/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                exclude: /node_modules/,</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    // &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123;</span><br><span class="line">                    //     useBuiltIns:&apos;usage&apos;,</span><br><span class="line">                    //     targets:&#123;</span><br><span class="line">                    //         chrome:&apos;67&apos;</span><br><span class="line">                    //     &#125;</span><br><span class="line">                    // &#125;]]</span><br><span class="line"></span><br><span class="line">                    // &quot;plugins&quot;: [</span><br><span class="line">                    //     [</span><br><span class="line">                    //         &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">                    //         &#123;</span><br><span class="line">                    //             &quot;corejs&quot;: 2,</span><br><span class="line">                    //             &quot;helpers&quot;: true,</span><br><span class="line">                    //             &quot;regenerator&quot;: true,</span><br><span class="line">                    //             &quot;useESModules&quot;: false</span><br><span class="line">                    //         &#125;</span><br><span class="line">                    //     ]</span><br><span class="line">                    // ]</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            importLoaders: 2,</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(svg|ttf|woff|eot)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;file-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;fonts&apos;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用然后使用webpack-merge将文件结合起来：</p>
<blockquote>
<p>npm install webpack-merge -D</p>
</blockquote>
<p>在webpack.dev.js中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const CommonConfig = require(&apos;./webpack.common&apos;)</span><br><span class="line"></span><br><span class="line">const devConfig = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class="line"></span><br><span class="line">    optimization:&#123;</span><br><span class="line">        usedExports:true</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &apos;./dist&apos;,</span><br><span class="line">        open: true,</span><br><span class="line">        hot: true,</span><br><span class="line">        // hotOnly: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    ],</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = merge(CommonConfig,devConfig);</span><br></pre></td></tr></table></figure>

<p>webpack.prod.js中同理。</p>
<p>我们还可以将所有webpack相关文件都放到build文件夹下，但是这样需要修改package文件中配置文件的路径。</p>
<h3 id="webpack和codeSplitting"><a href="#webpack和codeSplitting" class="headerlink" title="webpack和codeSplitting"></a>webpack和codeSplitting</h3><p>安装lodash 是功能集合，是一个第三方库，提供功能方法。</p>
<blockquote>
<p>npm install lodash –save</p>
</blockquote>
<p>在index.js中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import _ from &apos;lodash&apos;</span><br><span class="line"></span><br><span class="line">console.log(_.join([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],&quot;***&quot;)) //a***b***c</span><br></pre></td></tr></table></figure>

<p>打包后，lodash和业务逻辑代码都会被打包到main.js文件中，这样存在两个问题：</p>
<ul>
<li>main.js文件很大，首次访问页面，加载要耗费很长时间</li>
<li>每次改变业务逻辑都要重新加载main.js ，连同lodash都要重新加载</li>
</ul>
<p>解决：</p>
<p>创建dolash.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import _ from &apos;lodash&apos;;</span><br><span class="line">window._ =_; //将_挂载到全局，index.js中可以使用</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">console.log(_.join([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],&quot;***&quot;))</span><br></pre></td></tr></table></figure>

<p>我们去webpack.commom.js中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    lodash:&apos;./src/splitting/lodash.js&apos;,</span><br><span class="line">    main: &apos;./src/splitting/index.js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>打包后会产生两个文件lodash.js和main.js。</p>
<p>这种情况下:</p>
<ul>
<li>首次加载页面，并行加载两个js文件，而不是一个很大的main.js文件</li>
<li>改变业务代码只需要加载main.js</li>
</ul>
<p>codeSplitting：将公共代码进行拆分。</p>
<p>其实代码分割和webpack并没有本质上的关系，之所以每次提到代码分割就会提到webpack，是因为webpack提供了自动的代码分割。</p>
<p>进行如下配置即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    main: &apos;./src/splitting/index.js&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">optimization:&#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:&apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>index.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import _ from &apos;lodash&apos;</span><br><span class="line"></span><br><span class="line">console.log(_.join([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],&quot;***&quot;))</span><br></pre></td></tr></table></figure>

<p>打包后会发现lodash被打包到vendors~main.js中，业务逻辑打包到main.js文件中，不用再思考如何进行代码分割。</p>
<p>以上代码中我们同步的去加载库，然后使用它，如果我们异步加载呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">function getComponent()&#123;</span><br><span class="line">    return import(&apos;lodash&apos;).then((&#123; default: _ &#125;) =&gt; &#123;</span><br><span class="line">        var element = document.createElement(&apos;div&apos;);</span><br><span class="line">        element.innerHTML = _.join([&apos;hello&apos;,&apos;jerry&apos;],&apos;-&apos;)</span><br><span class="line">        return element</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then((element)=&gt;&#123;</span><br><span class="line">    document.body.appendChild(element);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不设置optimization，也会自动动态分割。就是不作任何配置，就会自动分割。</p>
<p>但是babel提供了<a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/" target="_blank" rel="noopener">动态引入的插件</a></p>
<p>webpack做代码分割底层该应用了 SplitChunksPlugin</p>
<h3 id="SplitChunksPlugin-参数配置"><a href="#SplitChunksPlugin-参数配置" class="headerlink" title="SplitChunksPlugin 参数配置"></a>SplitChunksPlugin 参数配置</h3><p>改变分割后代码名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">function getComponent()&#123;</span><br><span class="line">    //**************</span><br><span class="line">    return import(/*webpackChunkName:&quot;lodash&quot;*/ &apos;lodash&apos;).then(( _ ) =&gt; &#123;</span><br><span class="line">        var element = document.createElement(&apos;div&apos;);</span><br><span class="line">        element.innerHTML = _.join([&apos;hello&apos;,&apos;jerry&apos;],&apos;-&apos;)</span><br><span class="line">        return element</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then((element)=&gt;&#123;</span><br><span class="line">    document.body.appendChild(element);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>webpack.common.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:&apos;all&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    cacheGroups:&#123;</span><br><span class="line">        vendors:false,</span><br><span class="line">        default:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>对于异步的引入第三方库，webpack会自动进行代码分割，但是optimization.splitChunks中的设置并非不起作用，当不设置vendors:false时，打包后文件名字前边有前缀vendors~</p>
<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">    chunks: &quot;async&quot;, // 只对异步代码进行代码分割，配置成all则对同步异步都会代码分割,initial只对同步代码分割</span><br><span class="line">    minSize: 30000, //引入文件大于30000字节，才会做代码分割</span><br><span class="line">    maxSize:5000, //目前没有这项，之前有这个配置项，含义是当引入的模块大于5000字节时尝试二次拆分（如果还可以拆分的话）</span><br><span class="line">    minChunks: 1, //引入的模块至少用了1次才被分割。打包后chunks中至少有一个chunk应用了这个模块，才会被打包</span><br><span class="line">    maxAsyncRequests: 5,//同时只能加载5个请求，当代吗分割成10个文件，当打开网页时要同时请求10个，不满足，遇到这种情况只会分割引入的前五个库，剩下的不在分割</span><br><span class="line">    maxInitialRequests: 3,//入口文件引入的库最多分割出三个代码文件，超过则不再做代码分割</span><br><span class="line">    automaticNameDelimiter: &apos;~&apos;,//生成文件名之间的连接符，例如：vendors~main.js</span><br><span class="line">    name: true,//cacheGroups.vendors(default).filename是否有效</span><br><span class="line">    </span><br><span class="line">    cacheGroups: &#123;  //上边的配置都满足时会进到这里边看是否满足</span><br><span class="line">        vendors: &#123;</span><br><span class="line">            test: /[\\/]node_modules[\\/]/, // 是否是node_modules中的文件，当然是（npm下载的）</span><br><span class="line">            priority: -10,</span><br><span class="line">            filename:&apos;vendor.js&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    default: &#123;</span><br><span class="line">            minChunks: 2,</span><br><span class="line">            priority: -20,</span><br><span class="line">            reuseExistingChunk: true //我们引用a模块，a引用b模块，但是b之前已经打包过，打包a时就不会再对b进行打包，而是引用之前打包好的b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步代码分割步骤："><a href="#同步代码分割步骤：" class="headerlink" title="同步代码分割步骤："></a>同步代码分割步骤：</h4><ul>
<li>chunks: “all”，可以对同步代码分割</li>
<li>cacheGroups,满足vendors要求，打包到vendors组下，文件名为vendors~main.js。若设置filename则文件名为设置的文件名</li>
</ul>
<p>自己写的模块不满足vendors.test的要求，这时候会按照cacheGroups.default来打包，将文件打包到default~main.js（入口文件为main.js）同时你也可以设置filename。有的时候用filename会报错，可以改为name试试。</p>
<h4 id="cacheGroups：缓存组。"><a href="#cacheGroups：缓存组。" class="headerlink" title="cacheGroups：缓存组。"></a>cacheGroups：缓存组。</h4><p>当我们引入的两个模块都满足在cacheGroups.default时，会把两个模块都打包到default中</p>
<p>priority：优先级。当我们引入lodash这样的第三方库时会同时满足vendors和default（没有test，所有模块都满足），这是会优先存在优先级高（priority大）的文件中。</p>
<h3 id="Lazy-Load-懒加载"><a href="#Lazy-Load-懒加载" class="headerlink" title="Lazy Load 懒加载"></a>Lazy Load 懒加载</h3><p>模块懒加载指的是，异步的方式引入模块，模块什么时候被加载取决于代码怎么写，比如点击页面时加载模块。</p>
<p>懒加载的好处：使页面加载更快。不需要的先不加载。比如路由的概念，在不同路由显示不同代码。如果将页面都打包在一个包里，在访问主页的时候也会把详情页的东西加载出来，会很慢。</p>
<p>懒加载并不是webpack里边的概念，而是ES中的语法。</p>
<p>import后边可以跟then证明他会返回promise。所以必须要用polyfill。</p>
<h3 id="什么是chunk"><a href="#什么是chunk" class="headerlink" title="什么是chunk"></a>什么是chunk</h3><p>每一个打包后的文件都是一个chunk。</p>
<h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><p>在网上有很多打包分析工具，包括官网上也有推荐，其中分析的比较全面的是<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">这个</a>，以<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">另一个为例</a></p>
<p>进入package.json配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build-dev&quot;: &quot;webpack  --profile --json &gt; stats.json --config ./build/webpack.dev.js&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在打包过程中，将打包过程的描述放到stats.json文件中</p>
<p>打包后会发现根目录下生成了states.json文件，然后借助<a href="http://webpack.github.com/analyse" target="_blank" rel="noopener">工具</a>（需要翻墙），将states.json文件上传上去就会生成分析结果。</p>
<h3 id="Preloading-和-Prefetching"><a href="#Preloading-和-Prefetching" class="headerlink" title="Preloading 和 Prefetching"></a>Preloading 和 Prefetching</h3><p>像前文一样，将loadsh单独打包成一个文件，在第一次加载页面的时候去加载lodash，在第二次的时候利用缓存来加快加载速度。但是这样并没有很大程度上提高性能，我们希望的是在第一次加载页面的时候就最快加载。当我们按照以下方式写代码时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">    var element = document.createElement(&apos;div&apos;);</span><br><span class="line">    element.innerHTML = &apos;hello jerry&apos;;</span><br><span class="line">    document.body.appendChild(element);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以在控制台coverage里面看到代码的利用率，有70%多unused，是什么原因呢，原因是在没有点击的时候，这部分代码并没有起到作用，但是却加载出来，这部分相当于“无用代码”。那webpack希望我们如何做呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//handleclick.js</span><br><span class="line"></span><br><span class="line">function handleClick()&#123;</span><br><span class="line">    var element = document.createElement(&apos;div&apos;);</span><br><span class="line">    element.innerHTML = &apos;hello jerry&apos;;</span><br><span class="line">    document.body.appendChild(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default handleClick;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">   import(&apos;./handleClick&apos;).then((&#123;default:func&#125;)=&gt;&#123;</span><br><span class="line">       func();</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们再去会看到，当点击之后，打包后的handleclick文件才被加载利用，这样会使代码利用率增高。</p>
<p>这也就是为什么，optimization.splitChunks.chunks默认设置为async而不是all。他认为只有异步的加载代码才会使性能得到提高，同步的加载代码只会增加缓存。缓存并不能很高程度上的提升性能，提高代码的利用率才是提高性能的根本。</p>
<p>一个常用的场景：当进入网站主页时，不点登录框时不需要加载登录框的按钮，等到点击登录时才加载登录框按钮，但是等点击后再加载可能会使点击交互反应慢。用户体验差。</p>
<p>解决方案：当主页加载完毕时，可以认为带宽空闲，这时候就预先把登录页面加载出来。这就用到了preloading和prefetchting。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">    import(/*webpackPrefetch:true */ &apos;./handleClick&apos;).then((&#123;default:func&#125;)=&gt;&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>意思是：主要js加载完成后，网络一旦空闲，就去加载handleclick.js。</p>
<p>我们会发现，开始就会将handleclick.js加载出来，当你点击的时候会再次加载，但是再次加载是缓存里边的内容，时间会大大缩短。</p>
<p>webpackPrefetch：等你核心代码加载完成之后，才去加载对应文件。</p>
<p>webpackPrefetch：和核心代码一起加载对应文件。</p>
<h3 id="css代码分割"><a href="#css代码分割" class="headerlink" title="css代码分割"></a>css代码分割</h3><p>补充的小知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">    chunkFilename:&apos;[name].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入口文件打包回按照filename执行，入口文件中引入或者异步加载的文件，按照chunkFilename执行。并且chunkFilename打包后的文件不会引入到index.html中，因为他是main.js（打包后）引用的。</p>
<p>创建style.css文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background :green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./style.css&apos;</span><br><span class="line">console.log(&apos;hello jerry&apos;);</span><br></pre></td></tr></table></figure>

<p>打包之后可以看到，并没有打包css文件，而是只有main.js文件，这就是常说的 css in js 。</p>
<p>要想把css单独打包到一个文件中，需要用到插件：<a href="https://webpack.js.org/plugins/mini-css-extract-plugin/#root" target="_blank" rel="noopener">MiniCssExtractPlugin</a>。但是这个插件不支持 HMR 所以在开发环境中不常用，在常用于线上环境。</p>
<p>首先安装：</p>
<blockquote>
<p>npm install –save-dev mini-css-extract-plugin</p>
</blockquote>
<p>因为是在线上环境中使用，所以在webpack.prod.js中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">    plugins:[</span><br><span class="line">        new MiniCssExtractPlugin(),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>除此之外，我们之前对.css文件或者.scss文件处理使用的是style-loader和css-loader等处理的，我们需要将style.loader换成MiniCssExtractPlugin.loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            importLoaders: 2,</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，webpack.dev.css和webpack.prod.js产生了又一处差异，应将common.js中对应设置移除，分别进入各自配置文件进行配置。</p>
<p>但是不要忘记，之前我们学习treeShaking的时候讲到过，如果不设置的话会对所有文件进行treeShaking,当检测到没有使用style.css的时候会忽略对他的打包，所以要配置如下：</p>
<p>首先将usedExports移动到webpack.common.js 中，因为要对所有代码做treeShaking，之后到package.json文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;sideEffects&quot;: [</span><br><span class="line">  &quot;*.css&quot;,</span><br><span class="line">  &quot;*.scss&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>即不对css或者scss文件做treeShaking.做完以上左右处理后，我们发现，打包回会生成单独的 .css 文件。</p>
<p>除此之外还有很多配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename:&apos;[name].css&apos;,</span><br><span class="line">        chunkFilename:&apos;[name].chunk.css&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>打包后文件名按照filename进行配置，并且打包后的文件会被挂载到index.html。如果在index.js中引入多个css文件，多个css文件的内容会被打包到一个css文件中。</p>
<p>同时可以使用optimize-css-assets-webpack-plugin是打包后的css代码压缩。</p>
<blockquote>
<p>npm install optimize-css-assets-webpack-plugin -D</p>
</blockquote>
<p>同时在webpack.prod.js中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>再打包，代码就会被压缩和合并。</p>
<p>css代码分割也要依靠：splitChunks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      styles: &#123;</span><br><span class="line">        name: &apos;styles&apos;,  </span><br><span class="line">        test: /\.css$/, //.css文件</span><br><span class="line">        chunks: &apos;all&apos;, //所有的包</span><br><span class="line">        enforce: true, //排除其余所有判断，只要是.css就可以</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>以上代码的含义是，当存在多个入口文件时，将所有的css代码都打包到一个css文件（styles）中。</p>
<p>除此之外还可以根据入口的不同，将css文件打包到不同的css文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        fooStyles: &#123;</span><br><span class="line">          name: &apos;foo&apos;, //2.打包到foo.css中</span><br><span class="line">          test: (m, c, entry = &apos;foo&apos;) =&gt;  // 1.入口文件为foo</span><br><span class="line">            m.constructor.name === &apos;CssModule&apos; &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">          chunks: &apos;all&apos;,</span><br><span class="line">          enforce: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        barStyles: &#123;</span><br><span class="line">        // 入口为bar打包到bar.css中</span><br><span class="line">          name: &apos;bar&apos;,</span><br><span class="line">          test: (m, c, entry = &apos;bar&apos;) =&gt;</span><br><span class="line">            m.constructor.name === &apos;CssModule&apos; &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">          chunks: &apos;all&apos;,</span><br><span class="line">          enforce: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="webpack-与浏览器缓存-caching"><a href="#webpack-与浏览器缓存-caching" class="headerlink" title="webpack 与浏览器缓存(caching)"></a>webpack 与浏览器缓存(caching)</h3><p>index.js中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import _ from &apos;lodash&apos;;</span><br><span class="line">import $ from &apos;jquery&apos;;</span><br><span class="line"></span><br><span class="line">const dom = $(&apos;div&apos;);</span><br><span class="line">dom.html(_.join([&apos;hello&apos;,&apos;jerry&apos;],&apos; &apos;))</span><br><span class="line">$(body).append(dom);</span><br></pre></td></tr></table></figure>

<p>打包后生成main.js文件，和vendor~main.js文件（里边是lodash和jQuery）。</p>
<p>当我们打包上线的时候，会将两个文件传到服务器上。当用户第一次打开网页时，会加载两个js文件，但是当刷新页面的时候，会直接使用浏览器的缓存，而不去重新加载。</p>
<p>这样会存在问题：当我们改变代码重新上传的时候，依旧是这两个文件，浏览器会从缓存读取（请求文件时发现本地已经有缓存，就不会重新请求）。</p>
<p>解决：</p>
<p>webpack.dev.config:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">    chunkFilename:&apos;[name].chunk.js&apos;,</span><br><span class="line">    &lt;!--path: path.resolve(__dirname, &apos;../dist&apos;)--&gt;  //在common.js中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.prod.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[contenthash].js&apos;,  //打包后输出文件名称</span><br><span class="line">    chunkFilename:&apos;[name].[contenthash].chunk.js&apos;,</span><br><span class="line">    &lt;!--path: path.resolve(__dirname, &apos;../dist&apos;)--&gt; //在common.js中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次打包的时候会发现，打包后文件带有hash值，改变代码后hash值会改变，当用户刷新页面时，文件名发生改变（main会变，vendors不会改变（里边是lodash和jQuery）），会重新请求加载文件。</p>
<p>contenthash：是浏览器每次都请求修改过的文件，没有修改的使用本地缓存。</p>
<p>老版本的webpack中存在问题：即使不修改代码，两次的hash值可能也是不一样的，需要配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">    runtimeChunk:&#123;</span><br><span class="line">        name:&apos;runtime&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后会生成一个runtime.js。原因是main.js和vender.js之间存在引用关系，这个引用关系在两个文件夹中都存在，当打包时，即使代码没有改变，存在的对应关系可能会变，这就是为什么旧版webpack中，即使代码没有改变hash值也可能不同。当配置完成后会生成runtime.js文件，将对应关系存储进去，这也就解决了旧版webpack中存在的问题。</p>
<h3 id="shimming"><a href="#shimming" class="headerlink" title="shimming"></a>shimming</h3><p>当我们用了比较老的模块，模块中使用了第三方库，但是没有用ES module方法引入，则会导致报错，这时候需要webpac自带的一个插件<br>webpack.common.js 设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">    $:&apos;jquery&apos;,</span><br><span class="line">    _:&apos;loadsh&apos;,</span><br><span class="line">    _join:[&apos;loadsh&apos;,&apos;join&apos;] //_join = loadsh.join</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>就不会再报错，这段代码遇到 $ 时，发现没有引入jQuery ，就会自动帮我们引入jQuery。<br>当然还可以配置其他。</p>
<p>每个模块中的this都是指向本模块，而不是指向Window，如果想让模块中this指向window需要借助插件：imports-loader</p>
<blockquote>
<p>npm install imports-loader -D</p>
</blockquote>
<p>之后到webpack.common.js中配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">    use:[&#123;</span><br><span class="line">            loader:&quot;babel-loader&quot;                    </span><br><span class="line">       &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: &quot;imports-loader?this=&gt;window&quot;, </span><br><span class="line">        &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>碰到js代码时，先将this指向全局window，然后使用 babel将ES6转换为ES5。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>之前我们是通过webpack.common.js, webpack.dev.js, webpack.prod.js来控制不同环境下打包方式，我么可以做如下变更：<br>webpack.prod.js只导出prodConfig，webpack.dev.js只导出devConfig，统一到common.js中去做融合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">// *********************************</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const devConfig = require(&apos;./webpack.dev&apos;)</span><br><span class="line">const prodConfig = require(&apos;./webpack.prod&apos;)</span><br><span class="line">// *********************************</span><br><span class="line"></span><br><span class="line">const commonConfig = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/caching/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;../dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// *********************************</span><br><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env &amp;&amp; env.production)&#123;  //判断是否有env否则环境变量下打包会报错</span><br><span class="line">        // 线上环境</span><br><span class="line">        console.log(env.production)</span><br><span class="line">        return merge(commonConfig,prodConfig)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        // 开发环境</span><br><span class="line">        return merge(commonConfig,devConfig)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// *********************************</span><br></pre></td></tr></table></figure>

<p>同时package.json配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build-dev&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.common.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//  --env.production  传递环境变量production为true</span><br><span class="line">//  --env.production==abc  传递环境变量production为&apos;abc&apos;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/webpack-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/webpack-基础/" itemprop="url">webpack-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T15:12:19+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>创建index.html文件去编写基本的网页内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;这是网页内容&lt;/p&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>通过index.js 添加header,sidebar,content 三个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(&apos;root&apos;);</span><br><span class="line"></span><br><span class="line">var header = document.createElement(&apos;div&apos;);</span><br><span class="line">header.innerText = &apos;Header&apos;;</span><br><span class="line">dom.append(header);</span><br><span class="line"></span><br><span class="line">var sidebar = document.createElement(&apos;div&apos;);</span><br><span class="line">sidebar.innerText = &apos;sidebar&apos;;</span><br><span class="line">dom.append(sidebar);</span><br><span class="line"></span><br><span class="line">var content = document.createElement(&apos;div&apos;);</span><br><span class="line">content.innerText = &apos;content&apos;;</span><br><span class="line">dom.append(content);</span><br></pre></td></tr></table></figure>

<p>上述过程叫做面向过程的编程方式，这种方式存在很大的问题，当我们把逻辑代码全部存放到一个js文件中，个文件会越来越大，最后难以维护。</p>
<p>所以产生了一种新的编程方式：面向对象的编程方式</p>
<p>页面存在三个部分：header,sidebar,content，我们分别为他们创建对象，去完成各自的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//sidebar.js</span><br><span class="line">function Sidebar()&#123;</span><br><span class="line">    var sidebar = document.createElement(&apos;div&apos;);</span><br><span class="line">    sidebar.innerText = &apos;sidebar&apos;;</span><br><span class="line">    dom.append(sidebar);</span><br><span class="line">&#125;</span><br><span class="line">// content.js</span><br><span class="line">function Content()&#123;</span><br><span class="line">    var content = document.createElement(&apos;div&apos;);</span><br><span class="line">    content.innerText = &apos;content&apos;;</span><br><span class="line">    dom.append(content);</span><br><span class="line">&#125;</span><br><span class="line">//header.js</span><br><span class="line">function Header()&#123;</span><br><span class="line">    var header = document.createElement(&apos;div&apos;);</span><br><span class="line">    header.innerText = &apos;Header&apos;;</span><br><span class="line">    dom.append(header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在index.js中完成业务逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(&apos;root&apos;);</span><br><span class="line"></span><br><span class="line">new Header();</span><br><span class="line">new Sidebar();</span><br><span class="line">new Content();</span><br></pre></td></tr></table></figure>

<p>当然，我们需要在index.html中引入js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;这是网页内容&lt;/p&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./header.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./content.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./sidebar.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>面向对象使代码可维护性比较方便</p>
<p>面向对象的编程方式又引入新的问题：</p>
<ul>
<li>inde.html中引入文件较多，页面加载速度变慢（多出了三个http请求）；</li>
<li>在index.js中，只能看到创建了三部分，并不能看到文件相对位置；</li>
<li>很难查错</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./header.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./content.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">//&lt;script src=&quot;./sidebar.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./sidebar.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>会报错 Sidebar is not defined （指向index.js中）我们并不会想到是index.html引入顺序出错了。</p>
<p>为了解决上边的问题，我们又想到了另一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import Header from &apos;./header&apos;;</span><br><span class="line">import Sidebar from &apos;./sidebar&apos;;</span><br><span class="line">import Content from &apos;./content&apos;;</span><br><span class="line"></span><br><span class="line">&lt;!--var dom = document.getElementById(&apos;root&apos;);--&gt;</span><br><span class="line"></span><br><span class="line">new Header();</span><br><span class="line">new Sidebar();</span><br><span class="line">new Content();</span><br><span class="line"></span><br><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;这是网页内容&lt;/p&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>当然要引出模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Header()&#123;</span><br><span class="line">    var dom = document.getElementById(&apos;root&apos;);</span><br><span class="line">    var header = document.createElement(&apos;div&apos;);</span><br><span class="line">    header.innerText = &apos;Header&apos;;</span><br><span class="line">    dom.append(header);</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>

<p>轻松解决上边的三个问题。但是编译之后会在import部分报错，原因是浏览器并不能识别import语句，这时候webpack就登场了：webpack会对代码做一次翻译使浏览器能识别这段代码，但是webpack并不是js翻译器，因为他只认识import这样引入模块的语句，并不能识别高级语法。</p>
<p>准确的来说webpack是模块打包工具。webpack不仅可以识别ES module模块引入方式还能识别Common JS、CMD、AMD等模块引入规范。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//ES module</span><br><span class="line">import a from &apos;b.js&apos;</span><br><span class="line">export default xxx;</span><br><span class="line"></span><br><span class="line">//Common JS</span><br><span class="line">const a = require(&apos;b.js&apos;);</span><br><span class="line">module.exports = xxx;</span><br></pre></td></tr></table></figure>

<h3 id="webpack-环境搭建"><a href="#webpack-环境搭建" class="headerlink" title="webpack 环境搭建"></a>webpack 环境搭建</h3><p>需要有node环境，选择目前来说稳定的最新版本，打包速度较快。</p>
<p>首先初始化一个符合node规范的项目：</p>
<blockquote>
<p>npm init</p>
</blockquote>
<p>会产生一个package.json文件</p>
<p>接下来就是安装webpack，有两种方式</p>
<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><blockquote>
<p>npm install webpack webpack-cli -g</p>
</blockquote>
<p>不是十分推荐全局安装，如果全局的webpack是4.0版本的，而有一个项目是webpack3.0配置的。那这个项目就跑不起来。解决的办法是卸掉4.0版本的webpack去安装3.0版本的。但是如果两个项目之间存在依赖关系，但是使用的webpack版本还不同，那就没有办法解决了。所以比较提倡在项目内安装webpack。</p>
<h4 id="项目内安装"><a href="#项目内安装" class="headerlink" title="项目内安装"></a>项目内安装</h4><blockquote>
<p>npm install webpack webpack-cli –save -dev</p>
</blockquote>
<p>可以通过</p>
<blockquote>
<p>npm install <a href="mailto:webpack@4.0" target="_blank" rel="noopener">webpack@4.0</a> webpack-cli –save -dev</p>
</blockquote>
<p>来指定安装4.0版本的webpack。</p>
<p>此时若想验证是否安装成功，</p>
<blockquote>
<p>webpack -v</p>
</blockquote>
<p>不会出现版本号，原因是，会去全局查找webpack，但是并没有安装在全局，可以执行</p>
<blockquote>
<p>npx webpack -v</p>
</blockquote>
<p>来查看项目内webpack版本号。这样不同的项目可以使用不同版本webpack并且互不影响。</p>
<p>我们来尝试打包我们之前写的代码：</p>
<blockquote>
<p>npx webpack index.js</p>
</blockquote>
<p>我们会发现，目录下出现了dist文件夹，下边有一个main.js文件，就是webpack打包之后的文件，我们将这个文件引入到index.html中就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;这是网页内容&lt;/p&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>网页就会正常显示了。</p>
<h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3><p>创建webpack.config.js文件来配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry:&apos;./index.js&apos;,  //打包入口文件</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 整体含义是：从index.js文件开始打包，打包好的文件命名为boundle.js，将boundle.js文件保存在当前目录下的dist文件夹中。</span><br><span class="line">// 当前目录指的是配置文件的根目录，如果想输出到配置文件父级目录下应设置为：path: path.resolve(__dirname, &apos;../dist&apos;)</span><br></pre></td></tr></table></figure>

<p>配置好之后，执行：</p>
<blockquote>
<p>npx webpack</p>
</blockquote>
<p>就可以自动打包，不需要指定index.js文件了。如果没有配置入口文件，不指定index.js是会报错的。</p>
<p>注意：webpack.config.js文件是默认的配置文件，如果我们将他改名为b.js,打包时需执行：</p>
<blockquote>
<p>npx webpack –config b.js</p>
</blockquote>
<p>意思是以b.js为配置文件打包。</p>
<p>打包成功后，我们会发现出现警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING in configuration</span><br><span class="line">The &apos;mode&apos; option has not been set, webpack will fallback to &apos;production&apos; for this value. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for each environment.</span><br><span class="line">You can also set it to &apos;none&apos; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/</span><br></pre></td></tr></table></figure>

<p>当我们将配置文件改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;, </span><br><span class="line">    entry:&apos;./src/index.js&apos;,  //打包入口文件</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就不会再报错。我们看到其中增加了mode这一项，mode有两个可选值production（压缩，默认）和development（不压缩），打开打包好的文件可以看到，代码压缩到一行时为production。</p>
<p>但是在实际项目中，我们并没有通过npx去打包文件，一般都是npm。这也是可以配置的。打开package.json文件，设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;boundle&quot;:&quot;webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>接下来执行：</p>
<blockquote>
<p>npm run boundle </p>
</blockquote>
<p>即可完成打包。</p>
<p>总结：</p>
<ul>
<li>全局下使用 webpack index.js 命令打包。</li>
<li>项目内使用 npx webpack index.js 命令打包。</li>
<li>配置后使用 npm run boundle 命令打包。</li>
</ul>
<p>上述三种方法，归根结底是使用webpack进行打包的，而之前安装的webpack-cli 就是为了保证在命令行可以使用webpack。</p>
<p>打包后输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hash: 6d03458734bde1af0573（哈希值）</span><br><span class="line">Version: webpack 4.43.0（webpack版本号）</span><br><span class="line">Time: 150ms（打包用时）</span><br><span class="line">Built at: 2020-05-03 21:00:06</span><br><span class="line">     Asset（打包后的文件）      Size  Chunks （打包出的文件及相关文件ID） Chunk Names（打包出的文件及相关文件name）</span><br><span class="line">boundle.js                  1.29 KiB       0  [emitted]                 main</span><br><span class="line">Entrypoint main = boundle.js</span><br><span class="line">[0] ./src/index.js + 3 modules 761 bytes &#123;0&#125; [built]</span><br><span class="line">    | ./src/index.js 147 bytes [built]</span><br><span class="line">    | ./src/header.js 200 bytes [built]</span><br><span class="line">    | ./src/sidebar.js 208 bytes [built]</span><br><span class="line">    | ./src/content.js 206 bytes [built]</span><br></pre></td></tr></table></figure>

<h2 id="webpack核心"><a href="#webpack核心" class="headerlink" title="webpack核心"></a>webpack核心</h2><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><h4 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h4><p>loader是一种打包方案，作用就是使webpack可以识别别的类型的文件（图片文件或者css文件等）。</p>
<h4 id="打包图片文件"><a href="#打包图片文件" class="headerlink" title="打包图片文件"></a>打包图片文件</h4><p>前边说的都是对js文件的打包，接下来看看对图片文件的打包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const img = require(&apos;./img.png&apos;);</span><br><span class="line">console.log(img);</span><br></pre></td></tr></table></figure>

<p>直接打包会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You may need an appropriate loader to handle this file type</span><br></pre></td></tr></table></figure>

<p>下载<a href="https://www.webpackjs.com/loaders/file-loader/" target="_blank" rel="noopener">file-loader</a>去处理相应文件:</p>
<blockquote>
<p>npm install file-loader -D</p>
</blockquote>
<p>去webpack.config.js中配置file-loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(png|jpg|gif)$/,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:&quot;file-loader&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后再打包就好了。我们知道webpack可以打包任何形式的文件，但是webpack不识别非js文件，除了js以外的文件都是通过loader实现的。以上代码的含义是，当webpack不知道如何打包的时候，就去配置文件的module下查看相应规则，当文件是以png或者jpg或者gif结尾时，就用file-loader去处理它。</p>
<p>file-loader一共做了两件事：</p>
<ul>
<li>文件移动到dist。（打包后输出的文件夹下多了一个图片文件）</li>
<li>将文件名返回给变量（img）</li>
</ul>
<p>当我们写Vue项目的时候，常常会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import xxx from &apos;xxx.vue&apos;</span><br></pre></td></tr></table></figure>

<p>这时候用到的loader是vue-loader(vue官网上可看)。</p>
<h5 id="控制打包后图片文件名和存储位置"><a href="#控制打包后图片文件名和存储位置" class="headerlink" title="控制打包后图片文件名和存储位置"></a>控制打包后图片文件名和存储位置</h5><p>在options中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&apos;./src/index.js&apos;,  //打包入口文件</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(png|jpg|gif)$/,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:&quot;file-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name :&apos;[name].[ext]&apos;,  //输出文件名称为源文件名称，扩展名为源文件扩展名</span><br><span class="line">                        outputPath:&apos;images&apos; //打包后输出到dist/images下</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官网上关于file-loader的占位符还有很多，可以<a href="https://www.webpackjs.com/loaders/file-loader/#placeholders" target="_blank" rel="noopener">自行查阅</a>。</p>
<p>当然所有loader使用前都要下载</p>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a><a href="https://www.webpackjs.com/loaders/url-loader/" target="_blank" rel="noopener">url-loader</a></h5><p>url-loader 可以实现所有file-loader的功能，但是存在着差异。url-loader并不会把图片保存到单独文件中，而是会将图片以base64的形式放到打包后的js文件中，其实这样处理并不是很好。当图片很大的时候，会使js文件很大，加载速度会很慢。我们可以通过以下设置来改善：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&apos;./src/index.js&apos;,  //打包入口文件</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(png|jpg|gif)$/,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:&quot;url-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name :&apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath:&apos;images&apos;,</span><br><span class="line">                        limit:102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当图片大于102400字节时，就会和file-loader作同样处理（保存到单独文件中），当图片小于102400字节时就会以base64的形式保存到js文件中。</p>
<h4 id="处理css文件"><a href="#处理css文件" class="headerlink" title="处理css文件"></a>处理css文件</h4><p><code>style-loader + css-loader</code></p>
<p>在index.css设置图片样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.avatar&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js 中引入文件并将其添加到页面中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import avatar from &apos;./avatar.jpg&apos;</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line"></span><br><span class="line">var img = new Image();</span><br><span class="line">img.src = avatar;</span><br><span class="line">img.classList.add(&quot;avatar&quot;);</span><br><span class="line"></span><br><span class="line">var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">root.append(img);</span><br></pre></td></tr></table></figure>

<p>最后配置webpack</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(png|jpg|gif)$/,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:&quot;url-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name :&apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath:&apos;images&apos;,</span><br><span class="line">                        limit:102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.css$/,</span><br><span class="line">                use:[&quot;style-loader&quot;,&quot;css-loader&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后打包（记得先下载loader再打包哦）。看网页，会发现图片样式改变。</p>
<p>接下来我们变复杂一些：</p>
<p>新建avatar.css将样式代码写到其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.avatar&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;./avatar.css&apos;</span><br></pre></td></tr></table></figure>

<p>逻辑为：index.js引用index.css，index.css引用avatar.css。</p>
<p>重新打包后效果相同。在这个过程中，css-loader负责分析各个文件之间的关系，将不同文件的代码生成一个代码块。style-loader负责将css-loader生成的代码块挂载到head中。所以loader使用顺序是从右向左，从下向上。</p>
<h4 id="处理sass文件"><a href="#处理sass文件" class="headerlink" title="处理sass文件"></a>处理sass文件</h4><p><code>style-loader + css-loader + sass-loader</code></p>
<p>将index.scss编写为(scss)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    .avatar&#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js引入index.scss:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import avatar from &apos;./avatar.jpg&apos;</span><br><span class="line">import &apos;./index.scss&apos;</span><br><span class="line"></span><br><span class="line">var img = new Image();</span><br><span class="line">img.src = avatar;</span><br><span class="line">img.classList.add(&quot;avatar&quot;);</span><br><span class="line"></span><br><span class="line">var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">root.append(img);</span><br></pre></td></tr></table></figure>

<p>打包后发现样式没有改变，head部分依旧是sass语法，所以需要借助sass-loader将sass语法转化为css语法，sass-loader安装时还要同时安装 node-sass才可以使用(注意是sass)</p>
<blockquote>
<p>npm install sass-loader node-sass -D</p>
</blockquote>
<p>webpack 配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    entry:&apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.(png|jpg|gif)$/,</span><br><span class="line">                use:&#123;</span><br><span class="line">                    loader:&quot;url-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name :&apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath:&apos;images&apos;,</span><br><span class="line">                        limit:102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.scss$/,</span><br><span class="line">                use:[&quot;style-loader&quot;,&quot;css-loader&quot;,&quot;sass-loader&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致经过：</p>
<ul>
<li>sass将scss语法翻译为css语法</li>
<li>css将代码合并</li>
<li>style将css挂载到head</li>
</ul>
<p>有时候会需要像素偏移，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    .avatar&#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        transform: translate(100px,100px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后实偏移，但是我们发现样式并没有添加厂商前缀：</p>
<p>CSS3 在不断的推出一些新属性来满足新样式的要求，当 CSS3 刚刚推出新属性时，这些新的属性处于不太稳定的阶段，随时可能因为各种原因而被剔除。这时浏览器厂商如果想要运用这些新属性，就可以采用前缀方法来实现。<br>当推出的这些新属性被各大主流浏览器稳定支持并成为了标准，就可以不再添加浏览器的厂商前缀。</p>
<p><img src="https://s1.ax1x.com/2020/05/04/Y9dg5n.png" alt="image"></p>
<p><a href="https://www.webpackjs.com/loaders/postcss-loader/" target="_blank" rel="noopener">postcss-loader</a>会帮我们自动添加厂商前缀。</p>
<p>postcss-loader要创建postcss.config.js文件配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        require(&apos;autoprefixer&apos;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们要用到autoprefixer插件，所以要下载postcss-loader和autoprefixer插件。</p>
<p>当然还要在webpack.config.js中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    entry: &apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就自动添加了厂商前缀。</p>
<h4 id="css-loader-配置"><a href="#css-loader-配置" class="headerlink" title="css-loader 配置"></a>css-loader 配置</h4><p>有时候可能存在这种情况：index.js引入了index.scss，index.scss引入了其他scss文件，webpack配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    entry: &apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对index.js引用的文件肯定会由下向上依次执行loader，但是对index.scss文件引用的scss文件就可能直接执行css-loader和style-loader ，进行如下配置可以保证每次都依次执行所有loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            importLoaders: 2,  //保证每次依次执行</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="css打包的模块化（css-modules）"><a href="#css打包的模块化（css-modules）" class="headerlink" title="css打包的模块化（css-modules）"></a>css打包的模块化（css-modules）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import avatar from &apos;./avatar.jpg&apos;</span><br><span class="line">import &apos;./index.scss&apos;</span><br><span class="line">import createAvatar from &apos;./avatar.js&apos;</span><br><span class="line"></span><br><span class="line">createAvatar();</span><br><span class="line"></span><br><span class="line">var img = new Image();</span><br><span class="line">img.src = avatar;</span><br><span class="line">img.classList.add(&quot;avatar&quot;);</span><br><span class="line"></span><br><span class="line">var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">root.append(img);</span><br><span class="line"></span><br><span class="line">// avatar.js</span><br><span class="line">import avatar from &apos;./avatar.jpg&apos;</span><br><span class="line">function createAvatar()&#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = avatar;</span><br><span class="line">    img.classList.add(&quot;avatar&quot;);</span><br><span class="line"></span><br><span class="line">    var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">    root.append(img);</span><br><span class="line">&#125;</span><br><span class="line">export default createAvatar;</span><br></pre></td></tr></table></figure>

<p>打包后会发现网页上出现两个一摸一样的的图片，这说明index.scss中的样式不仅对index.js中的样式生效，而且对createAvatar()生效，但是在avatar.js中并没有引入index.scss。这说明这种index.scss的引入方式是全局的。这样的缺点在于如果你想改变一个的样式，另一个也会改变，css模块化就是使css仅在当前模块有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import avatar from &apos;./avatar.jpg&apos;</span><br><span class="line">import style from &apos;./index.scss&apos;  //!!!!</span><br><span class="line">import createAvatar from &apos;./avatar.js&apos;</span><br><span class="line"></span><br><span class="line">createAvatar();</span><br><span class="line"></span><br><span class="line">var img = new Image();</span><br><span class="line">img.src = avatar;</span><br><span class="line">img.classList.add(style.avatar); //!!!!</span><br><span class="line"></span><br><span class="line">var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">root.append(img);</span><br></pre></td></tr></table></figure>

<p>在webpack中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    entry: &apos;./src/static/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader:&quot;css-loader&quot;,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            importLoaders:2,</span><br><span class="line">                            modules:true   //!!!!!!!!!打开模块化打包方式</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundle.js&apos;,  </span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就会看到两张不同样式的图片。别的文件想要使用这个样式需要重新引入。</p>
<h4 id="字体打包"><a href="#字体打包" class="headerlink" title="字体打包"></a><a href="https://www.webpackjs.com/guides/asset-management/#%E5%8A%A0%E8%BD%BD%E5%AD%97%E4%BD%93" target="_blank" rel="noopener">字体打包</a></h4><p>先去iconfont找到图标，添加到项目，之后下载到本地会有一系列文件。将字体文件复制到项目font目录下，将iconfont.css复制到index.css,里边对字体文件的引入路径要修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 修改前：（对应四个字体文件）</span><br><span class="line">@font-face &#123;font-family: &quot;iconfont&quot;;</span><br><span class="line">    src: url(&apos;iconfont.eot?t=1588568351173&apos;); /* IE9 */</span><br><span class="line">    src: url(&apos;iconfont.eot?t=1588568351173#iefix&apos;) </span><br><span class="line">    ···</span><br><span class="line">    url(&apos;iconfont.woff?t=1588568351173&apos;) format(&apos;woff&apos;),</span><br><span class="line">    url(&apos;iconfont.ttf?t=1588568351173&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */</span><br><span class="line">    url(&apos;iconfont.svg?t=1588568351173#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ···</span><br><span class="line">   </span><br><span class="line">  .icon-auto:before &#123;</span><br><span class="line">    content: &quot;\e6eb&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .icon-all:before &#123;</span><br><span class="line">    content: &quot;\e6ef&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 修改后：</span><br><span class="line">  @font-face &#123;font-family: &quot;iconfont&quot;;</span><br><span class="line">    src: url(&apos;./font/iconfont.eot?t=1588568351173&apos;); /* IE9 */</span><br><span class="line">    src: url(&apos;./font/iconfont.eot?t=1588568351173#iefix&apos;) </span><br><span class="line">    ···</span><br><span class="line">    url(&apos;./font/iconfont.woff?t=1588568351173&apos;) format(&apos;woff&apos;),</span><br><span class="line">    url(&apos;./font/iconfont.ttf?t=1588568351173&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */</span><br><span class="line">    url(&apos;./font/iconfont.svg?t=1588568351173#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">  .icon-auto:before &#123;</span><br><span class="line">    content: &quot;\e6eb&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .icon-all:before &#123;</span><br><span class="line">    content: &quot;\e6ef&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line"></span><br><span class="line">var root = document.getElementById(&apos;root&apos;);</span><br><span class="line">root.innerHTML = &apos;&lt;div class=&quot;iconfont icon-auto&quot;&gt;&lt;/div&gt;&apos;</span><br></pre></td></tr></table></figure>

<p>index.css中有eot,svg,ttf,woff文件，所以在webpack中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    entry: &apos;./src/fonts/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;url-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images&apos;,</span><br><span class="line">                        limit: 102400,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader:&quot;css-loader&quot;,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            importLoaders:2,</span><br><span class="line">                            // modules:true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;,</span><br><span class="line">                    &quot;postcss-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            // !!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(svg|ttf|woff|eot)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;file-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符</span><br><span class="line">                        name: &apos;[name].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;fonts&apos;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就会显示相应字体或者图标了。</p>
<p>学习至此应该可以看懂<a href="https://www.webpackjs.com/guides/asset-management/" target="_blank" rel="noopener">官网的这一部分</a></p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><h4 id="plugins是什么"><a href="#plugins是什么" class="headerlink" title="plugins是什么"></a>plugins是什么</h4><p>plugins可以在特定的时刻为你做某些事。</p>
<h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a><a href="https://www.webpackjs.com/plugins/html-webpack-plugin/" target="_blank" rel="noopener">html-webpack-plugin</a></h4><p>安装后webpack配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &apos;./src/fonts/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">    rules:[]</span><br><span class="line">    // !!!!!</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:&apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundle.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>plugin使用前要引入，HtmlWebpackPlugin的作用是当打包完成时，以src/fonts/index.html文件为模板，生成index.html文件，并将打包好的js文件注入到里边。</p>
<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a><a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a></h4><p>不是官网plugin，是第三方plugin。</p>
<blockquote>
<p>npm install clean-webpack-plugin -D</p>
</blockquote>
<p>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &apos;./src/fonts/index.js&apos;,  //打包入口文件</span><br><span class="line">    module: &#123;</span><br><span class="line">       </span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:&apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;), </span><br><span class="line">        // 记得引入</span><br><span class="line">        new CleanWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundles.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clean-webpack-plugin的作用是在打包之前删除output.path下的所有内容之后再进行打包。所以不用传递参数。</p>
<h4 id="entry和output"><a href="#entry和output" class="headerlink" title="entry和output"></a>entry和output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/fonts/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;boundles.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出文件名称为boundle.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/fonts/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        // filename: &apos;boundles.js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出文件名为main.js。这就可以看出，entry对象配置方式的含义。</p>
<p>如果想打包两次，两次分别输出不同文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/fonts/index.js&apos;,</span><br><span class="line">        sub:&apos;./src/fonts/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倘若使用html-webpack-plugin，那这两个文件都会被添加到生成的HTML文件中。</p>
<p>还有另一种场景，将静态文件放到cdn上，打包后的HTML文件给后端作为入口，我们希望在生成的HTML文档对js文件的引用前面加上cdn路径，需要在output配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">       filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">       path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">       publicPath:&apos;http://cdn.com.cn&apos;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到生成的HTML对js的引用为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://cdn.com.cn/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://cdn.com.cn/sub.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.webpackjs.com/guides/output-management/" target="_blank" rel="noopener">仔细阅读</a></p>
<h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h4><p>当我们写代码的时候，写错是难免的，浏览器会自动提示我们在代码的哪一行出了错便于我们检错。如果没有source-map，那么浏览器提示的是打包后文件出错的位置，开启source-map后提示的是我们在自己编写的代码出错的位置。</p>
<p>source-map的是一种映射关系，例如：知道main.js96行实际上对应的是index.js第一行。</p>
<p>在mode为development的情况下，默认使用source-map，当mode为production时，配置devtool不起作用。</p>
<p>使用devtool配置source-map有<a href="https://webpack.js.org/configuration/devtool/#devtool" target="_blank" rel="noopener">很多种不同的配置方式</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devtool:&apos;source-map&apos; //打包后文件加下会产生main.js.map文件，存放一一对应关系</span><br><span class="line"></span><br><span class="line">devtool:&apos;inline-source-map&apos; //将一一对应关系直接存放到打包后的js文件中，不再产生单独文件</span><br><span class="line"></span><br><span class="line">devtool:&apos;cheap-inline-source-map&apos; //只将错误精确到行，不加cheap精确到哪行哪里列，不加比较耗费性能。</span><br><span class="line">// 除此之外，cheap只管自己业务代码与打包后文件之间的映射关系，只管业务代码出错</span><br><span class="line"></span><br><span class="line">devtool:&apos;cheap-module-inline-source-map&apos; //不仅管业务代码出错，还管别的模块代码（loader）的映射</span><br><span class="line"></span><br><span class="line">devtool：&apos;eval&apos; //最快的打包方式，通过eval在打包后文件中来形成映射关系，不再是base64</span><br></pre></td></tr></table></figure>

<p>复杂代码中eval提示不全面，实践中最好的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mode:&apos;development&apos;,</span><br><span class="line">devtool:&apos;cheap-module-eval-source-map&apos;</span><br></pre></td></tr></table></figure>

<p>线上：以便线上代码出问题时做映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mode:&apos;production&apos;,</span><br><span class="line">devtool:&apos;cheap-module-souce-map&apos;</span><br></pre></td></tr></table></figure>

<p>==面试考点：source-map原理==</p>
<h4 id="webpackDevServer提升开发效率"><a href="#webpackDevServer提升开发效率" class="headerlink" title="webpackDevServer提升开发效率"></a>webpackDevServer提升开发效率</h4><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><p>监听打包文件变化，变化自动打包，不需要重复 npm run boundle,但是要重复刷新网页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;webpack --watch&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>安装：</p>
<blockquote>
<p>npm install webpack-dev-server -D</p>
</blockquote>
<p>webpack配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    devtool:&apos;cheap-module-eval-source-map&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/sourceMap/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:&apos;./dist&apos; //借助devServer生成服务器放到dist目录下</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;), new CleanWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  //打包后输出文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;watch&quot;: &quot;webpack --watch&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>之后 npm run start.访问提示的网址，每次修改自动更新不必手动刷新网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    contentBase:&apos;./dist&apos; //借助devServer生成服务器放到dist目录下</span><br><span class="line">    open:true  //可以自动打开网址不必手动打开</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>借助devServer开启服务器的目的：可以进行ajax请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    contentBase:&apos;./dist&apos; //借助devServer生成服务器放到dist目录下</span><br><span class="line">    open:true  //可以自动打开网址不必手动打开</span><br><span class="line">    proxy:&#123;</span><br><span class="line">    // 用户访问http://loaclhost:8000/api时，自动转发到http://localhost:3000</span><br><span class="line">        &apos;/api&apos;:&apos;http://localhost:3000&apos; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>Vue和react中可以使用跨域，原因就是使用了devServe。devServer本身支持这种代理。</p>
<p>使用devServer并不会发现dist文件中有东西，那是因为打包后的文件放到了内存中，这样可以提升速度。</p>
<p><a href="https://www.webpackjs.com/guides/development/" target="_blank" rel="noopener">阅读</a></p>
<h4 id="Hot-Module-Replacement-热模块更新（HMR）"><a href="#Hot-Module-Replacement-热模块更新（HMR）" class="headerlink" title="Hot Module Replacement 热模块更新（HMR）"></a>Hot Module Replacement 热模块更新（HMR）</h4><p>有时候我们仅仅改变样式代码，浏览器就会重新加载整个文件，之前做的处理（比如动态添加的节点）都会消失不见，这时候我们希望当css文件更新时只改变样式，不改变之前js渲染出来的内容。这时候就需要开启HMR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: &apos;./src/HMR/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &apos;./dist&apos;,</span><br><span class="line">        open:true,</span><br><span class="line">        </span><br><span class="line">        // 开启HMR</span><br><span class="line">        hot:true,</span><br><span class="line">        hotOnly:true,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;src/fonts/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        </span><br><span class="line">        // 使用webpack原生插件，开头引入webpack</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].js&apos;,  </span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当修改页面样式时，之前渲染的js不会消失。这样也方便css的调试。</p>
<p>接下来看看HMR在js中的应用：</p>
<p>设计两个模块，counter.js实现点击累加计数，number.js只是显示数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// counter.js</span><br><span class="line">var counter = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.setAttribute(&apos;id&apos;,&apos;counter&apos;) </span><br><span class="line">    div.innerHTML = 1;</span><br><span class="line">    div.onclick = function()&#123;</span><br><span class="line">        div.innerHTML = parseInt(div.innerHTML,10)+1; </span><br><span class="line">    &#125;;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default counter;</span><br><span class="line"></span><br><span class="line">// number.js</span><br><span class="line">var number = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.setAttribute(&apos;id&apos;,&apos;number&apos;) </span><br><span class="line">    div.innerHTML = 2000;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default number;</span><br><span class="line"></span><br><span class="line">// index.js实现对两个模块的引用</span><br><span class="line">import counter from &apos;./counter&apos;;</span><br><span class="line">import number from &apos;./number&apos;</span><br><span class="line">counter()</span><br><span class="line">number()</span><br></pre></td></tr></table></figure>

<p>当我们不开启HMR时，会发现当点击计数counter中的值累计为15时去改变number的值，返回网页，counter中的值回归1，也就是说number模块的改变影响了counter模块。要使number的改变不影响counter，首先要去config中打开HMR，其次在index.js中编写逻辑代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import counter from &apos;./counter&apos;;</span><br><span class="line">import number from &apos;./number&apos;</span><br><span class="line">counter()</span><br><span class="line">number();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(module.hot)&#123; //判断是否开启HMR</span><br><span class="line">    module.hot.accept(&apos;./number.js&apos;,function()&#123; //监听number.js文件变化，若变化，则执行以下代码</span><br><span class="line">        var node = document.getElementById(&quot;number&quot;);</span><br><span class="line">            document.body.removeChild(node);</span><br><span class="line">            number();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不设置hotOnly,当不写逻辑判断时，会自动刷新页面。</p>
<p>在上边css中，并没有写逻辑代码，那是因为css-loader已经做了处理。</p>
<h3 id="Babel-处理ES6语法"><a href="#Babel-处理ES6语法" class="headerlink" title="Babel 处理ES6语法"></a>Babel 处理ES6语法</h3><p>在index.js中编写ES6语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [</span><br><span class="line">    new Promise(()=&gt;&#123;&#125;),</span><br><span class="line">    new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">arr.map(item =&gt; &#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行npx webpack，然后去打包后的main.js 文件夹下最后可以找到打包后的index.js代码，可以看到打包后的代码仍旧是ES6语法，在有的浏览器（比如谷歌）中可以兼容ES6语法，但是在较低版本的IE浏览器中，则不会兼容ES6，需要将他转换为ES5的语法。这时候Babel就上场了。</p>
<p><a href="https://www.babeljs.cn/setup#installation" target="_blank" rel="noopener">Babel官网上有详尽的教程</a></p>
<blockquote>
<p>npm install –save-dev babel-loader @babel/core</p>
</blockquote>
<blockquote>
<p>npm install @babel/preset-env –save-dev</p>
</blockquote>
<p>在webpack.config.js中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">            &#123;   test: /\.js$/, // 以js结尾的文件</span><br><span class="line">                exclude: /node_modules/,   //文件不在node_modules文件夹下</span><br><span class="line">                loader: &quot;babel-loader&quot; , //babel是js和babel的桥梁，但是并不完成代码转化</span><br><span class="line">                options:&#123;</span><br><span class="line">                    &quot;presets&quot;: [&quot;@babel/preset-env&quot;]  //代码转化</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>打包后会发现ES6语法转化成了ES5语法，但是.map 和promise依旧存在，在低版本的浏览器中，可能不存在ES6的某些对象或函数，我们需要将他们补充到低版本的浏览器中，需要安装babelPolyfill:</p>
<blockquote>
<p>npm install –save @babel/polyfill</p>
</blockquote>
<p>在index.js 中引用即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;  </span><br><span class="line">const arr = [</span><br><span class="line">    new Promise(()=&gt;&#123;&#125;),</span><br><span class="line">    new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">arr.map(item =&gt; &#123;</span><br><span class="line">    console.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是这样会发现打包后的文件变得很大，原因是babelPolyfill补充了所有的缺少的内容，但是我们只用到了map和pormise，这样做是浪费的，我们需要在config中去配置它，只让他补充我们用到的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123; test: /\.js$/, </span><br><span class="line">        exclude: /node_modules/, </span><br><span class="line">        loader: &quot;babel-loader&quot; ,</span><br><span class="line">        options:&#123;</span><br><span class="line">            &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123;</span><br><span class="line">                useBuiltIns:&apos;usage&apos;  //根据需求注入polyfill里边的内容,设置此内容后，index.js里边不需要再引入polyfill，会自动引入</span><br><span class="line">            &#125;]]</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>会看到打包后文件明显变小。</p>
<p>但是在有的浏览器版本中可以很好地支持ES6，我们就没有必要去转换，就需要做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: /\.js$/, </span><br><span class="line">    exclude: /node_modules/, </span><br><span class="line">    loader: &quot;babel-loader&quot; ,</span><br><span class="line">    options:&#123;</span><br><span class="line">        &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123;</span><br><span class="line">            useBuiltIns:&apos;usage&apos;,</span><br><span class="line">            targets:&#123;</span><br><span class="line">                chrome:&apos;67&apos;  //当chrome版本高于67时就不要做转换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这种方式只适用于普通的业务代码，对于打包库并不适用。polyfill注入变量或者方法时，是以全局变量的形式注入的，会污染全局环境。所以在打包类似UI组件库时要换一种打包方式，需要用到<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime#docsNav" target="_blank" rel="noopener">transform-runtime插件</a></p>
<blockquote>
<p>npm install –save-dev @babel/plugin-transform-runtime</p>
</blockquote>
<blockquote>
<p>npm install –save @babel/runtime</p>
</blockquote>
<p>webpack配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;absoluteRuntime&quot;: false,</span><br><span class="line">        &quot;corejs&quot;: false,</span><br><span class="line">        &quot;helpers&quot;: true,</span><br><span class="line">        &quot;regenerator&quot;: true,</span><br><span class="line">        &quot;useESModules&quot;: false,</span><br><span class="line">        &quot;version&quot;: &quot;7.0.0-beta.0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将corejs改为2（才会注入不存在的函数、对象或者方法）,需要安装：</p>
<blockquote>
<p>npm install –save @babel/runtime-corejs2</p>
</blockquote>
<p>最后设置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">     &#123;</span><br><span class="line">         test: /\.js$/,</span><br><span class="line">         exclude: /node_modules/,</span><br><span class="line">         loader: &quot;babel-loader&quot;,</span><br><span class="line">         options: &#123;</span><br><span class="line">             // &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123;</span><br><span class="line">             //     useBuiltIns:&apos;usage&apos;,</span><br><span class="line">             //     targets:&#123;</span><br><span class="line">             //         chrome:&apos;67&apos;</span><br><span class="line">             //     &#125;</span><br><span class="line">             // &#125;]]</span><br><span class="line"></span><br><span class="line">             &quot;plugins&quot;: [</span><br><span class="line">                 [</span><br><span class="line">                     &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">                     &#123;</span><br><span class="line">                         &quot;corejs&quot;: 2,</span><br><span class="line">                         &quot;helpers&quot;: true,</span><br><span class="line">                         &quot;regenerator&quot;: true,</span><br><span class="line">                         &quot;useESModules&quot;: false</span><br><span class="line">                     &#125;</span><br><span class="line">                 ]</span><br><span class="line">             ]</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;,</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<p>不需要引入polyfill。</p>
<p>babel-loader配置项options里面的内容可以单独抽出来放到src目录下.babelrc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line"></span><br><span class="line">&#123;  //用对象包住设置，不能有注释</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;corejs&quot;: 2,</span><br><span class="line">                &quot;helpers&quot;: true,</span><br><span class="line">                &quot;regenerator&quot;: true,</span><br><span class="line">                &quot;useESModules&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webpack对react打包"><a href="#webpack对react打包" class="headerlink" title="webpack对react打包"></a>webpack对react打包</h3><p>安装react</p>
<blockquote>
<p>npm install react react-dom –save</p>
</blockquote>
<p>对react打包需要<a href="https://babeljs.io/docs/en/babel-preset-react#docsNav" target="_blank" rel="noopener">babel-preset-react</a></p>
<blockquote>
<p>npm install –save-dev @babel/preset-react</p>
</blockquote>
<p>.babelrc文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;@babel/preset-env&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;targets&quot;: &#123;</span><br><span class="line">                    &quot;chrome&quot;:67</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;useBuiltIns&quot;:&quot;usage&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;@babel/preset-react&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有执行顺序，先执行preset-react转换react代码，然后preset-env结合useBuiltIns转换ES6代码。</p>
<p>index.js代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;</span><br><span class="line">import React ,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;hello Jerry&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T17:26:51+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、let、const、var"><a href="#1、let、const、var" class="headerlink" title="1、let、const、var"></a>1、let、const、var</h3><p><code>let</code>的用法类似于<code>var</code>，但是<code>let</code>只在代码块内有效，所以我们一般在代码块内用<code>let</code>替代<code>var</code>。而用<code>const</code>声明常量。</p>
<p>声明方式 | 变量提升 | 暂时性死区 | 重复声明 | 初始值 | 作用域<br>—|—|—|—|—|—|—<br>var | 允许 | 不存在 | 允许 | 不需要 | 除块级<br>let | 不允许 | 存在 | 不允许 | 不需要 | 块级<br>const | 不允许 | 存在 | 不允许 | 不需要 | 块级</p>
<h4 id="1-1、变量提升"><a href="#1-1、变量提升" class="headerlink" title="1.1、变量提升"></a>1.1、变量提升</h4><p>变量可在声明之前使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 变量提升</span><br><span class="line">console.log(a); //undefined</span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">console.log(b); //ReferenceError: b is not defined</span><br><span class="line">let b = 1;</span><br><span class="line"></span><br><span class="line">console.log(c); //ReferenceError: c is not defined</span><br><span class="line">const c = 1;</span><br></pre></td></tr></table></figure>

<p>var 命令经常会发生变量提升现象，按照一般逻辑，变量应该在声明之后使用才对。为了纠正这个现象，ES6 规定 let 和 const 命令不发生变量提升，使用 let 和 const 命令声明变量之前，该变量是不可用的。主要是为了减少运行时错误，防止变量声明前就使用这个变量，从而导致意料之外的行为。</p>
<h4 id="1-2、暂时性死区"><a href="#1-2、暂时性死区" class="headerlink" title="1.2、暂时性死区"></a>1.2、暂时性死区</h4><p>如果在代码块中存在 <code>let</code> 或 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">	tmp = &apos;abc&apos;;//报错，ReferenceError: tmp is not defined</span><br><span class="line">	let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的原意是在 <code>if</code> 内定义外部的 <code>tmp</code> 为 ‘abc’。</p>
<p>但现实是，存在全局变量 <code>tmp</code> ，但是块级作用域内 <code>let</code> 又声明了一个 <code>tmp</code>变量，导致后者被绑定在这个块级作用域中，所以在 <code>let</code> 声明变量前，对 <code>tmp</code> 赋值就报错了。</p>
<h4 id="1-3、重复声明"><a href="#1-3、重复声明" class="headerlink" title="1.3、重复声明"></a>1.3、重复声明</h4><p>指在相同作用域内，重复声明同一个变量。</p>
<p><code>let</code> 和 <code>const</code> 命令声明的变量不允许重复声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">    const PI = 3.1415;</span><br><span class="line">    </span><br><span class="line">    var a = 1;// 报错，Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</span><br><span class="line">    var PI = 3;// 报错，Uncaught SyntaxError: Identifier &apos;PI&apos; has already been declared</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当调用func()时报错，Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</span><br><span class="line">  function func()&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">    const PI = 3.1415;</span><br><span class="line">    </span><br><span class="line">    let a = 1;// 报错，Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</span><br><span class="line">    const PI = 3;// 报错，Uncaught SyntaxError: Identifier &apos;PI&apos; has already been declared</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>var 是允许重复定义的，而这又会给我们带来什么麻烦呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 10;</span><br><span class="line">for(var i = 0;i &lt; 5;i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);// 输出 5</span><br></pre></td></tr></table></figure>

<p>对于学习过静态（类型）语言的人知道，这段代码要是替换成 c 语言或其他静态语言，输出的结果应该是 10。然而对于 javascript 来说，这段代码的输出结果是 5。因为 <code>var</code> 命令没有块级作用域，所以 <code>for</code> 循环括号内的变量 <code>i</code> 会覆盖外层 <code>i</code>，而且 <code>var</code> 允许重复声明，所以这段代码中 <code>i</code> 被声明了两次,<code>i</code> 的最终结果就被 <code>for</code> 循环的 <code>i</code> 给覆盖了。</p>
<h4 id="1-4、初始值"><a href="#1-4、初始值" class="headerlink" title="1.4、初始值"></a>1.4、初始值</h4><p>由于 <code>const</code> 声明的是只读的常量，一旦声明，就必须立即初始化，声明之后值不能改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI = 3;// 报错，Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>

<h4 id="1-5、作用域"><a href="#1-5、作用域" class="headerlink" title="1.5、作用域"></a>1.5、作用域</h4><p>在 ES5 中只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();//处于全局作用域</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);//处于函数作用域</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>

<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。<br>然而现实是在这段代码中，<code>function</code> 内部的2个 <code>tmp</code> 变量处在同一函数作用域，由于变量提升，导致函数作用域中的 <code>tmp</code> 覆盖全局作用域中的 <code>tmp</code>，所以，f()输出结果为<code>undefined</code>。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量（前面在重复声明中提到的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 10;</span><br><span class="line">for(var i = 0;i &lt; 5;i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);// 输出 5</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="2、解构赋值"><a href="#2、解构赋值" class="headerlink" title="2、解构赋值"></a>2、解构赋值</h3><p>解构赋值是对赋值运算符的扩展。针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<h3 id="3、symbol"><a href="#3、symbol" class="headerlink" title="3、symbol"></a>3、symbol</h3><p>一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p>
<p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sy = Symbol(&quot;KK&quot;);</span><br><span class="line">console.log(sy);   // Symbol(KK)</span><br><span class="line">typeof(sy);        // &quot;symbol&quot;</span><br><span class="line"> </span><br><span class="line">// 相同参数 Symbol() 返回的值不相等</span><br><span class="line">let sy1 = Symbol(&quot;kk&quot;); </span><br><span class="line">sy === sy1;       // false</span><br></pre></td></tr></table></figure>

<h4 id="3-1、使用场景"><a href="#3-1、使用场景" class="headerlink" title="3.1、使用场景"></a>3.1、使用场景</h4><h5 id="作为属性名"><a href="#作为属性名" class="headerlink" title="作为属性名"></a>作为属性名</h5><p>由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。</p>
<p>写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let sy = Symbol(&quot;key1&quot;);</span><br><span class="line"> </span><br><span class="line">// 写法1</span><br><span class="line">let syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = &quot;kk&quot;;</span><br><span class="line">console.log(syObject);    // &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br><span class="line"> </span><br><span class="line">// 写法2</span><br><span class="line">let syObject = &#123;</span><br><span class="line">  [sy]: &quot;kk&quot;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(syObject);    // &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br><span class="line"> </span><br><span class="line">// 写法3</span><br><span class="line">let syObject = &#123;&#125;;</span><br><span class="line">Object.defineProperty(syObject, sy, &#123;value: &quot;kk&quot;&#125;);</span><br><span class="line">console.log(syObject);   // &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。</p>
<p>Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for…in 、 for…of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。</p>
<h5 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h5><p>使用 Symbol 定义常量，这样就可以保证这一组常量的值都不相等。</p>
<p>在switch case中使用</p>
<h4 id="3-2、Symbol-for"><a href="#3-2、Symbol-for" class="headerlink" title="3.2、Symbol.for()"></a>3.2、Symbol.for()</h4><p>Symbol.for() 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let yellow = Symbol(&quot;Yellow&quot;);</span><br><span class="line">let yellow1 = Symbol.for(&quot;Yellow&quot;);</span><br><span class="line">yellow === yellow1;      // false</span><br><span class="line"> </span><br><span class="line">let yellow2 = Symbol.for(&quot;Yellow&quot;);</span><br><span class="line">yellow1 === yellow2;     // true</span><br></pre></td></tr></table></figure>

<h4 id="3-3、Symbol-keyFor"><a href="#3-3、Symbol-keyFor" class="headerlink" title="3.3、Symbol.keyFor()"></a>3.3、Symbol.keyFor()</h4><p>Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let yellow1 = Symbol.for(&quot;Yellow&quot;);</span><br><span class="line">Symbol.keyFor(yellow1);    // &quot;Yellow&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4、Map"><a href="#4、Map" class="headerlink" title="4、Map"></a>4、Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h4 id="4-1、Maps-和-Objects-的区别"><a href="#4-1、Maps-和-Objects-的区别" class="headerlink" title="4.1、Maps 和 Objects 的区别"></a>4.1、Maps 和 Objects 的区别</h4><ul>
<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>
<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyString = &quot;a string&quot;; </span><br><span class="line"> </span><br><span class="line">myMap.set(keyString, &quot;和键&apos;a string&apos;关联的值&quot;);</span><br><span class="line"> </span><br><span class="line">myMap.get(keyString);    // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class="line">myMap.get(&quot;a string&quot;);   // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class="line">                         // 因为 keyString === &apos;a string&apos;</span><br></pre></td></tr></table></figure>

<p>map的key可以是string，object，function都可以</p>
<h4 id="4-2、Map-的迭代"><a href="#4-2、Map-的迭代" class="headerlink" title="4.2、Map 的迭代"></a>4.2、Map 的迭代</h4><h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(0, &quot;zero&quot;);</span><br><span class="line">myMap.set(1, &quot;one&quot;);</span><br><span class="line"> </span><br><span class="line">&lt;!--将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;--&gt;</span><br><span class="line">for (var [key, value] of myMap) &#123;</span><br><span class="line">  console.log(&apos;1&apos;,key + &quot; = &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1 0 = zero</span><br><span class="line">1 1 = one</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */</span><br><span class="line">for (var [key, value] of myMap.entries()) &#123;</span><br><span class="line">  console.log(&apos;2&apos;,key + &quot; = &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">2 0 = zero</span><br><span class="line">2 1 = one</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */</span><br><span class="line">for (var key of myMap.keys()) &#123;</span><br><span class="line">  console.log(&apos;3&apos;,key);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">3 0</span><br><span class="line">3 1</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */</span><br><span class="line">for (var value of myMap.values()) &#123;</span><br><span class="line">  console.log(&apos;4&apos;,value);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">4 zero</span><br><span class="line">4 one</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(0, &quot;zero&quot;);</span><br><span class="line">myMap.set(1, &quot;one&quot;);</span><br><span class="line"> </span><br><span class="line">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span><br><span class="line">myMap.forEach(function(value, key) &#123;</span><br><span class="line">  console.log(key + &quot; = &quot; + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-3、Map-对象的操作"><a href="#4-3、Map-对象的操作" class="headerlink" title="4.3、Map 对象的操作"></a>4.3、Map 对象的操作</h4><h5 id="Map-与-Array的转换"><a href="#Map-与-Array的转换" class="headerlink" title="Map 与 Array的转换"></a>Map 与 Array的转换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];</span><br><span class="line"> </span><br><span class="line">// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象</span><br><span class="line">var myMap = new Map(kvArray);</span><br><span class="line"> </span><br><span class="line">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span><br><span class="line">var outArray = Array.from(myMap);</span><br><span class="line"></span><br><span class="line">console.log(outArray) //[ [ &apos;key1&apos;, &apos;value1&apos; ], [ &apos;key2&apos;, &apos;value2&apos; ] ]</span><br><span class="line">console.log(kvArray) //[ [ &apos;key1&apos;, &apos;value1&apos; ], [ &apos;key2&apos;, &apos;value2&apos; ] ]</span><br><span class="line">console.log(myMap) //Map &#123; &apos;key1&apos; =&gt; &apos;value1&apos;, &apos;key2&apos; =&gt; &apos;value2&apos; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Map-的克隆"><a href="#Map-的克隆" class="headerlink" title="Map 的克隆"></a>Map 的克隆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);</span><br><span class="line">var myMap2 = new Map(myMap1);</span><br><span class="line"> </span><br><span class="line">console.log(myMap1 === myMap2);  //  false。 Map 对象构造函数生成实例，迭代出新的对象。</span><br></pre></td></tr></table></figure>

<h5 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var first = new Map([[1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);</span><br><span class="line">var second = new Map([[1, &apos;uno&apos;], [2, &apos;dos&apos;]]);</span><br><span class="line"> </span><br><span class="line">// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three</span><br><span class="line">var merged = new Map([...first, ...second]);</span><br><span class="line">console.log(first) //Map &#123; 1 =&gt; &apos;one&apos;, 2 =&gt; &apos;two&apos;, 3 =&gt; &apos;three&apos; &#125;</span><br><span class="line">console.log(second) //Map &#123; 1 =&gt; &apos;uno&apos;, 2 =&gt; &apos;dos&apos; &#125;</span><br><span class="line">console.log(merged) //Map &#123; 1 =&gt; &apos;uno&apos;, 2 =&gt; &apos;dos&apos;, 3 =&gt; &apos;three&apos; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4、WeakMap"><a href="#4-4、WeakMap" class="headerlink" title="4.4、WeakMap"></a>4.4、WeakMap</h4><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。<br>不同之处在于，WeakMap 不会阻止它的键值被垃圾回收。<br>那意味着你可以把数据和对象关联起来不用担心内存泄漏。</p>
<h3 id="5、Set"><a href="#5、Set" class="headerlink" title="5、Set"></a>5、Set</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<h4 id="5-1、Set-中的特殊值"><a href="#5-1、Set-中的特殊值" class="headerlink" title="5.1、Set 中的特殊值"></a>5.1、Set 中的特殊值</h4><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ul>
<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>
<li>undefined 与 undefined 是恒等的，所以不重复；</li>
<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let mySet = new Set();</span><br><span class="line"> </span><br><span class="line">console.log(mySet.add(1)); // Set &#123;1&#125;</span><br><span class="line">console.log(mySet.add(5)); // Set &#123;1, 5&#125;</span><br><span class="line">console.log(mySet.add(5)); // Set &#123;1, 5&#125; 体现了值的唯一性</span><br><span class="line">console.log(mySet.add(&quot;some text&quot;));  // Set &#123;1, 5, &quot;some text&quot;&#125; 体现了类型的多样性</span><br><span class="line"></span><br><span class="line">var o = &#123;a: 1, b: 2&#125;; </span><br><span class="line">console.log(mySet.add(o)); //Set &#123; 1, 5, &apos;some text&apos;, &#123; a: 1, b: 2 &#125; &#125;</span><br><span class="line">console.log(mySet.add(&#123;a: 1, b: 2&#125;));  //Set &#123; 1, 5, &apos;some text&apos;, &#123; a: 1, b: 2 &#125;, &#123; a: 1, b: 2 &#125; &#125;</span><br><span class="line">// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储</span><br></pre></td></tr></table></figure>

<h4 id="5-2、类型转换"><a href="#5-2、类型转换" class="headerlink" title="5.2、类型转换"></a>5.2、类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Array 转 Set</span><br><span class="line">var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);</span><br><span class="line">console.log(mySet) // Set &#123; &apos;value1&apos;, &apos;value2&apos;, &apos;value3&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 用...操作符，将 Set 转 Array</span><br><span class="line">var myArray = [...mySet];</span><br><span class="line">console.log(myArray) //[ &apos;value1&apos;, &apos;value2&apos;, &apos;value3&apos; ]</span><br><span class="line"></span><br><span class="line">// String 转 Set</span><br><span class="line">var mySet = new Set(&apos;hello&apos;);  </span><br><span class="line">console.log(mySet) //Set &#123; &apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos; &#125;</span><br><span class="line">// 注：Set 中 toString 方法是不能将 Set 转换成 String</span><br></pre></td></tr></table></figure>

<h4 id="5-3、set作用"><a href="#5-3、set作用" class="headerlink" title="5.3、set作用"></a>5.3、set作用</h4><h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mySet = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">console.log([...mySet]); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Set([1, 2, 3]);</span><br><span class="line">var b = new Set([4, 3, 2]);</span><br><span class="line">var union = new Set([...a, ...b]); // &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Set([1, 2, 3]);</span><br><span class="line">var b = new Set([4, 3, 2]);</span><br><span class="line">var intersect = new Set([...a].filter(x =&gt; b.has(x))); // &#123;2, 3&#125;</span><br></pre></td></tr></table></figure>

<h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Set([1, 2, 3]);</span><br><span class="line">var b = new Set([4, 3, 2]);</span><br><span class="line">var difference = new Set([...a].filter(x =&gt; !b.has(x))); // &#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>.filter 是数组内置的迭代方法，它接收一个断言函数，这个函数会在迭代的每个数组成员上调用，如果函数的返回值是真值，就过滤出（即保留）这个成员，否则（是假值的话）就过滤掉这个成员。最终 .filter 返回的是原数组的一个子集。</p>
<h4 id="5-4、WeakSet"><a href="#5-4、WeakSet" class="headerlink" title="5.4、WeakSet"></a>5.4、WeakSet</h4><p>WeakSet结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，<br>也就是说，如果其他对象都不再引用该对象，<br>那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
</ol>
<p><strong>Set 与 Map</strong></p>
<p>在使用的过程中明显的Set和Map比我们之前经常使用的Array和Object是有明显的便捷优势的。</p>
<p>在后续的开发过程中，我们可以根据场景需要来通过Set和Map来替代Array和Object来使用。</p>
<p>如果对数据结构存储的唯一性有要求，考虑使用Set。</p>
<p>如果数据的复杂程度高，考虑使用Map，在一些构建工具中是非常喜欢使用Map这种数据结构来进行配置，因为map是一种灵活、高效性、适合一对一查找的数据结构。</p>
<p>Set和Map有着类似的API，主要的不同是Set没有set方法，因为它不能存储键值对，剩下的几乎相同。</p>
<h3 id="6、Reflect和Proxy"><a href="#6、Reflect和Proxy" class="headerlink" title="6、Reflect和Proxy"></a>6、Reflect和Proxy</h3><p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。</p>
<p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p>
<h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;</span><br><span class="line">  name: &apos;Tom&apos;,</span><br><span class="line">  age: 24</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get: function(target, key) &#123;</span><br><span class="line">      console.log(&apos;getting &apos;+key);</span><br><span class="line">      return target[key]; // 不是target.key</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value) &#123;</span><br><span class="line">      console.log(&apos;setting &apos;+key);</span><br><span class="line">      target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(target, handler)</span><br><span class="line">proxy.name     // 实际执行 handler.get</span><br><span class="line">proxy.age = 25 // 实际执行 handler.set</span><br><span class="line">// getting name</span><br><span class="line">// setting age</span><br><span class="line"></span><br><span class="line">// proxy 是对target的浅拷贝</span><br><span class="line">console.log(target.age) //25</span><br></pre></td></tr></table></figure>

<h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p>
<h5 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h5><p>查找并返回 target 对象的 name 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    get info()&#123;</span><br><span class="line">        return this.name + this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Reflect.get(exam, &apos;name&apos;); // &quot;Tom&quot;</span><br><span class="line"> </span><br><span class="line">// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiver</span><br><span class="line">let receiver = &#123;</span><br><span class="line">    name: &quot;Jerry&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">Reflect.get(exam, &apos;info&apos;, receiver); // Jerry20</span><br><span class="line"> </span><br><span class="line">// 当 name 为不存在于 target 对象的属性时，返回 undefined</span><br><span class="line">Reflect.get(exam, &apos;birth&apos;); // undefined</span><br><span class="line"> </span><br><span class="line">// 当 target 不是对象时，会报错</span><br><span class="line">Reflect.get(1, &apos;name&apos;); // TypeError</span><br></pre></td></tr></table></figure>

<h5 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h5><p>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    set info(value)&#123;</span><br><span class="line">        return this.age = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">exam.age; // 24</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, 25); // true</span><br><span class="line">exam.age; // 25</span><br><span class="line"> </span><br><span class="line">// value 为空时会将 name 属性清除</span><br><span class="line">Reflect.set(exam, &apos;age&apos;, ); // true</span><br><span class="line">exam.age; // undefined</span><br><span class="line"> </span><br><span class="line">// 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,</span><br><span class="line">let receiver = &#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver); // true</span><br><span class="line">receiver.age; // 1</span><br><span class="line"> </span><br><span class="line">let receiver1 = &#123;</span><br><span class="line">    name: &apos;oppps&apos;</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &apos;info&apos;, 1, receiver1);</span><br><span class="line">receiver1.age; // 1</span><br></pre></td></tr></table></figure>

<h5 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h5><p>是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24</span><br><span class="line">&#125;</span><br><span class="line">Reflect.has(exam, &apos;name&apos;); // true</span><br></pre></td></tr></table></figure>

<h5 id="Reflect-deleteProperty-obj-property"><a href="#Reflect-deleteProperty-obj-property" class="headerlink" title="Reflect.deleteProperty(obj, property)"></a>Reflect.deleteProperty(obj, property)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24</span><br><span class="line">&#125;</span><br><span class="line">Reflect.deleteProperty(exam , &apos;name&apos;); // true</span><br><span class="line">exam // &#123;age: 24&#125; </span><br><span class="line">// property 不存在时，也会返回 true</span><br><span class="line">Reflect.deleteProperty(exam , &apos;name&apos;); // true</span><br></pre></td></tr></table></figure>

<h5 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys(target)"></a>Reflect.ownKeys(target)</h5><p>用于返回 target 对象的所有属性，等同于 Object.getOwnPropertyNames 与Object.getOwnPropertySymbols 之和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var exam = &#123;</span><br><span class="line">  name: 1,</span><br><span class="line">  [Symbol.for(&apos;age&apos;)]: 4</span><br><span class="line">&#125;</span><br><span class="line">Reflect.ownKeys(exam) // [&quot;name&quot;, Symbol(age)]</span><br></pre></td></tr></table></figure>

<h4 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h4><p>Reflect 对象的方法与 Proxy 对象的方法是一一对应的。所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let exam = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">    get: function(target, key)&#123;</span><br><span class="line">        console.log(&quot;getting &quot;+key);</span><br><span class="line">        return Reflect.get(target,key);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(target, key, value)&#123;</span><br><span class="line">        console.log(&quot;setting &quot;+key+&quot; to &quot;+value)</span><br><span class="line">        Reflect.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(exam, handler)</span><br><span class="line">proxy.name = &quot;Jerry&quot;</span><br><span class="line">proxy.name</span><br><span class="line">// setting name to Jerry</span><br><span class="line">// getting name</span><br><span class="line">// &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>

<h3 id="7、模板字符串"><a href="#7、模板字符串" class="headerlink" title="7、模板字符串"></a>7、模板字符串</h3><h3 id="8、对象"><a href="#8、对象" class="headerlink" title="8、对象"></a>8、对象</h3><h4 id="Object-assign-target-source-1-···"><a href="#Object-assign-target-source-1-···" class="headerlink" title="Object.assign(target, source_1, ···)"></a>Object.assign(target, source_1, ···)</h4><p>用于将源对象的所有可枚举属性复制到目标对象中。</p>
<p>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<h4 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1, value2)"></a>Object.is(value1, value2)</h4><p>用来比较两个值是否严格相等，与（===）基本类似。</p>
<p>区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//一是+0不等于-0</span><br><span class="line">Object.is(+0,-0);  //false</span><br><span class="line">+0 === -0  //true</span><br><span class="line">//二是NaN等于本身</span><br><span class="line">Object.is(NaN,NaN); //true</span><br><span class="line">NaN === NaN  //false</span><br></pre></td></tr></table></figure>

<h3 id="9、数组"><a href="#9、数组" class="headerlink" title="9、数组"></a>9、数组</h3><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>将参数中所有值作为元素形成数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]</span><br><span class="line"> </span><br><span class="line">// 参数值可为不同类型</span><br><span class="line">console.log(Array.of(1, &apos;2&apos;, true)); // [1, &apos;2&apos;, true]</span><br><span class="line"> </span><br><span class="line">// 参数为空时返回空数组</span><br><span class="line">console.log(Array.of()); // []</span><br></pre></td></tr></table></figure>

<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>将类数组对象或可迭代对象转化为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 参数为数组,返回与原数组一样的数组</span><br><span class="line">console.log(Array.from([1, 2])); // [1, 2]</span><br><span class="line"> </span><br><span class="line">// 参数含空位</span><br><span class="line">console.log(Array.from([1, , 3])); // [1, undefined, 3]</span><br></pre></td></tr></table></figure>

<h3 id="10、箭头函数"><a href="#10、箭头函数" class="headerlink" title="10、箭头函数"></a>10、箭头函数</h3><h3 id="11、class-类"><a href="#11、class-类" class="headerlink" title="11、class 类"></a>11、class 类</h3><h3 id="12、模块"><a href="#12、模块" class="headerlink" title="12、模块"></a>12、模块</h3><h3 id="13、promise"><a href="#13、promise" class="headerlink" title="13、promise"></a>13、promise</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/面向对象/" itemprop="url">面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T14:39:14+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>无序属性的集合，其属性可以包含基值、对象或者函数。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过关键字new，也可以通过对象字面量</p>
<h3 id="构造函数与原型"><a href="#构造函数与原型" class="headerlink" title="构造函数与原型"></a>构造函数与原型</h3><p>某一类的特定属性，通常放在构造函数中</p>
<p>某一类公共的方法与属性，通常放在原型对象中</p>
<p>new关键字在创建实例时经历如下过程：</p>
<ol>
<li>先创建一个新的、空的实例对象</li>
<li>将实例对象的原型指向构造函数的原型</li>
<li>将构造函数内部的this修改为指向实例</li>
<li>最后返回该实例对象</li>
</ol>
<p>如果在构造函数中声明的私有方法/属性与原型中的共有方法/属性重名，那么会优先访问私有方法/属性</p>
<h3 id="更简单的原型写法"><a href="#更简单的原型写法" class="headerlink" title="更简单的原型写法"></a>更简单的原型写法</h3><p>可以使用对象字面量的写法来添加原型方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype=&#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    getName:function()&#123;&#125;,</span><br><span class="line">    getAge:function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用对象字面量能够简化写法，但同时有一个需要特别注意的地方。当我们使用 <code>Person.prototype={}</code>时，其实是将Person的原型指向了一个新的对象{}。如果不做特殊处理，那么将会导致原型对象丢失。因此在这个新的对象中，需要将它的 <code>constructor</code> 属性指向构造函数 <code>Person</code>。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>几乎所有的对象都可以是原型对象，也可以是实例对象，还可以是构造函数，甚至可以身兼多职。</p>
<p>当一个对象身兼多职时，它就可以被看做原型链中的一个节点。</p>
<p>当一个对象A作为原型时，它有一个 <code>constructor</code>属性指向它的构造函数，即 <code>A.constructor</code>；</p>
<p>当一个对象B作为构造函数时，它有一个 <code>prototype</code>属性指向它的原型，即 <code>B.prototype；</code></p>
<p>当一个对象C作为实例时，它有一个 <code>_ _proto _ _</code>属性指向它的原型，即 <code>C._ _proto_ _</code>。</p>
<h3 id="实例方法、原型方法、静态方法"><a href="#实例方法、原型方法、静态方法" class="headerlink" title="实例方法、原型方法、静态方法"></a>实例方法、原型方法、静态方法</h3><p>构造函数中的this指向的是新创建的实例。因此在往this上添加方法与属性时，其实是在往新创建的实例上添加属性与方法，所以构造函数中的方法可称之为 <strong>实例方法</strong></p>
<p>通过 <code>prototype</code>添加的方法，将会挂载到原型对象上，因此称之为 <strong>原型方法</strong></p>
<p>直接挂载在构造函数上的方法，称之为 <strong>静态方法</strong>（静态方法不能通过实例访问，只能通过构造函数访问）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    this.bar=function()&#123;</span><br><span class="line">        return &apos;bar in Foo&apos; // 实例方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar=function()&#123;</span><br><span class="line">    return &apos;bar in static&apos;  //静态方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.bar=function()&#123;</span><br><span class="line">    return &apos;bar in prototype&apos; //原型方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>构造函数的继承（借助 call/apply实现）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var student=function(name,age,grade)&#123;</span><br><span class="line">    Student.call(Person,name,age);</span><br><span class="line">    this.grade=grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型的继承</p>
<p>只需让子类对象的原型成为父类对象的一个实例，然后通过 <code>_ _proto_ _</code>访问父类对象的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype=Object.create(Person.prototype,&#123;</span><br><span class="line">    //重新指定构造函数</span><br><span class="line">    constructor:&#123;</span><br><span class="line">        value:Student</span><br><span class="line">    &#125;,</span><br><span class="line">    getGrade:&#123;</span><br><span class="line">        value:function()&#123;</span><br><span class="line">            return this.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>在ES5中，对每个属性都添加了几个属性类型，用来描述这些属性的特点，如下：</p>
<ul>
<li><code>configurable</code>：表示该属性是都能被 <code>delete</code>删除。当其值为 <code>false</code>时，其他的特性也不能被改变。默认值为 <code>true</code></li>
<li><code>enumerable</code>：是否能枚举。即是都能被 <code>for-in</code>遍历。默认值为 <code>true</code></li>
<li><code>writable</code>：是都能修改值。默认值为 <code>true</code></li>
<li><code>value</code>：该属性的具体值是什么，默认为 <code>undefined</code></li>
<li><code>get</code>：访问某个值。该方法可以自定义返回的具体值是什么，默认值为 <code>undefined</code></li>
<li><code>set</code>：设置某个值。该方法可以自定义设置值的具体方式。默认值为 <code>undefined</code></li>
</ul>
<p>方法 <code>Object.defineProperty（对象名，属性名，{属性类型}）</code>，该方法只能设置一个属性的属性特性，当想要同时设置多个属性的特性时，需要使用 <code>Object.defineProperties</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Object.defineProperty</span><br><span class="line">Object.defineProperty(person,&apos;name&apos;,&#123;</span><br><span class="line">    value:&apos;Tom&apos;,</span><br><span class="line">    writable:false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//Object.defineProperties</span><br><span class="line">Object.defineProperties(person,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value:&apos;Tom&apos;,</span><br><span class="line">        writable:false</span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        value:20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="读取属性的特殊值"><a href="#读取属性的特殊值" class="headerlink" title="读取属性的特殊值"></a>读取属性的特殊值</h3><p>可以使用 <code>Object.getOwnPropertyDescriptor</code>方法读取某一个属性的特殊值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person,&apos;name&apos;,&#123;</span><br><span class="line">    value:&apos;alex&apos;,</span><br><span class="line">    writable:false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var descripter=Object.getOwnPropertyDescriptor(person,&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">console.log(descripter);</span><br><span class="line"></span><br><span class="line">descripter=&#123;</span><br><span class="line">    value:&apos;alex&apos;,</span><br><span class="line">    writable:false,</span><br><span class="line">    configurable:false,</span><br><span class="line">    enumerable:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/函数和函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/函数和函数式编程/" itemprop="url">函数和函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T14:15:09+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>常见函数形式：函数声明、函数表达式、匿名函数与自执行函数。</p>
<h4 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1. 函数声明"></a>1. 函数声明</h4><p>函数声明是指利用关键字 <code>function</code>来声明一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(&apos;function)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在变量对象的创建过程中， <code>function</code>声明的函数比 <code>var</code>声明的变量有更加优先的执行顺序，即函数声明提前。因此在同一执行上下文中，无论在什么地方声明了函数，都可以直接使用。</p>
<h4 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2. 函数表达式"></a>2. 函数表达式</h4><p>函数表达式其实是将一个函数体赋值给一个变量的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">//执行顺序</span><br><span class="line">var fn = undefined;</span><br><span class="line">fn=function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其中， <code>var fn = undefined</code>会因为变量对象的原因而提前声明，这就是常常被提到的变量提升。因此当我们使用函数表达式时，必须要考虑代码的先后顺序，这是与函数声明不同的地方。</p>
<h4 id="3-匿名函数"><a href="#3-匿名函数" class="headerlink" title="3. 匿名函数"></a>3. 匿名函数</h4><p>没有名字的函数，一般会作为一个参数或者作为一个返回值来使用，通常不使用变量来保存它的引用。</p>
<h4 id="4-自执行函数"><a href="#4-自执行函数" class="headerlink" title="4. 自执行函数"></a>4. 自执行函数</h4><p>自执行函数是匿名函数一个非常有用的应用场景。因为函数会产生独立的作用域。因此我们常常使用自执行函数来模拟块级作用域。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>当我们想要使用一个函数时，其实就是想将一些功能、逻辑等封装起来以便使用—函数式编程</p>
<h4 id="函数式一等公民"><a href="#函数式一等公民" class="headerlink" title="函数式一等公民"></a>函数式一等公民</h4><p>所谓的 “一等公民”就是普通公民。也就是说，函数没什么特殊的，可以向对待任何其他数据类型一样对待函数。</p>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>相同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数。</p>
<p>区分纯函数和非纯函数（获取数组的末尾值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getLast(arr)&#123;</span><br><span class="line">    return arr[arr.length]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLat_(arr)&#123;</span><br><span class="line">    return arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var last=getLast(arr);       //返回结果4，原数组不变（纯函数）</span><br><span class="line">var last_=getLast_(arr);     //返回结果4，原数组最后一项被删除（非纯函数）</span><br></pre></td></tr></table></figure>

<p>纯函数还有一个重要的特点，那就是除传入的参数外，不依赖任何外界的信息与状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;Jake&apos;;</span><br><span class="line"></span><br><span class="line">function sayHello()&#123;</span><br><span class="line">    return &apos;Hello,&apos;+ name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello();  &apos;&apos;Hello, Jake</span><br><span class="line"></span><br><span class="line">//当我们有其他需求时需要改变name的值</span><br><span class="line">name=&apos;Tom&apos;;</span><br><span class="line">sayHello();  //Hello,Tom</span><br></pre></td></tr></table></figure>

<p>由于 <code>sayHello</code>函数依赖于外界的 <code>name</code>，因此当外界变化时，函数的运行结果就会不同。因此，我们应该景将<code>name</code>当做一个参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name)&#123;</span><br><span class="line">    return &apos;Hello,&apos;+name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>纯函数的可移植性</li>
</ul>
<p>纯函数不依赖参数之外的值，因此纯函数的依赖非常明确。也正是如此，我们才能够把一些常用的功能封装成一个公共方法。</p>
<ul>
<li>纯函数的可缓存性</li>
</ul>
<p>纯函数的特点是，相同的输入总能得到相同的输出，因此可以对数据进行缓存。</p>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>构造函数中，<code>this</code>指向谁？如果在定义的原型方法中使用了 <code>this</code>，又指向谁？</p>
<p>构造函数其实就时普通的函数，而 <code>this</code>是在函数运行时才确认的。那么什么导致了构造函数的特别？</p>
<p> <strong>答案是与 <code>new</code>关键字有关</strong></p>
<p>自定义一个New方法，来模拟关键字 <code>new</code>的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//将构造函数以参数形式传入</span><br><span class="line">function New(func)&#123;</span><br><span class="line"></span><br><span class="line">    //声明一个中间对象，该对象为最终返回的实例</span><br><span class="line">    var res=&#123;&#125;;</span><br><span class="line">    if(func.prototype !==null)&#123;</span><br><span class="line">        </span><br><span class="line">        //将实例的原型指向构造函数的原型</span><br><span class="line">        res._ _proto_ _ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //ret为构造函数执行的结果，这里通过 apply</span><br><span class="line">    //将构造函数内部的 this 指向修改为指向 res，即为实例对象</span><br><span class="line">    var ret = func.apply(res,Array.prototype.slice.call(arguments,1));</span><br><span class="line">    </span><br><span class="line">    //当在构造函数中明确指定了返回对象时，那么 new的执行结果就是该返回对象</span><br><span class="line">    if((typeof ret === &apos;object&apos;|| typeof ret === &apos;function&apos;)&amp;&amp; ret !== null)&#123;</span><br><span class="line">        return ret</span><br><span class="line">    &#125;</span><br><span class="line">    //如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//应用</span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName=function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用上例中封装的New方法来创建对象</span><br><span class="line">var p1=New(Person,&apos;Jake&apos;,18);</span><br><span class="line">var p2=New(Person.&apos;Tom&apos;,20);</span><br><span class="line"></span><br><span class="line">p1.getName();  //Jake</span><br><span class="line">p2.getName();  //Tom</span><br></pre></td></tr></table></figure>

<p>如果把当前函数看成基础函数，那么高阶函数，就是让当前函数获得额外能力的函数。</p>
<p>通过下面的例子来理解高阶函数</p>
<h5 id="数组map方法封装的思考过程"><a href="#数组map方法封装的思考过程" class="headerlink" title="数组map方法封装的思考过程"></a>数组map方法封装的思考过程</h5><p>数组的map方法，对数组中的每一项运行给定的函数，返回每次函数调用的结果并组成数组。</p>
<p>map方法的第一参数为一个回调函数，该函数的有三个参数，this指向第二个参数，若该参数不存在，则this丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Array.prototypr._map=function(fn,context)&#123;</span><br><span class="line">    //首先定义一个数组来保存每一项的运算结果，最后返回</span><br><span class="line">    var temp=[];</span><br><span class="line">    if(typeof fn ==&apos;fuction’）&#123;</span><br><span class="line">        var k=0;</span><br><span class="line">        var len=this.length;</span><br><span class="line">        //封装for循环过程</span><br><span class="line">        for(;k&lt;len;k++)&#123;</span><br><span class="line">            //将每一项的运算操作丢进fn里</span><br><span class="line">            //利用call方法指定fn的this指向与具体参数</span><br><span class="line">            temp.push(fn,call(context,this[k],k,this))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;TypeError:&apos;+fn+&apos;is not a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回每一项运算结果组成的新数组</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newArr=[1,2,3,4]._map(function(item)&#123;</span><br><span class="line">    return item+1</span><br><span class="line">&#125;)</span><br><span class="line">//[2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>这个被传入的函数称为基础函数，封装的map函数即为高阶函数。</p>
<p><strong>高阶函数的使用思路正在于此，它其实是一个封装公共逻辑的过程</strong></p>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>所有以函数作为参数的函数，都可以叫做高阶函数</p>
<p>柯里化是指这样的函数（假设叫做createCurry），它接收函数A作为参数，运行后能够返回一个新的函数，并且这个新的函数能够处理函数A的剩余参数（只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function A(a,b,c)&#123;</span><br><span class="line">    //do</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _A=createCurry(A)</span><br><span class="line"></span><br><span class="line">//_A作为返回的函数，可以处理A剩余的参数，下面的结果都是等价的</span><br><span class="line">_A&#123;1,2,3&#125;</span><br><span class="line">_A(1,2)(3)</span><br><span class="line">_A(1)(2,3)</span><br><span class="line">_A(1)(2)(3)</span><br><span class="line">A(1,2,3)</span><br></pre></td></tr></table></figure>

<p>函数A被createCurry转化之后得到柯里化函数_A, 其能够处理A的所有剩余参数。因此柯里化也被称为部分求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//例子</span><br><span class="line">function add(a,b,c)&#123;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//柯里化后的函数</span><br><span class="line">function _add(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return function(c)&#123;</span><br><span class="line">            return a+b+c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//因此下面是等价的</span><br><span class="line">add(1,2,3);</span><br><span class="line">_add(1)(2)(3);</span><br></pre></td></tr></table></figure>

<p>柯里化函数的运行过程其实就是一个参数的收集过程，我们将每一次的参数收集起来，并在最里层进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//构造 createCurry 柯里化函数</span><br><span class="line"></span><br><span class="line">//arity用来标记剩余参数的个数，args用来收集参数</span><br><span class="line">function createCurry(func,arity,args)&#123;</span><br><span class="line">    //第一次执行时，并不会传入arity，而是直接获取func参数的个数</span><br><span class="line">    var arity=arity||func.length;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //第一次执行也不会传入args，而是默认为空数组</span><br><span class="line">    var args=args||[];</span><br><span class="line">    </span><br><span class="line">    var wrapper=function()&#123;</span><br><span class="line">        //将wrapper中的参数收集到args中</span><br><span class="line">        var _args=[].slice.call(arguments);</span><br><span class="line">        [].push.apply(args,_args);</span><br><span class="line">        </span><br><span class="line">        //如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class="line">        if(_args.length&lt;arity)&#123;</span><br><span class="line">            arity-=_args.length;</span><br><span class="line">            return createCurry(func,arity,args)</span><br><span class="line">        &#125;</span><br><span class="line">        //参数收集完毕，执行func</span><br><span class="line">        return func.apply(func,args)</span><br><span class="line">    &#125;</span><br><span class="line">    return wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/window对象的属性和方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/22/window对象的属性和方法/" itemprop="url">window对象的属性和方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-22T12:53:47+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener">参考</a></p>
<p><code>window</code>对象表示浏览器中打开的窗口</p>
<p>如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/22/函数/" itemprop="url">函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-22T12:25:13+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h5 id="构造函数的定义："><a href="#构造函数的定义：" class="headerlink" title="构造函数的定义："></a>构造函数的定义：</h5><p>构造函数是一种特殊的方法，主要用来创建对象时初始化对象，经常与 <code>new</code>运算符一起使用，创建对象的语句中构造函数的名称必须与类（ES6）名完全相同。</p>
<h5 id="与普通函数区别："><a href="#与普通函数区别：" class="headerlink" title="与普通函数区别："></a>与普通函数区别：</h5><ol>
<li><p>构造函数使用new关键字调用；普通函数不用new关键字调用；</p>
</li>
<li><p>构造函数内部可以使用this关键字；普通函数内部不建议使用this，因为这时候this指向的是window全局对象，这样无意间就会为window添加了一些全局变量或函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.1 在构造函数内部，this指向的是构造出来的新对象</span><br><span class="line">2.2 在普通函数内部，this指向的是window全局对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数默认不用return返回值；普通函数一般都有return返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.1 构造函数会默认返回this，也就是新的实例对象</span><br><span class="line"></span><br><span class="line">3.2 普通函数如果没有return值的话，返回undefined</span><br><span class="line"></span><br><span class="line">3.3 如果使用了return，那返回值会根据return值的类型而有所不同</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数首字母建议大写；普通函数首字母建议小写</p>
</li>
</ol>
<h5 id="拓展：构造函数中有-return怎么办？"><a href="#拓展：构造函数中有-return怎么办？" class="headerlink" title="拓展：构造函数中有 return怎么办？"></a>拓展：构造函数中有 <code>return</code>怎么办？</h5><p>构造函数里没有显式调用return时，默认是返回this对象，也就是新创建的实例对象。<br>当构造函数里调用return时，分两种情况：</p>
<ol>
<li><p><code>return</code>的是五种简单数据类型：<code>String</code>，<code>Number</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code>。<br>这种情况下，忽视<code>return</code>值，依然返回<code>this</code>对象。</p>
</li>
<li><p><code>return</code>的是<code>Object</code><br>这种情况下，不再返回<code>this</code>对象，而是返回<code>return</code>语句的返回值。</p>
</li>
</ol>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数的定义：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。因此callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p>
<p>简而言之，一个函数作为参数传给另一个函数，在另一个函数中被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法：匿名函数作为回调函数</span><br><span class="line">var generalLastName = &quot;Cliton&quot;;</span><br><span class="line">function getInput(options, callback)&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr.push(options);</span><br><span class="line">    //将全局变量generalLastName传递给回调函数</span><br><span class="line">    callback(generalLastName,arr);</span><br><span class="line">&#125;</span><br><span class="line">getInput(&#123;name:&quot;Rich&quot;,speciality:&quot;Javascript&quot;&#125;, function(generalLastName,arr)&#123;</span><br><span class="line">    console.log(generalLastName + &quot;:&quot; + arr[0].speciality) // Cliton:Javascript</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//第二种方法：命名函数作为回调函数</span><br><span class="line">var generalLastName = &quot;Cliton&quot;;</span><br><span class="line">function getInput(options, callback)&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    arr.push(options);</span><br><span class="line">    //将全局变量generalLastName传递给回调函数</span><br><span class="line">    callback(generalLastName,arr);</span><br><span class="line">&#125;</span><br><span class="line">function call(generalLastName,arr)&#123;</span><br><span class="line">    console.log(generalLastName + &quot;:&quot; + arr[0].speciality) // Cliton:Javascript</span><br><span class="line">&#125;</span><br><span class="line">getInput(&#123;name:&quot;Rich&quot;,speciality:&quot;Javascript&quot;&#125;, call);</span><br></pre></td></tr></table></figure>

<h3 id="自执行函数（立即执行函数）"><a href="#自执行函数（立即执行函数）" class="headerlink" title="自执行函数（立即执行函数）"></a>自执行函数（立即执行函数）</h3><p><a href="https://www.cnblogs.com/vickylinj/p/12191958.html" target="_blank" rel="noopener">参考</a></p>
<p>自执行函数的定义：立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行。</p>
<h5 id="自执行函数的写法"><a href="#自执行函数的写法" class="headerlink" title="自执行函数的写法"></a>自执行函数的写法</h5><ol>
<li>最前最后加括号</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;alert(1);&#125;());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>function外面加括号</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;alert(1);&#125;)();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>function前面加运算符，常见的是!与void</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;alert(1);&#125;(); </span><br><span class="line">void function()&#123;alert(2);&#125;();</span><br></pre></td></tr></table></figure>

<p>在function前面加！、+、-甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义</p>
<h5 id="自执行函数的功能"><a href="#自执行函数的功能" class="headerlink" title="自执行函数的功能"></a>自执行函数的功能</h5><ul>
<li>它可以帮你封装大量的工作而不会在背后遗留任何全局变量。</li>
<li>你定义的所有变量都会成员立即执行函数的局部变量，所以你不用担心这些临时变量会污染全局空间</li>
<li>可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量</li>
<li>可以添加更多的加强模块，移除它们，单独测试它们，允许用户去禁用它们等等</li>
</ul>
<h5 id="自执行函数的好处："><a href="#自执行函数的好处：" class="headerlink" title="自执行函数的好处："></a>自执行函数的好处：</h5><ul>
<li>防止变量弥散到全局，避免各种JavaScript库冲突</li>
<li>隔离作用域，避免污染，或者隔断作用域链，避免闭包造成引用变量无法释放</li>
<li>利用立即执行特性，返回需要的函数或对象，避免每次用条件判断来处理</li>
</ul>
<h5 id="自执行函数应用场景：作用是创建一个独立的作用域。一般用于框架、插件等场景"><a href="#自执行函数应用场景：作用是创建一个独立的作用域。一般用于框架、插件等场景" class="headerlink" title="自执行函数应用场景：作用是创建一个独立的作用域。一般用于框架、插件等场景"></a>自执行函数应用场景：作用是创建一个独立的作用域。一般用于框架、插件等场景</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/JavaScript中不同类型的错误有几种/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/21/JavaScript中不同类型的错误有几种/" itemprop="url">JavaScript中不同类型的错误有几种</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T22:29:53+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><code>Load time errors</code> ：该错误发生于加载网页时，例如出现语法错误等状况，称为加载时间错误，并且会动态生成错误。</li>
<li><code>Run time errors</code> ：由于在HTML语言中滥用命令而导致的错误。</li>
<li><code>Logical Errors</code> ：这是由于在具有不同操作的函数上执行了错误逻辑而发生的错误。</li>
</ul>
<p><a href="https://itbilu.com/javascript/js/V1oOv4Vv-.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="1-错误对象：-Error"><a href="#1-错误对象：-Error" class="headerlink" title="1. 错误对象： Error"></a>1. 错误对象： <code>Error</code></h3><h4 id="1-1-语法结构"><a href="#1-1-语法结构" class="headerlink" title="1.1 语法结构"></a>1.1 语法结构</h4><p> <code>new Error ([message])</code>  参数为错误描述</p>
<h4 id="1-2-Error类方法与属性"><a href="#1-2-Error类方法与属性" class="headerlink" title="1.2 Error类方法与属性"></a>1.2 <code>Error</code>类方法与属性</h4><p><code>Error</code>类本身没有任何方法。但是，在JavaScript中所有类都继承自对象，所以其会包含一些继承自 <code>Object</code>的类方法。</p>
<h4 id="1-3-使用示例"><a href="#1-3-使用示例" class="headerlink" title="1.3 使用示例"></a>1.3 使用示例</h4><p>通常，可以在创建<code>Error</code>实例后，通过<code>throw</code>关键字抛出。和大多数语言一样，JavaScript提供了<code>try...catch</code>结构来捕获和处理错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw new Error(&apos;Whoops!&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e.name + &apos;: &apos; + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-JavaScript中的错误类型"><a href="#2-JavaScript中的错误类型" class="headerlink" title="2. JavaScript中的错误类型"></a>2. JavaScript中的错误类型</h3><h4 id="2-1-EvalError-Eval错误"><a href="#2-1-EvalError-Eval错误" class="headerlink" title="2.1  EvalError - Eval错误"></a>2.1  <code>EvalError</code> - Eval错误</h4><p>该对象表示全局函数 <code>eval（）</code>中发生的错误。可以通过构造函数创建这个对象的实例。</p>
<h4 id="2-2-ReferenceError-引用错误"><a href="#2-2-ReferenceError-引用错误" class="headerlink" title="2.2 ReferenceError-引用错误"></a>2.2 <code>ReferenceError</code>-引用错误</h4><p>该对象会在引用未定义的变量时触发，也可以通过构造函数创建这个对象的实例。</p>
<h4 id="2-3-RangeError-范围错误"><a href="#2-3-RangeError-范围错误" class="headerlink" title="2.3  RangeError-范围错误"></a>2.3  <code>RangeError</code>-范围错误</h4><p>该错误对象会在值超过有效范围时触发，也可以通过构造函数创建这个对象的实例。</p>
<h4 id="2-4-SyntaxError-语法错误"><a href="#2-4-SyntaxError-语法错误" class="headerlink" title="2.4  SyntaxError-语法错误"></a>2.4  <code>SyntaxError</code>-语法错误</h4><p>该错误对象在使用不合法的语法结构时触发，也可以通过构造函数创建这个对象的实例。</p>
<h4 id="2-5-TypeError-类型错误"><a href="#2-5-TypeError-类型错误" class="headerlink" title="2.5  TypeError-类型错误"></a>2.5  <code>TypeError</code>-类型错误</h4><p>该对象会在对象用来表示值的类型非预期类型时触发，也可以通过构造函数创建这个对象的实例。</p>
<h4 id="2-6-URIError-URI错误"><a href="#2-6-URIError-URI错误" class="headerlink" title="2.6 URIError-URI错误"></a>2.6 <code>URIError</code>-URI错误</h4><p>该错误会在错误使用全局URI函数 如<code>encodeURI()</code>、<code>decodeURI()</code>等时触发。也可以通过构造函数创建该对象的实例。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/21/js/" itemprop="url">js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T15:05:40+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="不同浏览器关于js兼容性的两个常见问题"><a href="#不同浏览器关于js兼容性的两个常见问题" class="headerlink" title="不同浏览器关于js兼容性的两个常见问题"></a>不同浏览器关于js兼容性的两个常见问题</h3><ul>
<li>事件绑定兼容性：IE8以下的浏览器不支持使用<code>addEventListener</code>来绑定事件，使用<code>attachEvent</code> 可以解决这个问题。</li>
<li><code>stopPropagation</code>兼容性：IE8以下的浏览器不支持使用<code>e.stopPropagation</code>来阻止事件传播，使用<code>e.returnValue = false</code>可以解决这个问题。</li>
</ul>
<p><a href="https://www.w3school.com.cn/jsref/event_stoppropagation.asp" target="_blank" rel="noopener">stopPropagation</a></p>
<h3 id="什么是未声明和未定义变量"><a href="#什么是未声明和未定义变量" class="headerlink" title="什么是未声明和未定义变量"></a>什么是未声明和未定义变量</h3><p>未声明的变量是程序中不存在且未声明的变量。如果程序尝试读取未声明变量的值，则会遇到运行时错误。</p>
<p>未定义的变量是在程序中声明但尚未给出任何值的变量。如果程序尝试读取未定义变量的值，则返回未定义的值。</p>
<h3 id="JavaScript-中的进制转换"><a href="#JavaScript-中的进制转换" class="headerlink" title="JavaScript 中的进制转换"></a><code>JavaScript</code> 中的进制转换</h3><h4 id="十进制转换为其它进制"><a href="#十进制转换为其它进制" class="headerlink" title="十进制转换为其它进制"></a>十进制转换为其它进制</h4><p><code>Number.toString([radix])</code>，<code>radix</code> 要转换为的进制。</p>
<p>在调用数值的 <code>toString()</code>方法时，可以传递一个参数：输出数值的基数。默认情况下， <code>toString()</code>方法以十进制格式返回数值的字符串表示。而通过传递基数，<code>toString()</code>可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString()); // &quot;10&quot;</span><br><span class="line">alert(num.toString(2)); // &quot;1010&quot;</span><br><span class="line">alert(num.toString(8)); // &quot;12&quot;</span><br><span class="line">alert(num.toString(10)); // &quot;10&quot;</span><br><span class="line">alert(num.toString(16)); // &quot;a&quot;</span><br></pre></td></tr></table></figure>

<h4 id="其他禁止转换为十进制"><a href="#其他禁止转换为十进制" class="headerlink" title="其他禁止转换为十进制"></a>其他禁止转换为十进制</h4><p><code>parseInt(str, [radix])</code> </p>
<p><code>str</code> 必选项，转换对象。（该方法会将第一个参数强制转换为字符串）</p>
<p><code>radix</code> 可选项，表示 <code>str</code>的进制，范围为 2 - 36；如果缺少 <code>radix</code>，则以 0x 开头的字符串转换为十六进制，以 0 开头的字符串转换为八进制，其它字符串都转换十进制。将字符串<code>str</code>按照radix进制编码方式转换为10进制返回，没有radix，默认为10；此方法把任意进制字符串转为10进展返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x=&apos;110&apos;;</span><br><span class="line">alert(parseInt(x,2)); //6</span><br><span class="line">alert(parseInt(x,8));//72</span><br><span class="line">alert(parseInt(x,16));//272</span><br></pre></td></tr></table></figure>

<h3 id="void-0-的作用是什么"><a href="#void-0-的作用是什么" class="headerlink" title="void(0)的作用是什么"></a><code>void(0)</code>的作用是什么</h3><h4 id="void关键字介绍"><a href="#void关键字介绍" class="headerlink" title="void关键字介绍"></a><code>void</code>关键字介绍</h4><p>void关键字是javascript当中非常重要的关键字，该操作符指定要计算或运行一个表达式，但是不返回值。</p>
<p>语法格式：<code>void func()</code> or <code>javascript:void func()</code>或者 <code>void(func())</code> or <code>javascript:void(func())</code></p>
<ul>
<li>点击超级连接，什么都不发生</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--当用户点击链接时，viod(0)计算为0，用户不会发生任何效果--&gt;</span><br><span class="line"> &lt;a href=&quot;javascript:void(0);&quot;&gt;单击此处什么都不会发生&lt;/a&gt;&lt;br&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;!--下面的代码创建了一个超级链接，用户单时会提交表单。--&gt;</span><br><span class="line"> &lt;a href=&quot;javascript:void(document.form.submit())&quot;&gt;点击此处提交表单&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行void当中代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 2.执行 void() 操作符中的代码 --&gt;</span><br><span class="line">    &lt;a href=&quot;javascript:void(alert(&apos;还真点啊你，真听话！！！哈哈哈！！！&apos;))&quot;&gt;点我弹出警告框!!!&lt;/a&gt;&lt;br&gt;</span><br><span class="line">    &lt;a href=&quot;javascript:void(console.log(&apos;还真点啊你，真听话！！！哈哈哈！！！&apos;))&quot;&gt;点我输出到控制台!!!&lt;/a&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算void当中算数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot;&gt; 点我&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        var a, b, c, d;</span><br><span class="line">        a = void(b = 2, c = 3);</span><br><span class="line">        console.log(&apos;a =&gt; &apos; + a); //undefined</span><br><span class="line">        console.log(&apos;b =&gt; &apos; + b);//2</span><br><span class="line">        console.log(&apos;c =&gt; &apos; + c);//3</span><br><span class="line">        console.log(&apos;d =&gt; &apos; + d);//undefined</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//很显然，2赋值给了a, 3赋值给了b, a 和 d一样只是定义了没有赋值，所以为undefined</span><br></pre></td></tr></table></figure>

<ul>
<li>#与javascript:void(0)的区别</li>
</ul>
<p>#可以跳转到设置了id的目的地</p>
<p>javascript:void(0)则停留在原地，一动不动，我们称之为“死链接”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:void(0);&quot;&gt;你点吧，反正我就是不动，嘿嘿嘿！！！&lt;/a&gt;&lt;br&gt;</span><br><span class="line">    &lt;a href=&quot;#destination&quot;&gt;点我跳转&lt;/a&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;h2 id=&quot;destination&quot;&gt;目的地&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>当点击第一个链接时，一动不动</p>
<p>当点击第二个连接时，会跳转到指定id得位置（页面最底部）</p>
<p>总结：</p>
<p><code>void</code>操作符使表达式的运算结果返回 <code>undefined</code>   <code>a.void(5)-&gt;undefined</code></p>
<p><code>void(0)</code>用于防止页面刷新，并在传递时传递参数 “0”</p>
<p><code>void(0)</code>用于调用另一种方法而不刷新页面</p>
<h3 id="在JavaScript中使用innerHTML的缺点是什么"><a href="#在JavaScript中使用innerHTML的缺点是什么" class="headerlink" title="在JavaScript中使用innerHTML的缺点是什么"></a>在<code>JavaScript</code>中使用<code>innerHTML</code>的缺点是什么</h3><p>定义：该属性设置或返回表格行的开始合结束标签之间的 HTML</p>
<p>语法： <code>HTMLElementObject.innerHTML=text</code></p>
<ul>
<li>内容被随处替换</li>
<li>整个innerHTML内容被重新解析并构建成元素，因此它慢得多</li>
<li>innerHTML不提供验证，因此我们可以在文档中插入有效和破碎的HTML并将其分隔</li>
<li>我们不能使用像“appending to innerHTML”，即使使用 += 如 “innerHTML = innerHTML + ‘html’” ，旧的内容仍然会被字符串的连接替换掉</li>
</ul>
<h5 id="innerHTML与-innerText的区别："><a href="#innerHTML与-innerText的区别：" class="headerlink" title="innerHTML与 innerText的区别："></a><code>innerHTML</code>与 <code>innerText</code>的区别：</h5><p>这两个属性都是获取 <code>document</code>对象的文本内容的。</p>
<ul>
<li><code>innerHTML</code>指的是 ：从对象的起始位置到终止位置的全部内容，包括 HTML标签</li>
<li><code>innerText</code>指的是 ：从起始位置到终止位置的内容，但它去除HTML标签</li>
</ul>
<p>同时，innerHTML 是所有浏览器都支持的，innerText 是IE浏览器和chrome 浏览器支持的，Firefox浏览器不支持。其实，innerHTML 是W3C 组织规定的属性；而innerText 属性是IE浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jerry">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
