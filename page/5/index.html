<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Jerry&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Jerry&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jerry&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Jerry's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jerry's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/21/题目/" itemprop="url">题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T11:29:43+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">参考</a></p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<p>（1）在数据集之中，选择一个元素作为”基准”（pivot）。</p>
<p>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</p>
<p>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>
<h5 id="js实现快速排序"><a href="#js实现快速排序" class="headerlink" title="js实现快速排序"></a>js实现快速排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = function(arr)&#123;</span><br><span class="line">    // 检查数组个数，小于等于1，直接返回</span><br><span class="line">    if(arr.length &lt;= 1)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 选择基准</span><br><span class="line">    var pivotIndex = Math.floor(arr.length/2);</span><br><span class="line">    console.log(&apos;pivotIndex---&gt;&apos;,pivotIndex);</span><br><span class="line">    var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">    console.log(&apos;pivot---&gt;&apos;,pivot);</span><br><span class="line">    var left = [];</span><br><span class="line">    var right = [];</span><br><span class="line">    // 遍历数组，小于基准的放在左边的子集，大的放到右边的子集</span><br><span class="line">    for(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        if(arr[i] &lt; pivot)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 不断重复这个过程，得到排序后的数组</span><br><span class="line">    return quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [85,24,63,45,14,31,96,50]</span><br><span class="line"></span><br><span class="line">console.log(quickSort(arr));</span><br><span class="line">// [ 14, 24, 31, 45, 50, 63, 85, 96 ]</span><br></pre></td></tr></table></figure>

<h3 id="查看字符串中各字母的次数"><a href="#查看字符串中各字母的次数" class="headerlink" title="查看字符串中各字母的次数"></a>查看字符串中各字母的次数</h3><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>创建空对象，统计计数结果</p>
<p>遍历每个字母的值，看结果对象中是否存在</p>
<p>不存在则创建，存在则计数加一</p>
<h5 id="js代码实现"><a href="#js代码实现" class="headerlink" title="js代码实现"></a>js代码实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function searchWord(str)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    for(let i = 0 ,len = str.length;i&lt;len;i++)&#123;</span><br><span class="line">        //str.charAt(index)返回str[index],&apos;acd&apos;.charAt(0)---&apos;a&apos;</span><br><span class="line">        let keyValue = str.charAt(i);</span><br><span class="line">        if(obj[keyValue] &amp;&amp; obj[keyValue].value === keyValue)&#123;</span><br><span class="line">            console.log(&apos;1&apos;)</span><br><span class="line">            obj[keyValue].count = obj[keyValue].count + 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&apos;2&apos;)</span><br><span class="line">            obj[keyValue] = &#123;&#125;;</span><br><span class="line">            obj[keyValue].count = 1;</span><br><span class="line">            obj[keyValue].value = keyValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(searchWord(&apos;asaragavaf&apos;))</span><br><span class="line"></span><br><span class="line">// &#123; a: &#123; count: 5, value: &apos;a&apos; &#125;,</span><br><span class="line">//   s: &#123; count: 1, value: &apos;s&apos; &#125;,</span><br><span class="line">//   r: &#123; count: 1, value: &apos;r&apos; &#125;,</span><br><span class="line">//   g: &#123; count: 1, value: &apos;g&apos; &#125;,</span><br><span class="line">//   v: &#123; count: 1, value: &apos;v&apos; &#125;,</span><br><span class="line">//   f: &#123; count: 1, value: &apos;f&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="清除字符串前后空格"><a href="#清除字符串前后空格" class="headerlink" title="清除字符串前后空格"></a>清除字符串前后空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function trim(str)&#123;</span><br><span class="line">    if(str &amp;&amp; typeof str === &apos;string&apos;)&#123;</span><br><span class="line">        return str.replace(/^\s+|\s+$/g,&apos; &apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var str1 = &apos;    asdas  &apos;</span><br><span class="line">console.log(trim(str1));</span><br><span class="line">console.log(str1)</span><br><span class="line">/*</span><br><span class="line"> asdas</span><br><span class="line">    asdas</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="实现数组合并，并且去重"><a href="#实现数组合并，并且去重" class="headerlink" title="实现数组合并，并且去重"></a>实现数组合并，并且去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function defineConcat()&#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    function concat(arrA,arrB)&#123;</span><br><span class="line">        arrB.forEach(e =&gt; &#123;</span><br><span class="line">            if(arrA.indexOf(e) === -1)&#123;</span><br><span class="line">                arrA.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    for(let i =0,len = arguments.length;i &lt; len;i++)&#123;</span><br><span class="line">        concat(res,arguments[i]);</span><br><span class="line">        console.log(arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;合并数组&apos;,defineConcat([12,3],[5,4],[7,5]))</span><br><span class="line">// 合并数组 [ 12, 3, 5, 4, 7 ]</span><br></pre></td></tr></table></figure>

<h3 id="typeof-bar-39-object-39-可以确定bar是不是对象的潜在陷阱，如何避免这个陷阱？"><a href="#typeof-bar-39-object-39-可以确定bar是不是对象的潜在陷阱，如何避免这个陷阱？" class="headerlink" title="typeof bar===&#39;object&#39;可以确定bar是不是对象的潜在陷阱，如何避免这个陷阱？"></a><code>typeof bar===&#39;object&#39;</code>可以确定bar是不是对象的潜在陷阱，如何避免这个陷阱？</h3><p>我们知道<code>typeof null</code>结果为<code>object</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bar = null;</span><br><span class="line">console.log(typeof bar === &quot;object&quot;);  // logs true!</span><br></pre></td></tr></table></figure>

<p>只要清楚这一点，同时检查<code>bar</code>是否为<code>null</code>，就可以很容易地避免问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;));  // logs false</span><br></pre></td></tr></table></figure>

<h3 id="下面的代码将输出什么到控制台？为什么？"><a href="#下面的代码将输出什么到控制台？为什么？" class="headerlink" title="下面的代码将输出什么到控制台？为什么？"></a>下面的代码将输出什么到控制台？为什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var a=b=3;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(&quot;a defined&quot;+(typeof a!==&apos;undefined&apos;))</span><br><span class="line">console.log(&quot;b defined&quot;+(typeof b!==&apos;undefined&apos;))</span><br></pre></td></tr></table></figure>

<p>输出结果为下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a defined false</span><br><span class="line">b defined true</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a= b=3;</span><br><span class="line">//上面的声明为以下形式的简写</span><br><span class="line">b=3;</span><br><span class="line">var a=b;</span><br></pre></td></tr></table></figure>

<p>在非严格模式下， <code>b=3</code>会成为全局变量，所以会生成上面的输出结果</p>
<p>若在严格模式下：语句 <code>var a= b=3</code>将生成 <code>ReferenceError：b is not defined</code>的运行时错误，从而避免任何问题。</p>
<h3 id="以下两个函数会返回相同的结果吗？"><a href="#以下两个函数会返回相同的结果吗？" class="headerlink" title="以下两个函数会返回相同的结果吗？"></a>以下两个函数会返回相同的结果吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo1()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        bar:&apos;Hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    //&#123;bar:&apos;Hello&apos;&#125;</span><br><span class="line"></span><br><span class="line">function foo2()&#123;</span><br><span class="line">    return </span><br><span class="line">    &#123;</span><br><span class="line">        bar:&apos;Hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    // undefined</span><br></pre></td></tr></table></figure>

<p>当遇到 <code>return</code>语句行时（代码行上没有任何其他的代码），分号会立即插入返回语句之后，也不会抛出错误，因为代码的其余部分是完全有效的，即时它没有得到调用或做任何事情。</p>
<p>即第二个函数相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo2()&#123;</span><br><span class="line">    return ; // 执行到这已经结束了函数，后边代码没有执行</span><br><span class="line">    &#123;</span><br><span class="line">        bar:&apos;Hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写出函数-isInterger-x-的实现方法"><a href="#写出函数-isInterger-x-的实现方法" class="headerlink" title="写出函数 isInterger(x)的实现方法"></a>写出函数 <code>isInterger(x)</code>的实现方法</h3><p>ES6引入一个新的方法，即 <code>Number.isInterger(x)</code>，它可以用来判断一个数字x是否为整数。</p>
<p>在ES的规格说明中，整数只是在概念上存在，即，数字值总是存储为浮点数值。</p>
<p>实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//使用取余运算</span><br><span class="line">function isInterger(x)&#123;</span><br><span class="line">    return (typeof x===&apos;number&apos;)&amp;&amp;(x%1===0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Math.round,ceil,floor</span><br><span class="line">function isInterger(x)&#123;</span><br><span class="line">    return Math.floor(x)===x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Math.ceil() 函数返回大于或等于一个给定数字的最小整数。(向上取整)</span><br><span class="line">//Math.round() 函数返回一个数字四舍五入后最接近的整数</span><br><span class="line">//Math.floor() 返回小于或等于一个给定数字的最大整数。(向下取整)</span><br></pre></td></tr></table></figure>

<h3 id="写一个简单函数，要求返回一个布尔值，判断字符串是否为回文字符串。"><a href="#写一个简单函数，要求返回一个布尔值，判断字符串是否为回文字符串。" class="headerlink" title="写一个简单函数，要求返回一个布尔值，判断字符串是否为回文字符串。"></a>写一个简单函数，要求返回一个布尔值，判断字符串是否为回文字符串。</h3><p>回文字符串：正读和反读都一样的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function isPalindrome(str)&#123;</span><br><span class="line">    str=str.replace(/\W/g,&apos;&apos;).toLowerCase()</span><br><span class="line">    return (str==str.split(&apos;&apos;).reverse().join(&apos;&apos;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isPalindrome(&quot;level&quot;));                   // logs &apos;true&apos;</span><br><span class="line">console.log(isPalindrome(&quot;levels&quot;));                  // logs &apos;false&apos;</span><br><span class="line">console.log(isPalindrome(&quot;A car, a man, a maraca&quot;));  // logs &apos;true&apos;</span><br></pre></td></tr></table></figure>

<h3 id="写一个-sum方法，在使用下面任一语法调用时，都可以正常工作"><a href="#写一个-sum方法，在使用下面任一语法调用时，都可以正常工作" class="headerlink" title="写一个 sum方法，在使用下面任一语法调用时，都可以正常工作"></a>写一个 <code>sum</code>方法，在使用下面任一语法调用时，都可以正常工作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(2,3));   // Outputs 5</span><br><span class="line">console.log(sum(2)(3));  // Outputs 5</span><br></pre></td></tr></table></figure>

<h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x) &#123;</span><br><span class="line">  if (arguments.length == 2) &#123;</span><br><span class="line">    return arguments[0] + arguments[1];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function(y) &#123; return x + y; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JavaScript中，函数可以提供到 <code>arguments</code> 对象的访问，<code>arguments</code> 对象提供传递到函数的实际参数的访问。这使我们能够使用 <code>length</code> 属性来确定在运行时传递给函数的参数数量。</p>
<p>如果传递两个参数，那么只需加在一起，并返回。</p>
<p>否则，我们假设它被以 <code>sum(2)(3)</code>这样的形式调用，所以我们返回一个匿名函数，这个匿名函数合并了传递到 <code>sum()</code>的参数和传递给匿名函数的参数。</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y) &#123;</span><br><span class="line">  if (y !== undefined) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function(y) &#123; return x + y; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用一个函数的时候，JavaScript不要求参数的数目匹配函数定义中的参数数量。如果传递的参数数量大于函数定义中参数数量，那么多余参数将简单地被忽略。另一方面，如果传递的参数数量小于函数定义中的参数数量，那么缺少的参数在函数中被引用时将会给一个 <code>undefined</code>值。所以，在上面的例子中，简单地检查第2个参数是否未定义，就可以相应地确定函数被调用以及进行的方式。</p>
<h3 id="分析下题输出结果"><a href="#分析下题输出结果" class="headerlink" title="分析下题输出结果"></a>分析下题输出结果</h3><h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = &quot;john&quot;.split(&apos;&apos;);</span><br><span class="line">console.log(&apos;arr1&apos;,arr1);//arr1 [ &apos;j&apos;, &apos;o&apos;, &apos;h&apos;, &apos;n&apos; ]</span><br><span class="line">var arr2 = arr1.reverse();</span><br><span class="line">console.log(&apos;2arr1&apos;,arr1);//2arr1 [ &apos;n&apos;, &apos;h&apos;, &apos;o&apos;, &apos;j&apos; ]</span><br><span class="line">console.log(&apos;arr2&apos;,arr2);//arr2 [ &apos;n&apos;, &apos;h&apos;, &apos;o&apos;, &apos;j&apos; ]</span><br><span class="line">var arr3 = &quot;jones&quot;.split(&apos;&apos;);</span><br><span class="line">console.log(&apos;arr3&apos;,arr3);//arr3 [ &apos;j&apos;, &apos;o&apos;, &apos;n&apos;, &apos;e&apos;, &apos;s&apos; ]</span><br><span class="line">arr2.push(arr3);</span><br><span class="line">console.log(&apos;2arr2&apos;,arr2);//2arr2 [ &apos;n&apos;, &apos;h&apos;, &apos;o&apos;, &apos;j&apos;, [ &apos;j&apos;, &apos;o&apos;, &apos;n&apos;, &apos;e&apos;, &apos;s&apos; ] ]</span><br><span class="line"></span><br><span class="line">console.log(arr1,arr2)</span><br><span class="line">// [ &apos;n&apos;, &apos;h&apos;, &apos;o&apos;, &apos;j&apos;, [ &apos;j&apos;, &apos;o&apos;, &apos;n&apos;, &apos;e&apos;, &apos;s&apos; ] ] [ &apos;n&apos;, &apos;h&apos;, &apos;o&apos;, &apos;j&apos;, [ &apos;j&apos;, &apos;o&apos;, &apos;n&apos;, &apos;e&apos;, &apos;s&apos; ] ]</span><br><span class="line"></span><br><span class="line">console.log(&quot;array 1: length=&quot; + arr1.length + &quot; last=&quot; + arr1.slice(-1));</span><br><span class="line">console.log(&quot;array 2: length=&quot; + arr2.length + &quot; last=&quot; + arr2.slice(-1));</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line"></span><br><span class="line">&quot;array 1: length=5 last=j,o,n,e,s&quot;</span><br><span class="line">&quot;array 2: length=5 last=j,o,n,e,s&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组属于引用类型，直接赋值，赋的是引用</li>
<li>split() 方法用于把一个字符串分割成字符串数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.split(separator,howmany)</span><br></pre></td></tr></table></figure>

<p><code>separator</code>:必需。字符串或正则表达式，从该参数指定的地方分割 <code>stringObject</code>。</p>
<p><code>howmany</code>:可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</p>
<ul>
<li>slice() 方法可从已有的数组中返回选定的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure>

<p><code>start</code>:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。</p>
<p><code>end</code>:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从<code>start</code>到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  &quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 +  +&quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 +  -&quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + 2);</span><br></pre></td></tr></table></figure>

<p>上面的代码将输出以下内容到控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;122&quot;</span><br><span class="line">&quot;32&quot;</span><br><span class="line">&quot;02&quot;</span><br><span class="line">&quot;112&quot;</span><br><span class="line">&quot;NaN2&quot;</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<p>这里的根本问题是，JavaScript（ECMAScript）是一种弱类型语言，它可对值进行自动类型转换，以适应正在执行的操作。让我们通过上面的例子来说明这是如何做到的。</p>
<p>例1：<code>1 + &quot;2&quot; + &quot;2&quot;</code> 输出：<code>&quot;122&quot;</code> 说明： <code>1 + &quot;2&quot;</code> 是执行的第一个操作。由于其中一个运算对象（<code>&quot;2&quot;</code>）是字符串，JavaScript会假设它需要执行字符串连接，因此，会将 <code>1</code> 的类型转换为 <code>&quot;1&quot;</code>， <code>1 + &quot;2&quot;</code>结果就是 <code>&quot;12&quot;</code>。然后， <code>&quot;12&quot; + &quot;2&quot;</code> 就是 <code>&quot;122&quot;</code>。</p>
<p>例2： <code>1 + +&quot;2&quot; + &quot;2&quot;</code> 输出： <code>&quot;32&quot;</code> 说明：根据运算的顺序，要执行的第一个运算是 <code>+&quot;2&quot;</code>（第一个 <code>&quot;2&quot;</code> 前面的额外 <code>+</code> 被视为一元运算符）。因此，JavaScript将 <code>&quot;2&quot;</code> 的类型转换为数字，然后应用一元 <code>+</code> 号（即，将其视为一个正数）。其结果是，接下来的运算就是 <code>1 + 2</code> ，这当然是 <code>3</code>。然后我们需要在一个数字和一个字符串之间进行运算（即， <code>3</code> 和 <code>&quot;2&quot;</code>），同样的，JavaScript会将数值类型转换为字符串，并执行字符串的连接，产生 <code>&quot;32&quot;</code>。</p>
<p>例3： <code>1 + -&quot;1&quot; + &quot;2&quot;</code> 输出： <code>&quot;02&quot;</code>  说明：这里的解释和前一个例子相同，除了此处的一元运算符是 <code>-</code> 而不是 <code>+</code>。先是 <code>&quot;1&quot;</code> 变为 <code>1</code>，然后当应用 <code>-</code> 时又变为了 <code>-1</code> ，然后将其与 <code>1</code>相加，结果为 <code>0</code>，再将其转换为字符串，连接最后的 <code>&quot;2&quot;</code> 运算对象，得到 <code>&quot;02&quot;</code>。</p>
<p>例4： <code>+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;</code> 输出： <code>&quot;112&quot;</code> 说明：虽然第一个运算对象 <code>&quot;1&quot;</code>因为前缀的一元 <code>+</code> 运算符类型转换为数值，但又立即转换回字符串，当连接到第二个运算对象 <code>&quot;1&quot;</code> 的时候，然后又和最后的运算对象<code>&quot;2&quot;</code> 连接，产生了字符串 <code>&quot;112&quot;</code>。</p>
<p>例5： <code>&quot;A&quot; - &quot;B&quot; + &quot;2&quot;</code> 输出： <code>&quot;NaN2&quot;</code> 说明：由于运算符 <code>-</code>  不能被应用于字符串，并且 <code>&quot;A&quot;</code> 和 <code>&quot;B&quot;</code> 都不能转换成数值，因此，<code>&quot;A&quot; - &quot;B&quot;</code>的结果是 <code>NaN</code>，然后再和字符串 <code>&quot;2&quot;</code> 连接，得到 <code>&quot;NaN2&quot;</code> 。</p>
<p>例6： <code>&quot;A&quot; - &quot;B&quot; + 2</code> 输出： <code>NaN</code> 说明：参见前一个例子， <code>&quot;A&quot; - &quot;B&quot;</code> 结果为 <code>NaN</code>。但是，应用任何运算符到NaN与其他任何的数字运算对象，结果仍然是 <code>NaN</code>。</p>
<h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h5><p>下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();</span><br><span class="line"> </span><br><span class="line">var nextListItem = function() &#123;</span><br><span class="line">    var item = list.pop();</span><br><span class="line"> </span><br><span class="line">    if (item) &#123;</span><br><span class="line">        // process the list item...</span><br><span class="line">        nextListItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>潜在的堆栈溢出可以通过修改<code>nextListItem</code> 函数避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();</span><br><span class="line"> </span><br><span class="line">var nextListItem = function() &#123;</span><br><span class="line">    var item = list.pop();</span><br><span class="line"> </span><br><span class="line">    if (item) &#123;</span><br><span class="line">        // process the list item...</span><br><span class="line">        setTimeout( nextListItem, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>堆栈溢出之所以会被消除，是因为事件循环操纵了递归，而不是调用堆栈。当 <code>nextListItem</code> 运行时，如果 <code>item</code>不为空，timeout函数（<code>nextListItem</code>）就会被推到事件队列，该函数退出，因此就清空调用堆栈。当事件队列运行其timeout事件，且进行到下一个 <code>item</code> 时，定时器被设置为再次调用 <code>nextListItem</code>。因此，该方法从头到尾都没有直接的递归调用，所以无论迭代次数的多少，调用堆栈保持清空的状态。</p>
<h5 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  (function()&#123;  </span><br><span class="line">        setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );</span><br><span class="line">   &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不会按预期显示值0，1，2，3，和4，而是会显示5，5，5，5，和5。</p>
<p>原因是，在循环中执行的每个函数将整个循环完成之后被执行，因此，将会引用存储在 <code>i</code>中的最后一个值，那就是5。</p>
<p>闭包可以通过为每次迭代创建一个唯一的范围，存储范围内变量的每个唯一的值，来防止这个问题，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">	(function(x) &#123;</span><br><span class="line">    	setTimeout(function() &#123; console.log(x); &#125;, x * 1000 );</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就会按预期输出0，1，2，3，和4到控制台。</p>
<h5 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&#125;,</span><br><span class="line">    b=&#123;key:&apos;b&apos;&#125;,</span><br><span class="line">    c=&#123;key:&apos;c&apos;&#125;;</span><br><span class="line"> </span><br><span class="line">a[b]=123;</span><br><span class="line">a[c]=456;</span><br><span class="line"> </span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure>

<p>这段代码将输出 <code>456</code>（而不是 <code>123</code>）。</p>
<p>原因为：当设置对象属性时，JavaScript会隐式的将[]内的变量转换成字符串。在这种情况下，由于 <code>b</code> 和 <code>c</code>都是对象，因此它们都将被转换为<code>&quot;[object Object]&quot;</code>。结果就是， <code>a[b]</code>和<code>a[c]</code>均相当于<code>a[&quot;[object Object]&quot;]</code> ，并可以互换使用。因此，设置或引用<code>a[c]</code>和设置或引用 <code>a[b]</code>完全相同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/attribute和property/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/21/attribute和property/" itemprop="url">attribute和property</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-21T10:12:50+08:00">
                2020-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/elcarim5efil/p/4698980.html" target="_blank" rel="noopener">参考</a></p>
<p>property 和 attribute非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。</p>
<ul>
<li><code>property</code>是DOM的属性，是JavaScript里的对象</li>
<li><code>attribute</code>是HTML标签上的特性，它的值只能够是字符串</li>
</ul>
<p>结论：</p>
<ul>
<li><p>DOM有其默认的基本属性，而这些属性就是所谓的  <code>property</code>，无论如何，它们都会在初始化的时候在DOM对象上创建。</p>
</li>
<li><p>HTML标签上定义的属性和值会保存在该DOM对象的 <code>attribute</code>属性里面</p>
</li>
<li><p><code>property</code>能够从 <code>attribute</code>中得到同步（改变<code>attribute</code>中的值，<code>property</code>中也会改变）</p>
</li>
<li><p><code>attribute</code>不会同步 <code>property</code>上的值（改变<code>property</code>的值，<code>attribute</code>不会改变）</p>
</li>
<li><p><code>attribute</code>和 <code>property</code>之间的数据绑定是单向的， <code>attribute-&gt;property</code></p>
</li>
<li><p>更改 <code>property</code>和 <code>attribute</code>上的任意值，都会将更新反映到HTML页面上</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/事件委托（事件代理）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/20/事件委托（事件代理）/" itemprop="url">事件委托（事件代理）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T21:18:59+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>事件委托就是利用事件冒泡处理动态元素事件绑定的方法。</p>
<p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>js中事件冒泡我们知道，子元素身上的事件会冒泡到父元素身上。</p>
<p>事件代理就是，本来加在子元素身上的事件，加在了其父级身上。</p>
<p>那就产生了问题：父级那么多子元素，怎么区分事件本应该是哪个子元素的？</p>
<p>答案是：event对象里记录的有“事件源”，它就是发生事件的子元素。</p>
<p>它存在兼容性问题，在老的IE下，事件源是 window.event.srcElement，其他浏览器是 event.target</p>
<p>用事件委托有什么好处呢？</p>
<p>第一个好处是效率高，比如，不用for循环为子元素添加事件了</p>
<p>第二个好处是，js新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便。</p>
<h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>DOM需要事件处理程序，那么我们直接添加，但是如果我们有多个DOM节点需要相同的事件呢，如果循环将会影响性能，这时候就可以使用事件委托。</p>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
<p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。</p>
<p>比如下面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好</p>
<p>使用事件委托技术能避免对每个元素添加事件监听器。相反，把事件监听器添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到它们是哪个子元素的事件。也就是说，把监听在子元素上的事件监听函数放到它的父元素上，这样新添加的子元素仍然可以执行事件回调函数。</p>
<p>事件委托的三大优势：减少事件数量、避免内存泄露、预测未来元素。</p>
<h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p>事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p>
<h3 id="事件委托的实现"><a href="#事件委托的实现" class="headerlink" title="事件委托的实现"></a>事件委托的实现</h3><h5 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h5><p>页面有个ul包含着4个li，鼠标移动到li上，li背景变成红色，移出，背景恢复原色。</p>
<p>不使用事件代理的情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">            &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var oUl = document.getElementById(&apos;ul1&apos;);</span><br><span class="line">        var aLi = oUl.children;</span><br><span class="line">        console.log(aLi);</span><br><span class="line">        //传统方法，li身上添加事件，需要用for循环，找到每个li</span><br><span class="line">        for (var i=0;i&lt;aLi.length;i++) &#123;</span><br><span class="line">            aLi[i].onmouseover = function() &#123;</span><br><span class="line">                this.style.background = &apos;red&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            aLi[i].onmouseout = function()&#123;</span><br><span class="line">                this.style.background = &apos;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//for结束</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用事件代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&apos;ul1&apos;);      </span><br><span class="line">    oUl.onmouseover = function(ev)&#123;</span><br><span class="line">        var ev = ev || window.event;</span><br><span class="line">        var oLi = ev.srcElement || ev.target;</span><br><span class="line">        oLi.style.background = &apos;red&apos;;              </span><br><span class="line">    &#125;</span><br><span class="line">    oUl.onmouseout = function(ev)&#123;</span><br><span class="line">        var ev = ev || window.event;</span><br><span class="line">        var oLi = ev.srcElement || ev.target;</span><br><span class="line">        oLi.style.background = &apos;&apos;;                </span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但是会发现，鼠标移到了ul身上而不是某个li身上时，获取的事件源是ul，那么整个ul背景将变红，这不是想要的结果，怎么办？</p>
<p>答曰：加个判断。通过事件源的nodeName判断是不是li，是才做出反应，不是不理它。为了防止nodeName在不同浏览器获取的字母大小写不同，加个toLowerCase()</p>
<p>所以，上面的js代码更改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&apos;ul1&apos;);</span><br><span class="line">    oUl.onmouseover = function(ev)&#123;</span><br><span class="line">        var ev = ev || window.event;</span><br><span class="line">        var oLi = ev.srcElement || ev.target;</span><br><span class="line">        if(oLi.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">            oLi.style.background = &apos;red&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">    oUl.onmouseout = function(ev)&#123;</span><br><span class="line">        var ev = ev || window.event;</span><br><span class="line">        var oLi = ev.srcElement || ev.target;</span><br><span class="line">        if(oLi.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">            oLi.style.background = &apos;&apos;;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h5><p>定我们有一个UL元素，它有几个子元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;parent-list&quot;&gt;</span><br><span class="line">       &lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;</span><br><span class="line">       &lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;</span><br><span class="line">       &lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;</span><br><span class="line">       &lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;</span><br><span class="line">       &lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;</span><br><span class="line">       &lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>我们还假设，当每个子元素被点击时，将会有各自不同的事件发生。你可以给每个独立的li元素添加事件监听器，但有时这些li元素可能会被删除，可能会有新增，监听它们的新增或删除事件将会是一场噩梦，尤其是当你的监听事件的代码放在应用的另一个地方时。但是，如果你将监听器安放到它们的父元素上呢？你如何能知道是那个子元素被点击了？</p>
<p>简单：当子元素的事件冒泡到父ul元素时，你可以检查事件对象的target属性，捕获真正被点击的节点元素的引用。下面是一段很简单的JavaScript代码，演示了事件委托的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 找到父元素，添加监听器...</span><br><span class="line">    document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123;</span><br><span class="line">        // e.target是被点击的元素!</span><br><span class="line">        // 如果被点击的是li元素</span><br><span class="line">        if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123;</span><br><span class="line">            // 找到目标，输出ID!</span><br><span class="line">            console.log(&quot;List item &quot;,e.target.id.replace(&quot;post-&quot;,&apos;&apos;),&quot; was clicked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>一步是给父元素添加事件监听器。当有事件触发监听器时，检查事件的来源，排除非li子元素事件。如果是一个li元素，我们就找到了目标！如果不是一个li元素，事件将被忽略。这个例子非常简单，UL和li是标准的父子搭配。让我们试验一些差异比较大的元素搭配。假设我们有一个父元素div，里面有很多子元素，但我们关心的是里面的一个带有”classA” CSS类的A标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获得父元素DIV, 添加监听器...</span><br><span class="line">    document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;,function(e) &#123;</span><br><span class="line">        // e.target是被点击的元素</span><br><span class="line">        if(e.target &amp;&amp; e.target.nodeName == &quot;A&quot;) &#123;</span><br><span class="line">            // 获得CSS类名</span><br><span class="line">            var classes = e.target.className.split(&quot; &quot;);</span><br><span class="line">                // 搜索匹配!</span><br><span class="line">                if(classes) &#123;</span><br><span class="line">                    // For every CSS class the element has...</span><br><span class="line">                    for(var x = 0; x &lt; classes.length; x++) &#123;</span><br><span class="line">                        // If it has the CSS class we want...</span><br><span class="line">                        if(classes[x] == &quot;classA&quot;) &#123;</span><br><span class="line">                            // Bingo!</span><br><span class="line">                            console.log(&quot;Anchor element clicked!&quot;);</span><br><span class="line">                            // Now do something here....</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上面这个例子中不仅比较了标签名，而且比较了CSS类名。虽然稍微复杂了一点，但还是很具代表性的。比如，如果某个A标记里有一个span标记，则这个span将会成为target元素。这个时候，我们需要上溯DOM树结构，找到里面是否有一个 A.classA 的元素。</p>
<h5 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">            var Add = document.getElementById(&quot;add&quot;);</span><br><span class="line">            var Remove = document.getElementById(&quot;remove&quot;);</span><br><span class="line">            var Move = document.getElementById(&quot;move&quot;);</span><br><span class="line">            var Select = document.getElementById(&quot;select&quot;);</span><br><span class="line">            </span><br><span class="line">            Add.onclick = function()&#123;</span><br><span class="line">                alert(&apos;添加&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Remove.onclick = function()&#123;</span><br><span class="line">                alert(&apos;删除&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Move.onclick = function()&#123;</span><br><span class="line">                alert(&apos;移动&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Select.onclick = function()&#123;</span><br><span class="line">                alert(&apos;选择&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上边的例子，四个按钮完成四个不同的操作，至少需要四次dom操作，如果运用事件委托能优化吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">            var oBox = document.getElementById(&quot;box&quot;);</span><br><span class="line">            oBox.onclick = function (ev) &#123;</span><br><span class="line">                var ev = ev || window.event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;)&#123;</span><br><span class="line">                    switch(target.id)&#123;</span><br><span class="line">                        case &apos;add&apos; :</span><br><span class="line">                            alert(&apos;添加&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;remove&apos; :</span><br><span class="line">                            alert(&apos;删除&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;move&apos; :</span><br><span class="line">                            alert(&apos;移动&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;select&apos; :</span><br><span class="line">                            alert(&apos;选择&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>事件委托仅仅操作一次dom就完成了，比上边的性能肯定要好一些。</p>
<h3 id="事件委托的优点"><a href="#事件委托的优点" class="headerlink" title="事件委托的优点"></a>事件委托的优点</h3><p>事件委托技术可以避免对没个子元素添加监听器，减少操作DOM节点的次数，从而减少浏览器的重排和重绘，提高代码的性能</p>
<p>使用委托事件，只有父元素与DOM存在交互，其他的操作都是在JS虚拟内存中完成的，这样大大提高了性能。</p>
<p>当新添加或者删除子元素节点时，响应的事件可以自动添加或删除，不需要在写程序进行添加或删除。</p>
<h3 id="事件委托三部曲"><a href="#事件委托三部曲" class="headerlink" title="事件委托三部曲"></a>事件委托三部曲</h3><p>第一步：给父元素绑定事件<br>给元素ul添加绑定事件，通过addEventListener为点击事件click添加绑定</p>
<p>第二步：监听子元素的冒泡事件<br>这里默认是冒泡，点击子元素li会向上冒泡</p>
<p>第三步：找到是哪个子元素的事件</p>
<p>通过匿名回调函数的参数e用来接收事件对象，通过target获取触发事件的目标</p>
<p>另外，event.currentTarget 指向的是监听器直接绑定的那个元素，而 event.target 指向的是我们点击的那个元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/事件系统、事件流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/14/事件系统、事件流/" itemprop="url">事件系统、事件流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T21:10:31+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、什么是事件系统"><a href="#一、什么是事件系统" class="headerlink" title="一、什么是事件系统"></a>一、什么是事件系统</h3><p>JavaScript和HTML之间的交互是通过事件来实现的。事件，就是文档或浏览器窗口之间发生的一些交互瞬间。可以使用侦听器（或处理程序）来监听事件，以便事情发生时执行相应的代码。</p>
<p>一个完整的事件系统，通常存在以下三个角色：</p>
<ul>
<li>事件对象:用于储存事件的状态。</li>
<li>事件源对象:当前事件在操作的对象，如元素节点，文档对象，window对象，XMLHttpRequest对象等。</li>
<li>事件监听器：当一个事件源生成一个事件对象时，它会调用相应的回调函数进行操作。在IE中，事件对象恒为全局属性window.event的分身。</li>
</ul>
<p>通俗点讲，事件源对象相当于”当事人“，事件监听器相当于”监护人“，事件对象相当于”事故详情“。一个事件可以理解为，当事人出了点事，至于什么事情（被打了，还是被抢了）都记录在事故详情里，监护人根据事故详情得做出点反应（回调函数）。</p>
<h3 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h3><p>事件流描述的就是从页面中接受事件的顺序。但有意思的是，IE和Netscape团队提出了几乎完全相反的事件流概念。IE的事件流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。</p>
<h4 id="2-1-事件冒泡流与事件捕获流"><a href="#2-1-事件冒泡流与事件捕获流" class="headerlink" title="2.1 事件冒泡流与事件捕获流"></a>2.1 事件冒泡流与事件捕获流</h4><p>事件冒泡流：事件开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。（由内及外）</p>
<p>事件捕获流：由不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件。（由外及内）</p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpS2oq.png" alt="image"></p>
<p>注意:</p>
<ol>
<li>所有现代浏览器都支持事件冒泡，但在具体实现中略有差别。IE5.5及更早版本中事件冒泡会跳过<html>元素(从body直接跳到document)。IE9、Firefox、Chrome、和Safari则将事件一直冒泡到window对象。</html></li>
<li>IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。</li>
<li>由于老版本浏览器不支持，很少有人使用事件捕获。建议使用事件冒泡。有特殊情况再使用捕获。</li>
</ol>
<h4 id="2-2-DOM2级事件流"><a href="#2-2-DOM2级事件流" class="headerlink" title="2.2 DOM2级事件流"></a>2.2 DOM2级事件流</h4><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。如图所示：</p>
<p><img src="https://s1.ax1x.com/2020/04/14/Jp9ZU1.png" alt="image"></p>
<p>捕获阶段：实际目标( &lt; div&gt;元素)在捕获阶段不会接收事件，意思是事件从 [ document-&gt;html-&gt;body ] 后就停止了。【1、2、3】</p>
<p>目标阶段：事件在目标元素上发生。但事件处理被看作是冒泡阶段的一部分。</p>
<p>冒泡阶段：从目标元素开始处理事件，一直传播到文档。也就是 [ div-&gt;body-&gt;html-&gt;document  ]【4、5、6、7】</p>
<p>注意：</p>
<ol>
<li>“DOM2级事件”规范明确要求捕获阶段不会涉及实际目标的事件，但IE9、Chrome、Firefox、Safari和Opera9.5及更高版本都会在捕获阶段触发实际目标上的事件。结果，<strong>目标对象上的事件就会执行两次</strong>！</li>
<li>并非所有的事件都会有冒泡阶段。但所有的事件都会经过捕获阶段和处于目标阶段。eg:跳过冒泡阶段的事件：获得输入焦点的focus事件和失去输入焦点的blur事件。</li>
</ol>
<h3 id="三、事件处理程序"><a href="#三、事件处理程序" class="headerlink" title="三、事件处理程序"></a>三、事件处理程序</h3><p>事件就是用户或浏览器自身执行的某种动作。如 click、load 和 mouseover、mousedown 等</p>
<p>响应某个事件的函数叫做事件处理程序（或事件侦听器）。click事件的事件处理程序是onclick，load事件的事件处理程序就是onload。为事件指定处理程序的方式有有好几种。如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/04/14/JpChfP.png" alt="image"></p>
<p>注意：由于HTML事件处理程序中HTML和JavaScript紧密耦合，所以已被大多程序员摒弃。<br>所谓跨浏览器事件处理程序，就是把HTML、DOM0、DOM2、IE的事件处理程序进行封装。</p>
<h4 id="3-1-HTML事件处理程序-addEventListener-type-listener-useCapture"><a href="#3-1-HTML事件处理程序-addEventListener-type-listener-useCapture" class="headerlink" title="3.1 HTML事件处理程序:addEventListener(type, listener[, useCapture]);"></a>3.1 HTML事件处理程序:addEventListener(type, listener[, useCapture]);</h4><p>某个元素支持每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是可以执行的JavaScript代码。</p>
<p>示例代码（3种）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方法一 --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&apos;clicked!&apos;)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二  如果单双引号不能叉开使用，必要时可以使用转义后的HTML语法字符 --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;clicked!&amp;quot;)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法三 --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;showMessage()&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function showMessage()&#123;</span><br><span class="line">        alert(&apos;clicked!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其实事件每发生一次，就会创建一个封装着事件相关信息的函数，这个函数中有一个局部变量event，也就是事件对象（稍后介绍）。通过event变量，我们就可以直接访问事件对象，而不用自己定义，也不用从函数的参数列表中读取。同时，我们也可以通过这个事件对象获取目标元素。</p>
<p>获取目标元素3种方式，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方法一 IE9、Firefox、chrome、Opera、safari支持（IE8及其以下不支持） --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.target)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二 主要是为了IE8以下兼容，同时其他高级浏览器也还支持 --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(event.srcElement)&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二  JavaScript中的this比较乱，如果不是很清楚，建议慎用--&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;console.log(this)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>HTML事件处理程序的缺点：</p>
<ul>
<li>时差问题：用户可能在HTML元素一出现在页面上就触发事件，此时事件处理程序有可能尚不具备执行条件。解决办法，try-catch 。</li>
<li>耦合度问题：HTML代码与JavaScript代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML代码和JavaScript代码。</li>
</ul>
<p>优点：</p>
<ul>
<li>简洁</li>
<li>处理事件的 this关键字指向当前元素</li>
</ul>
<h4 id="3-2-DOM0级事件处理程序"><a href="#3-2-DOM0级事件处理程序" class="headerlink" title="3.2 DOM0级事件处理程序"></a>3.2 DOM0级事件处理程序</h4><p>通过JavaScript指定事件处理程序，就是将一个函数赋值为一个事件处理程序属性（eg: 赋值给 onclick ）。</p>
<p>以这种方式添加的事件，会在事件流的冒泡阶段被处理。</p>
<p>优点：所有浏览器支持，简单，跨浏览器支.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;clicker&quot; id=&quot;clicker&quot; value=&quot;点击&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var clicker = document.getElementById(&quot;clicker&quot;);</span><br><span class="line">    clicker.onclick = function()&#123;</span><br><span class="line">        console.log(&quot;点击了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>缺点：绑定事件不能累加，最后绑定的会覆盖之前的。（DOM2级事件处理程序解决了这个问题，稍后详解）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;clicker&quot; id=&quot;clicker&quot; value=&quot;点击&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var clicker = document.getElementById(&quot;clicker&quot;);</span><br><span class="line">    clicker.onclick = function()&#123;</span><br><span class="line">        aler(&quot;第一次点击！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    clicker.onclick = function()&#123;</span><br><span class="line">        alert(&quot;第二次点击！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>只会弹出第二次点击，而不会显示第一次的。</p>
<p>也可以删除通过DOM0级方法指定的事件处理程序，就是将事件处理程序设置为null。</p>
<p>设置之后，再点击就不会有任何动作发生。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clicker.onclick = null;</span><br></pre></td></tr></table></figure>

<p>注意：使用HTML事件处理程序指定的程序，可以被DOM0级事件处理程序覆盖，也可以以同样方式删除。</p>
<h4 id="3-3-DOM2级事件处理程序"><a href="#3-3-DOM2级事件处理程序" class="headerlink" title="3.3 DOM2级事件处理程序"></a>3.3 DOM2级事件处理程序</h4><p>DOM2级事件定义了两个方法，用于处理和删除指定的事件处理程序。</p>
<p>添加事件：addEventListener()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 参数意义</span><br><span class="line"> * target 目标元素</span><br><span class="line"> * type 表示监听事件类型的字符串。</span><br><span class="line"> * listener 事件的处理程序，</span><br><span class="line"> * (listener 必须是一个实现了 EventListener 接口的对象或者函数.当所监听的事件类型触发时，会接收到一个事件通知对象（实现了 Event 接口的对象）</span><br><span class="line"> * useCapture Boolean类型值，默认false,实现事件冒泡。若设置为true，实现事件捕获。</span><br><span class="line"> * */</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>

<p>移除事件： removeEventListener()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 参数意义</span><br><span class="line"> * target 目标元素</span><br><span class="line"> * type 一个字符串，表示需要移除的事件类型，如 &quot;click&quot;。</span><br><span class="line"> * listener 需要移除的 EventListener 函数（先前使用 addEventListener 方法定义的）</span><br><span class="line"> * useCapture 指定需要移除的 EventListener 函数是否为事件捕获。如果无此参数，默认值为 false。</span><br><span class="line"> * */</span><br><span class="line">target.removeEventListener(type, listener[, useCapture])</span><br></pre></td></tr></table></figure>

<p>DOM2级事件处理程序的主要好处是可以添加多个事件处理程序。然后按顺序触发:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;btn&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">    </span><br><span class="line">    btn.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">        console.log(&apos;第一个注册事件执行了！&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    btn.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">        console.log(&apos;第二个注册事件执行了！&apos;);</span><br><span class="line">    &#125;)        </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；</p>
<p>移除时传入的参数和添加时使用的参数相同。</p>
<p>这也意味着添加的匿名函数将无法移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;btn&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">    </span><br><span class="line">    btn.addEventListener(&quot;click&quot;, first, false)</span><br><span class="line">    btn.addEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">        console.log(&apos;第二个注册事件执行了！&apos;);</span><br><span class="line">    &#125;,false)    </span><br><span class="line">    </span><br><span class="line">    //移除事件的参数与addEventListener时的参数相同 ，</span><br><span class="line">    btn.removeEventListener(&quot;click&quot;, first, false);</span><br><span class="line">    //如果是匿名函数，将无法移除</span><br><span class="line">    btn.removeEventListener(&quot;click&quot;, function()&#123;</span><br><span class="line">        console.log(&apos;第二个注册事件执行了！&apos;);</span><br><span class="line">    &#125;,false)</span><br><span class="line">    </span><br><span class="line">    function first()&#123;</span><br><span class="line">        console.log(&apos;第一个注册事件执行了！&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果同一个监听事件分别为“事件捕获”和“事件冒泡”注册了一次，一共两次，这两次事件需要分别移除。两者不会互相干扰。 </li>
<li>为最大限度的兼容各种浏览器，建议将事件处理程序添加到事件流的冒泡阶段</li>
<li>除非特殊需要，否则不建议在事件捕获阶段注册事件处理程序 </li>
</ol>
<h4 id="3-3-IE事件处理程序"><a href="#3-3-IE事件处理程序" class="headerlink" title="3.3 IE事件处理程序"></a>3.3 IE事件处理程序</h4><p>方法：注册事件处理程序 attachEvent() 、 移除事件处理程序 detachEvent()</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attached = target.attachEvent(eventNameWithOn, callback)</span><br></pre></td></tr></table></figure>

<p>区别addEventListener：</p>
<ol>
<li>attachEvent 是非标准的，addEventListener是标准的</li>
<li>attachEvent只有两个参数，第一参数是事件类型（带“on”的，比如click，要写成 “onclick”）、第二个参数写法与addEventListener相同，没有三个参数，IE8及以下版本也不支持事件捕获</li>
<li>事件处理程序中的作用域不同，也就是第二个参数中的this指向不同，DOM0、DOM2事件处理程序会在其元素的作用域内运行，this指向目标元素；而使用attachEvent()方法，事件处理程序会在全局作用域中运行，因此此处this指向window.</li>
</ol>
<p>作用域示例代码 （IE8运行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;clicker&quot;/&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 获取目标元素的引用</span><br><span class="line">    var clicker = document.getElementById(&quot;clicker&quot;);</span><br><span class="line">    // 注册事件处理程序</span><br><span class="line">    clicker.attachEvent(&quot;onclick&quot;, showThis);</span><br><span class="line">    function showThis()&#123;</span><br><span class="line">        alert(this);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-跨浏览器事件处理程序"><a href="#3-4-跨浏览器事件处理程序" class="headerlink" title="3.4 跨浏览器事件处理程序"></a>3.4 跨浏览器事件处理程序</h4><p>事件的绑定、移除:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;clicker&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var clicker = document.getElementById(&quot;clicker&quot;);</span><br><span class="line">    // 兼容代码 </span><br><span class="line">    var handing = &#123;</span><br><span class="line">        addEvent:function(target, type, listener, capture)&#123;</span><br><span class="line">            if (target.addEventListener) &#123;</span><br><span class="line">                target.addEventListener(type, listener, capture);</span><br><span class="line">            &#125;else if(target.attachEvent)&#123;</span><br><span class="line">                target.attachEvent(&quot;on&quot; + type, listener);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                target[&quot;on&quot; + type] = listener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        deleteEvent:function(target, type, listener, capture)&#123;</span><br><span class="line">            if (target.removeEventListener) &#123;</span><br><span class="line">                target.removeEventListener(type, listener, capture);</span><br><span class="line">            &#125; else if(target.detachEvent)&#123;</span><br><span class="line">                target.detachEvent(&quot;on&quot; + type, listener);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                target[&quot;on&quot; + type] = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 注册事件处理程序，须放在兼容代码的下面</span><br><span class="line">    handing.addEvent(clicker, &quot;click&quot;, showMessage, false);</span><br><span class="line">    // 移除事件处理程序 </span><br><span class="line">    handing.deleteEvent(clicker, &quot;click&quot;, showMessage, false);</span><br><span class="line">    function showMessage()&#123;</span><br><span class="line">        alert(this);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="如果HTML事件处理程序、-DOM0级事件处理程序-和DOM2级事件处理程序同时存在？？"><a href="#如果HTML事件处理程序、-DOM0级事件处理程序-和DOM2级事件处理程序同时存在？？" class="headerlink" title="如果HTML事件处理程序、 DOM0级事件处理程序 和DOM2级事件处理程序同时存在？？"></a>如果HTML事件处理程序、 DOM0级事件处理程序 和DOM2级事件处理程序同时存在？？</h3><p>答：HTML事件处理程序与DOM0级事件处理程序不能同时存在，会覆盖。</p>
<p>　　且DOM0级事件处理程序不能累积添加。只执行最后一个添加的事件处理程序</p>
<p>　　DOM2级事件程序不受HTML事件处理程序和DOM0级事件处理程序的影响。遵从先添加先执行的原则，可以累积添加事件。</p>
<h3 id="四、阻止冒泡"><a href="#四、阻止冒泡" class="headerlink" title="四、阻止冒泡"></a>四、阻止冒泡</h3><p>在W3C中，使用 <code>stopPropagation（）</code>方法</p>
<p>在IE下设置 <code>cancelBubble=true</code></p>
<h3 id="五、阻止捕获"><a href="#五、阻止捕获" class="headerlink" title="五、阻止捕获"></a>五、阻止捕获</h3><p>在W3C中，使用 <code>preventDefault（）</code>方法</p>
<p>在IE下设置 <code>window.event.returnValue=false</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/14/CORS/" itemprop="url">CORS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T19:52:02+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h3 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h3 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h3><h4 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为<code>HTTP</code>回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与<code>CORS</code>请求相关的字段，都以<code>Access-Control</code>-开头。</p>
<p>（1）<code>Access-Control-Allow-Origin</code></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p>（2）<code>Access-Control-Allow-Credentials</code></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p>
<p>（3）<code>Access-Control-Expose-Headers</code></p>
<p>该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma。</li>
</ul>
<p>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h4 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h4><p>上面说到，<code>CORS</code>请求默认不发送<code>Cookie</code>和<code>HTTP</code>认证信息。如果要把<code>Cookie</code>发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<p>另一方面，开发者必须在<code>AJAX</code>请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器同意发送<code>Cookie</code>，浏览器也不会发送。或者，服务器要求设置<code>Cookie</code>，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送<code>Cookie</code>。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p>
<h3 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h3><h4 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>HTTP</code>请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的<code>HTTP</code>头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p>
<p>（1）<code>Access-Control-Request-Method</code></p>
<p>该字段是必须的，用来列出浏览器的<code>CORS</code>请求会用到哪些<code>HTTP</code>方法，上例是<code>PUT</code>。</p>
<p>（2）<code>Access-Control-Request-Headers</code></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器<code>CORS</code>请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h4 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h4><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>如果服务器否定了”预检”请求，会返回一个正常的<code>HTTP</code>回应，但是没有任何<code>CORS</code>相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>

<p>服务器回应的其他CORS相关字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>

<p>（1）<code>Access-Control-Allow-Methods</code></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p>（2）<code>Access-Control-Allow-Headers</code></p>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p>（3）<code>Access-Control-Allow-Credentials</code></p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）<code>Access-Control-Max-Age</code></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h4 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h4><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一<code>个Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h3 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h3><ul>
<li><code>CORS</code>与<code>JSONP</code>的使用目的相同，但是比<code>JSONP</code>更强大。</li>
<li><code>JSONP</code>只支持<code>GET</code>请求，<code>CORS</code>支持所有类型的<code>HTTP</code>请求。<code>JSONP</code>的优势在于支持老式浏览器，以及可以向不支持<code>CORS</code>的网站请求数据。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/同源策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/14/同源策略/" itemprop="url">同源策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T18:42:05+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="同源的含义"><a href="#同源的含义" class="headerlink" title="同源的含义"></a>同源的含义</h3><ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<h3 id="同源的目的"><a href="#同源的目的" class="headerlink" title="同源的目的"></a>同源的目的</h3><p>浏览器安全的基石是”同源政策”。</p>
<p>保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 <code>Cookie</code>，会发生什么？</p>
<p>很显然，如果<code>Cookie</code> 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，<code>Cookie</code> 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制：</p>
<ul>
<li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取。</li>
<li><code>DOM</code> 无法获得。</li>
<li><code>AJAX</code>请求不能发送。</li>
</ul>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面将详细介绍，如何规避上面三种限制。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h5 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h5><p><code>Cookie</code>是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 <code>Cookie</code>。</p>
<p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享<code>Cookie</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;example.com&apos;;</span><br></pre></td></tr></table></figure>

<p>现在，A网页通过脚本设置一个 <code>Cookie</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;test1=hello&quot;;</span><br></pre></td></tr></table></figure>

<p>B网页就可以读到这个 <code>Cookie</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var allCookie = document.cookie;</span><br></pre></td></tr></table></figure>

<p>注意，这种方法只适用于 <code>Cookie</code> 和 <a href="https://www.w3school.com.cn/html/html_iframe.asp" target="_blank" rel="noopener">iframe</a> 窗口，<code>LocalStorage</code> 和 <code>IndexDB</code> 无法通过这种方法，规避同源政策，而要使用下文介绍的<code>PostMessage API</code>。</p>
<h5 id="服务器指定-cookie-所属域名"><a href="#服务器指定-cookie-所属域名" class="headerlink" title="服务器指定 cookie 所属域名"></a>服务器指定 <code>cookie</code> 所属域名</h5><p>服务器也可以在设置<code>Cookie</code>的时候，指定<code>Cookie</code>的所属域名为一级域名，比如<code>.example.com</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure>

<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个<code>Cookie</code>。</p>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>如果两个网页不同源，就无法拿到对方的<code>DOM</code>。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;myIFrame&quot;).contentWindow.document</span><br><span class="line">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span><br></pre></td></tr></table></figure>

<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.parent.document.body</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure>

<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到<code>DOM</code>。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题:</p>
<ul>
<li>片段识别符（<code>fragment identifier</code>）</li>
<li><code>window.name</code></li>
<li>跨文档通信API（<code>Cross-document messaging</code>）</li>
</ul>
<h5 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h5><p>片段标识符（<code>fragment identifier</code>）指的是，<code>URL</code>的<code>#</code>号后面的部分，比如 <code>http://example.com/x.html#fragment</code> 的 <code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新</p>
<p>父窗口可以把信息，写入子窗口的片段标识符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var src = originURL + &apos;#&apos; + data;</span><br><span class="line">document.getElementById(&apos;myIFrame&apos;).src = src;</span><br></pre></td></tr></table></figure>

<p>子窗口通过监听<code>hashchange</code>事件得到通知:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line">function checkMessage() &#123;</span><br><span class="line">  var message = window.location.hash;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，子窗口也可以改变父窗口的片段标识符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href= target + &quot;#&quot; + hash;</span><br></pre></td></tr></table></figure>

<h5 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h5><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.name = data;</span><br></pre></td></tr></table></figure>

<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = &apos;http://parent.url.com/xxx.html&apos;;</span><br></pre></td></tr></table></figure>

<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h5 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h5><p>HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（<code>Cross-document messaging</code>）。</p>
<p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（<code>origin</code>），即”协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</span><br></pre></td></tr></table></figure>

<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  if (event.origin !== &apos;http://aaa.com&apos;) return;</span><br><span class="line">  if (event.data === &apos;Hello World&apos;) &#123;</span><br><span class="line">      event.source.postMessage(&apos;Hello&apos;, event.origin);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>通过<code>window.postMessage</code>，读写其他窗口的 <code>LocalStorage</code> 也成为了可能。</p>
<p>下面是一个例子，主窗口写入<code>iframe</code>子窗口的<code>localStorage</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onmessage = function(e) &#123;</span><br><span class="line">  if (e.origin !== &apos;http://bbb.com&apos;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  var payload = JSON.parse(e.data);</span><br><span class="line">  localStorage.setItem(payload.key, JSON.stringify(payload.data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口将父窗口发来的消息，写入自己的<code>LocalStorage</code>。</p>
<p>父窗口发送消息的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;</span><br><span class="line">var obj = &#123; name: &apos;Jack&apos; &#125;;</span><br><span class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure>

<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.onmessage = function(e) &#123;</span><br><span class="line">  if (e.origin !== &apos;http://bbb.com&apos;) return;</span><br><span class="line">  var payload = JSON.parse(e.data);</span><br><span class="line">  switch (payload.method) &#123;</span><br><span class="line">    case &apos;set&apos;:</span><br><span class="line">      localStorage.setItem(payload.key, JSON.stringify(payload.data));</span><br><span class="line">      break;</span><br><span class="line">    case &apos;get&apos;:</span><br><span class="line">      var parent = window.parent;</span><br><span class="line">      var data = localStorage.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, &apos;http://aaa.com&apos;);</span><br><span class="line">      break;</span><br><span class="line">    case &apos;remove&apos;:</span><br><span class="line">      localStorage.removeItem(payload.key);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;</span><br><span class="line">var obj = &#123; name: &apos;Jack&apos; &#125;;</span><br><span class="line">// 存入对象</span><br><span class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);</span><br><span class="line">// 读取对象</span><br><span class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);</span><br><span class="line">window.onmessage = function(e) &#123;</span><br><span class="line">  if (e.origin != &apos;http://aaa.com&apos;) return;</span><br><span class="line">  // &quot;Jack&quot;</span><br><span class="line">  console.log(JSON.parse(e.data).name);</span><br></pre></td></tr></table></figure>

<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>同源政策规定，<code>AJAX</code>请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p><code>JSONP</code>是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求<code>JSON</code>数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于<code>JSONP</code>是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的<code>JSON</code>数据被视为<code>JavaScript</code>对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h5 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h5><p><code>WebSocket</code>是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的<code>WebSocket</code>请求的头信息（摘自维基百科）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（<code>origin</code>），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以<code>WebSocket</code>才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p><code>CORS</code>是跨源资源分享（<code>Cross-Origin Resource Sharing</code>）的缩写。它是<code>W3C</code>标准，是跨源<code>AJAX</code>请求的根本解决方法。相比<code>JSONP</code>只能发<code>GET</code>请求，<code>CORS</code>允许任何类型的请求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/异步编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/03/异步编程/" itemprop="url">异步编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-03T10:24:24+08:00">
                2020-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="同步VS异步"><a href="#同步VS异步" class="headerlink" title="同步VS异步"></a>同步VS异步</h3><p>同步，也就是你在执行代码时，他会等待代码返回结果，不管这代码执行多久，只有代码返回结果了然后再代码才会继续往下执行。而异步指的是：我要执行一段代码A，我不等待他出结果，我会为他设置一个处理代码，当A出结果时，直接去调用那个处理代码去处理他，而我本身就不会再去管代码A了，代码会继续往下执行，等到A出结果了，直接让他执行之前设置好的处理代码就行了。比如，前端的请求Ajax接口就是一个异步操作。</p>
<p>所以同步和异步的不同之处就在于处理问题时流程上的不同。同步比较符合人们的线性思维，代码一步一步往下走，不会乱。而异步需要就需要把思维转化为事件驱动的思路上：我要做一件事，只是告诉计算机开始做这件事就行了，然后我就继续去做别的事了，而不是傻傻等着计算机做完。只要让计算机做完了这件事后，告诉我这件事做完了。我才继续回来去处理结果就行了。</p>
<p>所谓异步执行，不同于同步执行（程序的执行顺序与任务的排列顺序是一致的、同步的），每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的。</p>
<p>所以我的理解就是，当一段代码很耗费时间时，后边代码不需要这段代码的返回结果，但是也要耗费时间等待这段代码的执行，所以将这段代码异步编程，向下执行别的代码，对这段代码结果设置处理的代码(<code>callback</code>)，等出来结果调用处理的代码(<code>callback</code>)就好了。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>这是异步编程最基本的方法。</p>
<p>假定有两个函数<code>f1</code>和<code>f2</code>，后者等待前者的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line">//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。</span><br><span class="line">function f1(callback)&#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行代码就变成下面这样：</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>

<p>采用这种方式，我们把同步操作变成了异步操作，<code>f1</code>不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p>
<p>利用定时器的工作原理将<code>f1</code>放入事件队列中去执行，哪怕延时是0，也是如此，因此不堵塞程序运行。</p>
<p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<h5 id="回调和异步"><a href="#回调和异步" class="headerlink" title="回调和异步"></a>回调和异步</h5><p>注意区分回调函数和异步, 回调并不一定就是异步。他们自己并没有直接关系。 简单区分 同步回调 和 异步回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 同步回调</span><br><span class="line">function fn1(callback)&#123;</span><br><span class="line">    console.log(&apos;我是fn1，我开始执行了！&apos;);</span><br><span class="line">    callback();</span><br><span class="line">    console.log(&apos;我是fn1的小尾巴呀&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2()&#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn1(fn2);</span><br><span class="line">console.log(&apos;这是js尾巴呀！&apos;)</span><br><span class="line">/*</span><br><span class="line">我是fn1，我开始执行了！</span><br><span class="line">2</span><br><span class="line">我是fn1的小尾巴呀</span><br><span class="line">这是js尾巴呀！</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 异步回调</span><br><span class="line"></span><br><span class="line">function fn1(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;我是fn1，我开始执行了！&apos;);</span><br><span class="line">        console.log(&apos;我是fn1的小尾巴呀&apos;);</span><br><span class="line">        callback()</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(fn2)</span><br><span class="line">console.log(&apos;这是非异步的尾巴！&apos;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这是非异步的尾巴！</span><br><span class="line">我是fn1，我开始执行了！</span><br><span class="line">我是fn1的小尾巴呀</span><br><span class="line">2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的jQuery的写法）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&apos;done&apos;, f2);</span><br><span class="line">//上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：</span><br><span class="line"></span><br><span class="line">function f1()&#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        f1.trigger(&apos;done&apos;); //执行完成后，立即触发done事件，从而开始执行f2。</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理也是利用定时器的原理去把f1放入事件队列里，等全部执行完毕之后，才会执行事件队列里的方法</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>上一节的”事件”，完全可以理解成”信号”。</p>
<p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（<code>publish</code>）一个信号，其他任务可以向信号中心”订阅”（<code>subscribe</code>）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（<code>publish-subscribe pattern</code>），又称”观察者模式”（<code>observer pattern</code>）。</p>
<p>这个模式有多种实现，下面采用的是<code>Ben Alman</code>的<code>Tiny Pub/Sub</code>，这是<code>jQuery</code>的一个插件。</p>
<p>首先，<code>f2</code>向”信号中心”<code>jQuery</code>订阅”<code>done</code>“信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&quot;done&quot;, f2);</span><br><span class="line"></span><br><span class="line">// 然后，f1进行如下改写：</span><br><span class="line">function f1()&#123;</span><br><span class="line">　　setTimeout(function () &#123;</span><br><span class="line">　　　　// f1的任务代码</span><br><span class="line">　　　　jQuery.publish(&quot;done&quot;); //f1执行完成后，向&quot;信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。</span><br><span class="line">　　&#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，<code>f2</code>完成执行后，也可以取消订阅（<code>unsubscribe</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(&quot;done&quot;, f2)</span><br></pre></td></tr></table></figure>

<p>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h3><p><code>Promises</code>对象是<code>CommonJS</code>工作组提出的一种规范，目的是为异步编程提供统一接口。</p>
<p>简单说，它的思想是，每一个异步任务返回一个<code>Promise</code>对象，该对象有一个<code>then</code>方法，允许指定回调函数。比如，<code>f1</code>的回调函数<code>f2</code>,可以写成：<code>f1().then(f2)</code>;</p>
<p>f1要进行如下改写（这里使用的是jQuery的实现）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    var dfd = $.Deferred();</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        dfd.resolve();</span><br><span class="line">    &#125;, 500);</span><br><span class="line">    return dfd.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。</p>
<p>比如，指定多个回调函数：<code>f1().then(f2).then(f3)</code>;</p>
<p>再比如，指定发生错误时的回调函数：<code>f1().then(f2).fail(f3)</code>;</p>
<p>　　而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。</p>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener">jQuery</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/js中的内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/02/js中的内存泄漏/" itemprop="url">js中的内存泄漏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-02T11:13:58+08:00">
                2020-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存泄漏是指一块被分配的内存，不再使用，却也没有回收。</p>
<h3 id="js的回收机制"><a href="#js的回收机制" class="headerlink" title="js的回收机制"></a><code>js</code>的回收机制</h3><p>js的垃圾回收机制<code>(GC:garbage collec)</code>有两种方法：标记清除法和引用计数法。其中引用计数法就存在内存泄漏的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function problem() &#123;</span><br><span class="line">    var objA = new Object();</span><br><span class="line">    var objB = new Object();</span><br><span class="line">    objA.someOtherObject = objB;</span><br><span class="line">    objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，<code>objA</code>和<code>onjB</code>通过各自的属性相互引用，他们的引用次数均为1，当<code>problem()</code>执行完的时候，<code>objA</code>和<code>objB</code>就离开了执行环境，不会再被引用，但是他们计数值永远不会为0，内存不会被回收，从而造成内存泄漏问题。</p>
<h3 id="意外的全局变量引起内存泄漏"><a href="#意外的全局变量引起内存泄漏" class="headerlink" title="意外的全局变量引起内存泄漏"></a>意外的全局变量引起内存泄漏</h3><p><code>js</code>中如果不用<code>var</code>声明变量，该变量将会被视为全局对象的属性，也就是全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar = &quot;this is a hidden global variable&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面的函数等价于</span><br><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar = &quot;this is an explicit global variable&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以函数调用完以后，变量仍然存在，导致泄漏。</p>
<h3 id="this引起内存泄漏"><a href="#this引起内存泄漏" class="headerlink" title="this引起内存泄漏"></a><code>this</code>引起内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.variable = &quot;potential accidental global&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有对象调用foo, 也没有给它绑定this, 所以this是window</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>你可以通过加上 <code>&#39;use strict&#39;</code> 启用严格模式来避免这类问题, 严格模式会组织你创建意外的全局变量。</p>
<h3 id="闭包引起内存泄漏"><a href="#闭包引起内存泄漏" class="headerlink" title="闭包引起内存泄漏"></a>闭包引起内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">     var  a = &apos;变量1&apos;</span><br><span class="line">     var  inner = function () &#123;</span><br><span class="line">            console.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    return inner    // inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = ourter()</span><br></pre></td></tr></table></figure>

<p><code>outer()</code>返回值<code>inner()</code>被赋给全局变量<code>a</code>,<code>inner()</code>始终存在与内存中，<code>inner</code>依赖于<code>outer</code>，所以<code>outer</code>不会结束调用，不会被回收。</p>
<h3 id="没有清理的DOM元素引用"><a href="#没有清理的DOM元素引用" class="headerlink" title="没有清理的DOM元素引用"></a>没有清理的<code>DOM</code>元素引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var elements = &#123;</span><br><span class="line">    button: document.getElementById(&apos;button&apos;),</span><br><span class="line">    image: document.getElementById(&apos;image&apos;),</span><br><span class="line">    text: document.getElementById(&apos;text&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    image.src = &apos;http://some.url/image&apos;;</span><br><span class="line">    button.click();</span><br><span class="line">    console.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&apos;button&apos;));</span><br><span class="line">    </span><br><span class="line">    // 虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用</span><br><span class="line">    // 换言之, DOM元素还在内存里面.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="被遗忘的定时器或者回调"><a href="#被遗忘的定时器或者回调" class="headerlink" title="被遗忘的定时器或者回调"></a>被遗忘的定时器或者回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var someResource = getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&apos;Node&apos;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>这样的代码很常见, 如果 <code>id</code> 为 <code>Node</code> 的元素从 <code>DOM</code> 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 <code>someResource</code> 的引用, 定时器外面的 <code>someResource</code> 也不会被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;par&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;Node&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var someResource = &apos;dfas&apos;</span><br><span class="line">        setInterval(function () &#123;</span><br><span class="line">            var node = document.getElementById(&apos;Node&apos;);</span><br><span class="line">            if (node) &#123;</span><br><span class="line">                node.innerHTML = someResource</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&apos;setinterval&apos;)</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        document.getElementById(&apos;par&apos;).removeChild(document.getElementById(&apos;Node&apos;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;!-- setinterval依旧一直在打印 --&gt;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/null和undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/02/null和undefined/" itemprop="url">null和undefined</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-02T09:56:21+08:00">
                2020-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先看一个判断题：<code>null</code>和<code>undefined</code> 是否相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(null==undefined)//true</span><br><span class="line">console.log(null===undefined)//false</span><br></pre></td></tr></table></figure>

<p>观察可以发现：<code>null</code>和<code>undefined</code> 两者相等，但是当两者做全等比较时，两者又不等。</p>
<p><code>null</code>类型，代表“空值”，代表一个空对象指针，使用<code>typeof</code>运算得到<code>object</code>，可以认为它是一个特殊的对象值。<code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。<strong>是不应该有值。</strong></p>
<p><code>undefined</code>类型，当一个声明了一个变量未初始化时，得到的就是<code>undefined</code>。<strong>是应该有值，但是尚未赋值</strong></p>
<ul>
<li><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</li>
</ul>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象。</li>
<li>作为对象原型链的终点。</li>
</ol>
<ul>
<li><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</li>
</ul>
<ol>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于<code>undefined</code>。</li>
<li>对象没有赋值的属性，该属性的值为<code>undefined</code>。</li>
<li>函数没有返回值时，默认返回<code>undefined</code>。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/浏览器多个标签页之间通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jerry's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/02/浏览器多个标签页之间通信/" itemprop="url">浏览器多个标签页之间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-02T09:41:21+08:00">
                2020-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="调用localStorage"><a href="#调用localStorage" class="headerlink" title="调用localStorage"></a>调用<code>localStorage</code></h3><p>在一个标签页里面使用 <code>localStorage.setItem(key,value)</code>添加（修改、删除）内容；在另一个标签页里面监听 <code>storage</code> 事件。即可得到 <code>localstorge</code> 存储的值，实现不同标签页之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index1.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var bt = document.getElementById(&apos;btn&apos;)</span><br><span class="line">        bt.onclick = function () &#123;</span><br><span class="line">            localStorage.setItem(&quot;name&quot;, &apos;I am the value of name&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index2.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function (event) &#123;</span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="调用cookie-setInterval"><a href="#调用cookie-setInterval" class="headerlink" title="调用cookie + setInterval()"></a>调用<code>cookie + setInterval()</code></h3><p><a href="https://www.runoob.com/js/js-cookies.html" target="_blank" rel="noopener">参考</a></p>
<p>将要传递的信息存储在<code>cookie</code>中，每隔一定时间读取<code>cookie</code>信息，即可随时获取要传递的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index1.html--&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var bt = document.getElementById(&apos;btn&apos;)</span><br><span class="line">        bt.onclick = function () &#123;</span><br><span class="line">            document.cookie=&quot;username=John Doe&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index2.html--&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function getCookie(key) &#123;</span><br><span class="line">           return document.cookie;</span><br><span class="line">        &#125;</span><br><span class="line">        setInterval(function () &#123;</span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));</span><br><span class="line">        &#125;, 10000);    </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jerry">
            
              <p class="site-author-name" itemprop="name">Jerry</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
